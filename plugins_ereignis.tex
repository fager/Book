%revised
\index{Ereignis-Plugins}%
\chapter{Ereignis-Plugins}

\index{Events}%
\index{Hooks}%
Ereignis-Plugins dienen der Erweiterung von Funktionen im Frontend wie auch im Backend.
Serendipity setzt innerhalb seines Quellcodes an zahlreichen strategisch
wichtigen Stellen sogenannte \emph{Event-Callbacks} bzw. \emph{Event-Hooks}. An
dieser Stelle des Codes führt Serendipity also nacheinander alle installierten Ereignis-Plugins aus,
so dass jedes Plugin an dieser Stelle die Möglichkeit erhält, seine
eigenen Funktionen auszuführen. Die Reihenfolge, in der die Ereignis-Plugins in
der Plugin-Verwaltung aufgeführt sind, bestimmt dabei auch die
Ausführungsreihenfolge.

\label{Textformatierungs-Plugins}%
\index{Plugins!Textformatierungen}%
\index{Textformatierungs-Plugins}%
Bei den Textformatierungs-Plugins ist die
Ausführungsreihenfolge besonders wichtig. Ein Textformatierungs-Plugin
kann bei Artikeltexten und auch Kommentartexten dazu benutzt werden,
Text- oder Formatierungsänderungen durchzuführen. Daher reichen solche
Plugins von einfachen Wort\-ersetzungen (\cmd{s9y} könnte z.\,B.\
überall durch \cmd{Serendipity} ersetzt werden) über 
Smiley-Ersetzungen (\cmd{:-)} wird zu einem grinsenden Gesicht) bis
zu speziellen Plugins, die Quelltexte in beliebigen Programmiersprachen
korrekt einrücken und darstellen.

Stellen Sie sich ein Textformatierungs-Plugin vor (\emph{Plugin A}), das
das Wort \cmd{*doof*} in eine besondere Grafik verwandelt. Ein
zweites \emph{Plugin B} kümmert sich darum, dass alle Wörter, die von
Sternchen (\cmd{*}) umgeben sind, im Artikel später fett geschrieben
werden. Wenn Plugin A vor Plugin B platziert wird, sehen
Sie nach der Umwandlung des Wortes \cmd{*doof*} wie gewünscht eine
schöne Grafik. Wäre Plugin B jedoch das zuerst ausgeführte Plugin,
würden Sie in der Ausgabe nur ein fettes Wort \cmd{doof} sehen. Denn
nachdem Plugin B alle Wörter mit umgebenden Sternchen umgewandelt hat,
kann das Smiley-Plugin das Wort \cmd{*doof*} nicht mehr
finden.

Die Plugin-Reihenfolge ergibt sich also meist abhängig von Ihrem
persönlichen Einsatz des Plugins, daher können keine allgemeinen
Aussagen getroffen werden, welches Plugin an welcher Stelle stehen muss.

Textformatierungs-Plugins werden also immer erst bei der Ausgabe
angewendet und bieten Ihnen den Komfort der einfacheren Eingabe. Wer
möchte schon jedesmal den kompletten HTML-Code für eine Smiley-Grafik
einfügen? 

Ihre Eingaben werden ganz unabhängig von der späteren Formatierung in der
Datenbank gespeichert -- wenn Sie also einen Artikel später überarbeiten, werden
sämtliche Formatierungsänderungen dort noch nicht angezeigt, da sie nur bei der
Anzeige angewendet werden und nicht beim Speichern der Rohdaten. Das bedeutet
auch, dass sämtliche von einem Textformatierungs-Plugin vorgenommenen Änderungen
nicht mehr ausgeführt werden, wenn Sie dieses Plugin löschen. Seien Sie also
vorsichtig beim Löschen von Plugins und prüfen Sie, ob dadurch möglicherweise
alte Artikel nicht mehr so dargestellt werden, wie Sie es erwarten.

Eine weitere Besonderheit von Textformatierungs-Plugins ist, dass alle diese
Plugins eine Konfigurationsoption anbieten, um einzustellen, auf welche
Ausgabefelder eine Formatierung angewendet wird. So können Sie einstellen, ob
eine Formatierung nur auf normale Artikeltexte, erweiterte Artikeltexte,
Kommentare von Besuchern oder HTML-Klötze (siehe Seite
\pageref{htmlnugget}) angewendet wird. Im Eingabefeld für Kommentare von
Besuchern kann jedes Textformatierungs-Plugin eigene Hinweise einblenden, 
wie deren Syntax zu benutzen ist.

\label{Standardpluginkonfiguration}%
\index{Ereignis-Plugins!häufige Konfigurationsoptionen}%
Mehrere Ereignis-Plugins bieten die Möglichkeit, beliebige Inhalte
innerhalb Ihres Blogs einzubinden: eigenständige HTML-Seiten (statische
Seiten), Gästebücher, Kontaktformulare und weitere. Alle diese Plugins
haben einen Satz an Konfigurationsoptionen gemeinsam, auf die Sie immer
wieder stoßen werden. Damit diese nicht immer für jedes Plugin wiederholt
werden müssen, werden Sie hier erklärt:

\begin{ospdescription}

\label{Standardpluginkonfiguration-Permalink}%
\index{Plugins!Standard-Konfigurationsoptionen!Permalink}%
\index{Permalinks}%
\ospitem{\menu{Permalink}}
\index{Fehler!falsche Permalinks}%
In das Feld \menu{Permalink} tragen Sie die URL ein, unter der Sie später
die Ausgaben des jeweiligen Plugins wollen. Hier müssen Sie den
vollständigen HTTP-Pfad eintragen, der zu dieser URL führt. Standardmäßig
wird das Feld vorausgefüllt mit
\cmd{/serendipity/pages/plug\-inname.html}, was Ihrem Pfadnamen und einem
virtuellen Pfad entspricht. Im virtuellen Pfadnamen können Sie eine
beliebige Struktur einsetzen. Dabei müssen Sie lediglich darauf achten,
dass die URL mit \cmd{.html} endet, keine Sonderzeichen enthält und
keinem bereits vorhandenen Permalink entspricht. Wichtig ist, dass
diese Variable immer nur eine Pfadangabe enthalten darf, niemals eine
vollständige URL wie \cmd{http://www.example.com/\ldots}. Auch muss
der Stammpfad zum Serendipity-Blog beibehalten bleiben, eine Eingabe wie
\cmd{/anderes\_blog/pages/pluginname.html} wäre ungültig.\footnote{Eine
derartige URL wäre ungültig, da der Aufruf dieser URL außerhalb der
Serendipity-Installation läge. Serendipity kann nur virtuelle
Verzeichnisse unterhalb seiner eigenen Verzeichnisstruktur verwalten.}

Wenn Sie in Ihrem Blog einmal die URL-Umformung (siehe Seite
\pageref{urlformung}) (de-)aktivieren oder Ihr Blog in ein Unterverzeichnis
verschieben, kann es sein, dass Sie die konfigurierten Permalinks aller Plugins
ebenfalls anpassen müssen. Bei deaktivierter URL-Umformung muss ein Permalink
einen Wert wie \cmd{/serendipity/index.php?/pages/""pluginname.html} enthalten.
Erst bei der Pfadangabe hinter \cmd{index.""php?} dürfen Sie eine beliebige URL
eintragen, der Pfad davor muss der Konfiguration Ihres Servers entsprechen.

\index{Plugins!Standard-Konfigurationsoptionen!Pagetitle}%
\index{Plugins!Standard-Konfigurationsoptionen!Seitentitel}%
\index{Plugins!Standard-Konfigurationsoptionen!URL-Titel der Seite}%
\index{Plugins!Standard-Konfigurationsoptionen!URL shorthand name}%
\label{Standardpluginkonfiguration-Pagetitle}%
\ospitem{\menu{URL-Titel der Seite, Seitentitel, Pagetitle oder URL shorthand
name}}
Alternativ zu der Konfiguration eines Permalinks bieten alle Plugins auch
einen \emph{URL-Titel der Seite} oder \emph{URL shorthand name} an.
Mithilfe dieser Variable kann man die Ausgaben eines Plugins auch ohne
Permalink ansehen, indem man

\begin{ospcode}
http://www.example.com/serendipity/index.php?serendipity[subpage]=
Seitentitel
\end{ospcode}

aufruft.
Dies ist wichtig, da in manchen Webserver-Konfigurationen ein Permalink
nicht mit Formulardaten beschickt werden kann.\footnote{Konkret ist dies
bei der Nutzung der URL-Umformungsmethode \cmd{Apache Error\-Hand\-ling}
nicht möglich. Eine URL wie
\cmd{/serendipity/""pages/""seite.html?""variable=inhalt} würde keine
GET-Variable \cmd{\$\_GET['variable']} erzeugen, die die Plugins
teilweise jedoch benötigen, um abhängig von der Anfrage des Besuchers
bestimmte Inhalte anzuzeigen.}

\index{Template-Variablen!\$staticpage\_pagetitle}%
Tragen Sie für den URL-Titel einer Seite ausschließlich Namen ohne
Sonderzeichen, Umlaute und Leerzeichen ein. Beinahe alle Plugins weisen
den Wert der \cmd{serendipity[subpage]}-Variable der Smarty-Variablen
\cmd{\{\$staticpage\_pagetitle\}} zu. Über diese Variable kann man
individuell in den Templates bei speziellen Plugins unterschiedliche
Template-Ausgaben erreichen (siehe Seite \pageref{Smarty-Templates}).

\label{Standardpluginkonfiguration-Articleformat}%
\index{Plugins!Standard-Konfigurationsoptionen!Als Artikel formatieren}%
\ospitem{\menu{Als Artikel formatieren}}
Wenn Sie die Option \menu{Als Artikel formatieren} aktivieren, wird
Serendipity die Ausgabe eines Plugins so darstellen, als sei dies ein
normaler Blog-Artikel. Um die Ausgabe herum wird also das übliche
HTML-Konstrukt erzeugt, das Serendipity standardmäßig ausgibt (mit
Seitenüberschrift und Datum).

Wenn Sie diese Option deaktivieren, werden die Ausgaben 1:1
weitergereicht und in den Inhaltsbereich von Serendipity eingefügt. Das
heißt, dass Serendipity sich in jedem Fall um die Ausgabe des HTML-Kopf-
und -Fußkonstruktes sowie der Seitenleisten-Plugins kümmert, aber sonstige
Überschriften nicht ausgibt.

\end{ospdescription}


%revised
\section{Standardmäßig aktivierte Plugins}

Die im Folgenden behandelten Ereignis-Plugins werden bei Serendipity mitgeliefert und sind
standardmäßig aktiviert.

\index{Anti-Spam}%
\index{Spamblock}%
\index{Spamschutz}%
\label{spamblock}%
\index{Plugins!Spamschutz}%
\index{Plugins!serendipity\_event\_spamblock}%
\subsection{Spamschutz\newline serendipity\_event\_spamblock}

Das Plugin, das den Rekord für die höchste Anzahl von
Konfigurationsoptionen hält, ist sicherlich das \emph{Spamschutz}-Plugin.
Erschrecken Sie nicht davor, sondern gehen Sie die Möglichkeiten ruhig
nacheinander durch. Die Voreinstellungen des Plugins sind für gewöhnliche
Zwecke bereits recht gut geeignet.

\index{Spam}%
Anhand der Fülle verschiedener Optionen wird eines recht deutlich: Der
Kampf gegen Spam (unerwünschte Werbung) ist extrem müßig und mit viel
"`Wenn"' und "`Aber"' verbunden. Einen optimalen Schutz gegen Spam
kann Ihnen auch dieses Buch leider nicht geben, dafür ändern sich die
Techniken der Spammer zu häufig.

\index{Akismet}%
\index{Captchas}%
Als probates Mittel hat sich die Verwendung des \emph{Akismet}-Services
erwiesen. Dieser zentrale Server führt schwarze Listen von
Kommentarspam-Fällen und kann von vielen Blogsystemen genutzt werden,
darunter Serendipity, WordPress und MoveableType. Auch die Aktivierung
von Captchas reduziert Kommentarspam sehr deutlich, bringt aber
auch Usability-Einschränkungen mit sich.

Dafür ermöglichen es Ihnen aber viele der aufgeführten Optionen, flexibel
auf neue Gegebenheiten eingehen zu können. Daher sollten Sie das
Folgende aufmerksam durchlesen, um im Bedarfsfall schnell auf Spam
reagieren zu können.

Das Spamschutz-Plugin wird jeweils aufgerufen, wenn in Ihrem Blog jemand
einen Kommentar oder ein Trackback hinterlässt. Das Plugin prüft
daraufhin, was der Benutzer übermittelt hat, und führt nacheinander
mehrere Tests aus. Sobald einer der aktivierten Tests einen Kommentar als
Spam markiert, wird der Artikel speziell vorgemerkt. Das Plugin merkt
sich daraufhin, aufgrund welcher Maßnahme ein Artikel als Spam
identifiziert wurde. Denn wie bei der Spam-Filterung bei E-Mails kann es
leicht vorkommen, dass auch gültige Nachrichten aufgrund einer
Filterregel als Spam klassifiziert worden sind. Daher ist es wichtig,
die Filter von vornherein nicht zu "`scharf"' einzustellen und
ab und zu die Logdateien nach falsch eingestuftem Spam durchzugehen.

Wenn ein Kommentar als Spam identizifiert ist, können zwei Dinge
geschehen: Entweder er wird komplett verworfen, oder er wird moderiert.
Moderierte Kommentare müssen erst von einem Redakteur freigeschaltet
werden. Komplett verworfene Kommentare werden erst gar nicht in der
Datenbank gespeichert, und der Redakteur wird von einem solchen Kommentar
nie etwas erfahren. Nur auf zu moderierende Kommentare wird ein
Redakteur möglicherweise per E-Mail hingewiesen (abhängig von den
Einstellungen des Redakteurs bezüglich E-Mail-Benachrichtigungen, siehe
Seite \pageref{einstellungen-commentnotify}).

Bei vielen Anti-Spam-Optionen können Sie einstellen, ob beim Zutreffen
einer einzelnen Regel die Nachricht verworfen oder moderiert werden soll.
Sobald die erste Regel zutrifft, die eine Nachricht verwirft, ist die
Ausführung des Anti-Spam-Plugins beendet. Daher ist es durchaus möglich,
dass ein Kommentar von einer Regel erst als "`moderiert"'
eingestuft wird, dann aber eine Folge-Filterregel den Kommentar doch
"`abweist"'. Das Abweisen hat also Priorität vor der Moderation.

Wenn Sie einen Artikel bereits mit aktivierter Option \menu{Kommentare
und Trackbacks dieses Eintrags werden moderiert} erstellt haben, kann das
Anti-Spam-Plugin dennoch Kommentare abweisen. Ein Kommentar kann dann
jedoch niemals ohne Moderation veröffentlicht werden. Wenn Sie die Option
\menu{Kommentare für diesen Eintrag zulassen} bei einem Artikel
deaktiviert haben, ist das Anti-Spam-Plugin für diesen Artikel
irrelevant, da sämtliche Kommentare abgewiesen werden.

\begin{ospdescription}

\index{Plugins!Spamschutz!Notfall-Blockade von Kommentaren}%
\ospitem{\menu{Notfall-Blockade von Kommentaren}}
Wenn gerade eine Spam-Welle über Sie hereinbricht, können Sie diese
Option aktivieren, um im Blog keinerlei Kommentare oder Trackbacks
anzunehmen. Weitergehende Blockademaßnahmen können Sie auf Seite 
\pageref{commentphp} nachlesen.

Empfohlene Einstellung: \emph{Nein}

\index{Plugins!Spamschutz!Spamblock für Autoren deaktivieren}%
\ospitem{\menu{Spamblock für Autoren deaktivieren}}
Häufig können Sie den angemeldeten Autoren des Blogs vertrauen, dass sie
keine Spam-Einträge in Ihrem Blog vornehmen. Daher können Sie mit der
Einstellung \menu{Spamblock für Autoren deaktivieren} dafür sorgen, dass
alle eingeloggten Redakteure bei Kommentaren von keinerlei
Anti-Spam-Maßnahmen betroffen sind (Einstellung \menu{Alle Autoren}).
Eingeloggte Autoren sehen also keine Captcha-Grafiken und werden nicht
anderweitig von Filterungen behelligt. Wenn Sie das Auswahlfeld auf
\menu{keine} stellen, unterscheidet das Plugin nicht zwischen anonymen
und eingeloggten Besuchern.

Ansonsten können Sie in diesem Feld gezielt Benutzergruppen auswählen.
Wenn Sie das Plugin \emph{Freie Benutzer-Registrierung} benutzen, ist
dies besonders sinnvoll, um "`anonyme"' Redakteure dennoch von den
"`echten"', manuell erzeugten Redakteuren unterscheiden zu können. Achten
Sie dann einfach darauf, dass die Benutzergruppe der Redakteure, die über das
Registrierungs-Plugin hinzugefügt werden, nicht im Auswahlfeld markiert
ist.

Empfohlene Einstellung: \emph{Alle Autoren}

\index{IP-Filterung}%
\index{Plugins!Spamschutz!Trackback IP Validierung}%
\ospitem{\menu{Trackback IP Validierung}}
Wenn Sie von einem fremden Blog ein Trackback erhalten (siehe Seite
\pageref{trackback}), dann wird dieses Trackback von einem bestimmten Server aus
gesendet. In einem Trackback selbst ist die URL des fremden Blogs enthalten.

Im üblichen Fall entspricht die IP-Adresse des Servers, der das
Trackback sendet, genau der IP-Adresse der URL, die im Trackback enthalten
ist.

Bei Spam sieht dies anders aus: Die Trackbacks werden von infizierten
Computersystemen aus verschickt, und die beworbene URL entspricht meist
der von Spam-Seiten und liegt auf einem völlig anderen Server.

Das Antispam-Plugin kann solche Trackbacks automatisch abweisen, wenn die
IPs des sendenden Servers und des beworbenen Servers nicht
übereinstimmen.

Die Aktivierung dieser Option ist sehr empfehlenswert, da es im täglichen
Einsatz de facto nicht zu einer fehlenden Übereinstimmung bei echten
Trackbacks kommen kann. Lediglich in Randfällen wie Servern, die
Trackbacks über Proxy-Server verschicken müssen, kann dies gültige
Trackbacks verwerfen. Wägt man den positiven Nutzen des Schutzes vor
ungültigem Spam dagegen ab, ist dieser Nachteil jedoch leicht zu
verschmerzen.

Empfohlene Einstellung: \emph{abweisen}

\index{Plugins!Spamschutz!Keine doppelten Kommentare erlauben}%
\ospitem{\menu{Keine doppelten Kommentare erlauben}}
Üblicherweise sollte es in einem Blog nie dazu kommen, dass identische
Kommentare mehrfach vorkommen. Daher können Sie Kommentare sperren, die
bereits in der Datenbank vorhanden sind, wenn Sie die Option \menu{Keine
doppelten Kommentare erlauben} auf \menu{Ja} stellen.

Viele Spammer variieren ihre Inhalte durch zufällig erzeugte Buchstaben
und sind daher von dieser Einstellung nicht betroffen. Dennoch kann diese
Anti-Spam-Maßnahme auch helfen, doppelte profane Kommentare wie
"`super!"' zu unterbinden.

Empfohlene Einstellung: \emph{Ja}

\index{Plugins!Spamschutz!Kommentare abweisen, die als Text nur den Artikeltitel enthalten}%
\ospitem{\menu{Kommentare abweisen, die als Text nur den Artikeltitel
enthalten}}
Eine beliebte Form des Kommentar-Spams stellte einmal die Methode dar, bei
einem Kommentar einfach den Titel Ihrer eigenen Artikel zu übernehmen.
Anstelle eines Links zu einem fremden Artikel erhielten Spammer ihren
Nutzen dadurch, dass deren Benutzername oder Homepage auf eine fremde URL
verwies.

Wenn Sie diese Option aktivieren, werden solche Kommentare verboten.
In der freien Wildbahn treten derartige Spam-Kommentare kaum noch auf,
daher ist es empfehlenswert, die Option aus Geschwindigkeitsgründen
besser zu deaktivieren.

Empfohlene Einstellung: \emph{Nein}

\index{IP-Adresse!sperren}%
\label{ipblock}%
\index{Plugins!Spamschutz!IP-Block Intervall}%
\ospitem{\menu{IP-Block Intervall}}
\index{IP}%
Jeder Besucher des Blogs besitzt eine eigene IP, die den Benutzer im
Internet identifiziert. Üblicherweise hat somit jeder Besucher der
Webseite eine eindeutige IP, die sich jedoch bei jeder neuen Einwahl des
Benutzers ins Internet unterscheiden wird. Mit einer so gewonnenen
IP-Adresse kann man versuchen, Kommentare von dort nach gewissen
Kriterien zu unterbinden.

\index{Proxy}%
IP-Adressen sind jedoch leider keine verlässliche Maßnahme. Wenn ein
Besucher einen sogenannten \emph{Proxy}\footnote{Ein Proxy ist eine
Art Webserver, der die Inhalte fremder Webseiten zwischenspeichern kann, um so
Traffic zu reduzieren oder Inhalte leichter zu filtern.} benutzt,
werden seine Zugriffe über die IP-Adresse dieses Servers durchgeführt.
Der Proxy verschleiert also die wahre Identität des Besuchers. Da große
Unternehmen wie T-Online und auch AOL für ihre Benutzer zentrale
Proxy-Server benutzen, könnte man also beim Blocken einer solchen IP
nicht nur den Zugriff für eine einzelne Person verhindern, sondern für
alle Besucher, die diesen Proxy verwenden.

Kurzum, Sie sollten der IP-Adresse kein absolutes Vertrauen schenken.
Dennoch kann es helfen, Missbrauch auf gewisse Weise einzudämmen. Die
Option \menu{IP-Block Intervall} ermöglicht es, dass eine eindeutige IP
nur einmal einen Kommentar eintragen darf, und dann erst wieder nach Ablauf
des konfigurierten Zeitraums. Somit ist es nicht mehr möglich, mehrere
hundert Kommentare pro Sekunde abzusetzen.

In Blogs passiert es selten, dass Benutzer (auch die Benutzer eines Proxies) 
im Minutentakt gewünschte Kommentare hinterlassen. Daher ist ein
Zeitraum von einer Minute hier durchaus empfehlenswert.

Die Abweisung eines Kommentars mittels dieser Option erfolgt erst bei
der Abarbeitung eines bereits übermittelten Kommentars. Das heißt, der
eigentliche Zugriff auf das Blog wird anhand dieser Option nicht
eingeschränkt.

Empfohlene Einstellung: \emph{60}.

\index{CSRF}%
\index{XSRF}%
\index{Plugins!Spamschutz!CSRF-Schutz aktivieren}%
\ospitem{\menu{CSRF-Schutz aktivieren?}}
Die meisten Spam-Kommentare erfolgen, indem ein Spam-Roboter automatisch
Ihre URLs aufruft und einen Kommentar überträgt. Meist macht sich der
Roboter nicht die Mühe, vorher (wie ein normaler Blog-Besucher) die
eigentliche Webseite aufzurufen. Dieses Vorgehen kann man sich zur Abwehr
zunutze machen: Man speichert auf der Seite, von der aus das
Kommentarformular eingebunden wird, einen Zufallswert. Nur wenn dieser
Zufallswert gültig mit dem Kommentar vom Browser des Besuchers
übermittelt wird, kann man davon ausgehen, dass ein menschlicher Besucher
auch vorher den Artikel aufgerufen hat und dass nicht einfach etwas automatisiert
übertragen wird.

Die Aktivierung dieser Option hat leider einen gravierenden Nachteil.
Denn damit der eingegebene Zufallswert auf dem Server zur Prüfung
zwischengespeichert werden kann, muss eine Session (siehe Terminologie,
Seite \pageref{sessioncookies}) für den Besucher angelegt werden. Eine Session
ist jedoch von Serendipity nur nutzbar, wenn der Browser des Besuchers Cookies annimmt
(siehe Hinweis Seite \pageref{Cookie}).

Weiterhin bringt diese Option einen Schutz vor
\emph{CSRF}\footnote{\emph{Cross Site Request Forgery} nennt man den
Versuch eines fremden Benutzers, Ihren Browser fernzusteuern und damit 
Aktionen auszulösen, die Sie selbst gar nicht
ausführen möchten.}. Dies führt zu Angriffen, bei denen ein böswilliger Benutzer
Sie dazu bringen könnte, ungewollt Kommentare zu verfassen oder sogar
freizuschalten.

Empfohlene Einstellung: \emph{Ja}.

\index{Plugins!Spamschutz!Captchas aktivieren}%
\index{Captchas}%
\ospitem{\menu{Captchas aktivieren}}
Captchas (siehe Seite \pageref{Captcha}) sind kleine Grafiken mit schwer
zu lesenden Zeichenkombinationen. Damit ein Besucher einen Kommentar
schreiben darf, muss er die dargestellten Zeichen in eine Box abtippen,
um sich dem System gegenüber als "`Mensch"' auszuweisen.

Captcha-Grafiken müssen eine gewisse Komplexität aufweisen, damit sie
tatsächlich nicht von Computern überlistet werden können. Dies kann dazu
führen, dass es auch den Besuchern immer schwerer fällt, die Captchas
zu entziffern. Dennoch bietet diese Maßnahme eine der effektivsten
Möglichkeiten, automatisierten Spam zu unterbinden.

Mit der Option \menu{Stärkere Captchas} können Sie die Komplexität der
Grafiken noch weiter erhöhen, indem weitere Zufallsmuster eingefügt
werden. Diese Option ist mehr für den "`Spam der Zukunft"' vorgesehen
und sollte derzeit glücklicherweise noch nicht erforderlich sein.

\index{gdlib}%
Um Captchas anzeigen zu können, sollte Ihr Server die PHP \emph{gdlib}
anbieten. Andernfalls werden die Zeichenfolgen mit Grafikdateien
zusammengebaut, was von Spam-Robotern um einiges einfacher zu umgehen
ist. Damit Ihre Besucher Captchas ausfüllen können, müssen sie
in ihrem Browser Cookies annehmen. Wie Sie die Captcha-Grafiken anpassen
können, ist auf Seite \pageref{Captcha-anpassen} ausgeführt.

Empfohlene Einstellung: \emph{Ja}.

\index{Plugins!Spamschutz!Captchas nach wie vielen Tagen erzwingen}%
\ospitem{\menu{Captchas nach wie vielen Tagen erzwingen}}
Da Captchas gerade für sehbehinderte Menschen große Probleme schaffen,
möchte man diese Grafiken so selten wie möglich erforderlich machen.

Da Spammer mit Vorliebe alte Artikel in Ihrem Blog als Ziel nehmen (da
diese Artikel bei Suchmaschinen bereits besser vertreten sind), sind
häufig neue Artikel des Blogs nicht betroffen.

Dies können Sie ausnutzen, indem Sie Captchas nur dann einblenden, wenn
ein Artikel ein gewisses Alter erreicht hat. Das Mindestalter tragen Sie
in Tagen ein. Wenn Sie \emph{0} eintragen, werden Captchas auch bei
aktuellen Artikeln direkt eingebunden.

Empfohlene Einstellung: \emph{14}.

\index{Plugins!Spamschutz!Hintergrundfarbe des Captchas}%
\ospitem{\menu{Hintergrundfarbe des Captchas}}
Die Captcha-Grafik wird unterhalb des Eingabeformulars für einen Kommentar
eingebunden. Je nach Design Ihres Blogs möchten Sie die Hintergrundfarbe
dieser automatisch erzeugten Grafiken sicher anpassen. Daher können Sie bei
dieser Option eine Farbe im RGB-Format eintragen. Drei Zahlen repräsentieren hier,
von einem Komma voneinander getrennt, den Farbwert von \emph{Rot, Grün} und \emph{Blau}.
Wer sich an die Farbenlehre erinnern kann, weiß, dass man mit diesen drei
Primärfarben jede andere vom Monitor darstellbare Farbe abbilden kann. Um
diese Farbwerte leicht herauszufinden, können Sie kleine Tools wie etwa den Colorpicker\footnote{\cmd{http://www.pagetutor.com/colorpicker/index.html}} benutzen.

Empfohlene Einstellung: \emph{255,255,255} (Weiß)

\index{Plugins!Spamschutz!Kommentarmoderation nach wievielen Tagen erzwingen}%
\ospitem{\menu{Kommentarmoderation nach wievielen Tagen erzwingen}}
Bei besonders alten Artikeln ist es sehr selten, dass Besucher noch
gewünschte Kommentare hinterlassen. Blogs sind meistens so tagesaktuell,
dass ältere Artikel schnell an "`Kommentarwert"' verlieren. Dies können
Sie also ausnutzen, um Kommentare zu alten Artikeln von vornherein
auszusortieren.

Wenn Sie hier die Zahl \cmd{0} eintragen, wird diese Möglichkeit der
automatischen Moderation deaktiviert. Eine Zahl wie \cmd{60} bewirkt,
dass Artikel älter als zwei Monate nicht ohne Ihre Zustimmung kommentiert
werden können.

Empfohlene Einstellung: \emph{60}

\index{Plugins!Spamschutz!Was soll mit auto-moderierten Kommentaren passieren}%
\ospitem{\menu{Was soll mit auto-moderierten Kommentaren passieren?}}
Üblicherweise werden Kommentare zu Artikeln, die Sie mit der Option
\menu{Kommentarmoderation nach wievielen Tagen erzwingen} gefiltert
haben, in der Datenbank gespeichert, aber nicht freigeschaltet.

Über die Option \menu{Was soll mit auto-moderierten Kommentaren
passieren} können Sie mit solchen Kommentaren auch noch härter verfahren
und Kommentare vollständig \menu{abweisen}.

Empfohlene Einstellung: \menu{moderieren}

\index{Plugins!Spamschutz!Trackbackmoderation nach wievielen Tagen erzwingen}%
\ospitem{\menu{Trackbackmoderation nach wievielen Tagen erzwingen}}
Ähnlich der Einstellung für Kommentare können auch Trackbacks nach einem
gewissen Zeitraum automatisch moderiert werden.

Empfohlene Einstellung: \emph{60}

\index{Plugins!Spamschutz!Was soll mit auto-moderierten Trackbacks passieren}%
\ospitem{\menu{Was soll mit auto-moderierten Trackbacks passieren?}}
Ähnlich der Einstellung für Kommentare können die durch automatische
Moderation erfassten Trackbacks entweder moderiert oder verworfen werden.

Empfohlene Einstellung: \emph{moderieren}

\index{Plugins!Spamschutz!Behandlung von per API übermittelten Kommentaren}%
\ospitem{\menu{Behandlung von per API übermittelten Kommentaren}}
Es gibt bei Serendipity grundsätzlich zwei Möglichkeiten, als Benutzer
eine Mitteilung zu einem Blog-Artikel zu hinterlassen. Zum einen sind das
Kommentare, die direkt im Blog eingetragen werden. Hierbei ist also eine
Interaktion des Benutzers notwendig, Captchas und andere Anti-Spam-Maßnahmen
können in den Prozess eingebunden werden.

Anders ist dies bei Trackbacks. Derartige "`Kommentare"' werden von einem
automatischen System verschickt und empfangen, daher können dort keine
Captchas zwischengeschaltet werden. Solche automatische Methoden
bezeichnet man daher als API (siehe Terminologie auf Seite \pageref{API}).
Sie können derartige Kommentare, die immer von Computern übermittelt
werden, gezielt behandeln: Entweder werden solche Kommentare
\menu{abgewiesen}, oder sie müssen von Ihnen \menu{moderiert} werden.

Wenn Sie automatisch übermittelte Kommentare gleichrangig wie via
Formular eingetragene Kommentare behandeln wollen, können Sie die Option
\menu{keine} wählen.

Da das Aktivieren der automatischen Moderation meist eine große E-Mail-Flut von
Benachrichtigungen mit sich bringt und man gültige von ungültigen Trackbacks
schwer trennen kann, macht eine pauschale Moderation von Trackbacks selten
Sinn. Nur wenn Sie auf Trackbacks vollständig verzichten wollen, sollten Sie die
Option auf \menu{abweisen} stellen.

Empfohlene Einstellung: \emph{keine}

\index{Plugins!Spamschutz!Trackback URLS@Trackback-URLS prüfen}%
\ospitem{\menu{Trackback-URLS prüfen}}
Der Sinn eines Trackbacks ist, dass ein fremdes Blog Sie darauf hinweisen
kann, dass es sich auf einen Ihrer Artikel bezieht. Daher muss ein
Trackback immer die URL des fremden Blogs enthalten, auf dem sich jemand
zu Ihrem Artikel äußert.

Bei Spam ist das meistens nicht der Fall -- die URL, die das Trackback
bewirbt, enthält meistens nur besondere Angebote zum preiswerten Bezug
von Viagra oder tolle Vorschläge, wie man reich werden kann. Für die
Spammer wäre es ein hoher Aufwand, sich dort tatsächlich auf Ihren
Blog-Artikel zu beziehen.

Diese Nachlässigkeit der Spammer können Sie ausnutzen und mit der Option
\menu{Trackback-URLs prüfen} einstellen, ob alle Trackback-URLs daraufhin
geprüft werden sollen, ob sie die URL Ihres Artikels enthalten.

\index{Traffic}%
Die Aktivierung dieser Option birgt jedoch zwei Gefahren: Wenn ein
Spammer eine ungültige URL oder eine URL mit besonders
vielen Daten hinterlässt, dann wird Ihr Webserver diese Seite gnadenlos trotzdem
aufrufen und viel Traffic verursachen. Da die URL-Prüfung ausgeführt
wird, während das Trackback gespeichert wird, kann dies die Dauer der
Prüfung sehr in die Länge ziehen und Ihren Server stark auslasten.
Zusätzlich darf bei der Aktivierung dieser Option der Webserver nicht von
einer Firewall blockiert werden, damit fremde URLs überhaupt aufgerufen
werden können.

Die zweite Gefahr ist, dass Sie möglicherweise Trackbacks abweisen, die
eigentlich gültig wären. Manche Blogsysteme senden ein Trackback an Ihr
Blog nämlich bereits, bevor der eigene Artikel veröffentlicht wurde. Das
Blogsystem würde also erst dann seinen Artikel mit dem Link zu Ihnen
online stellen, wenn das Trackback an Sie abgearbeitet wurde. Da Sie aber
bereits bei der Annahme des Trackbacks die Existenz der fremden URL
voraussetzen, würde das Trackback fehlschlagen.

Empfohlene Einstellung: \emph{Nein}

\index{Plugins!Spamschutz!Erforderliche Anzahl an Links für Moderation}%
\ospitem{\menu{Erforderliche Anzahl an Links für Moderation}}
Viele Spammer nennen in ihren Kommentaren einfach zahlreiche Links und
hoffen, dass Ihre Besucher diese Links anklicken. Es ist
üblicherweise ungewöhnlich, dass Kommentatoren Ihrer Artikel dutzende von
Links an Sie schicken, daher können Sie in diesem Optionsfeld eine Anzahl
von Links angeben, bei deren Erreichen ein Kommentar automatisch
moderiert werden soll.

Empfohlene Einstellung: \emph{7}

\index{Plugins!Spamschutz!Erforderliche Anzahl an Links für Abweisung}%
\ospitem{\menu{Erforderliche Anzahl an Links für Abweisung}}
Die Anzahl der erforderlichen Links im oberen Eingabefeld dient nur der
Moderation eines Kommentars. Wenn Sie ab einer gewissen Anzahl von Links
aber einen Kommentar direkt abweisen wollen, können Sie dies im Feld
\menu{Erforderliche Anzahl an Links für Abweisung} eintragen.

Empfohlene Einstellung: \emph{13}

\index{Wortfilter}%
\index{Blacklist}%
\label{Wortfilter}%
\index{Plugins!Spamschutz!Wortfilter aktivieren}%
\ospitem{\menu{Wortfilter aktivieren}}
In den folgenden großen Eingabefeldern können Sie Zeichenketten
eintragen. Sobald eine dieser Zeichenketten in einem Kommentar vorkommt
("`Blacklisting"'), kann ein Kommentar speziell behandelt werden.

Wie diese Behandlung ausfallen soll, stellen Sie über die Option
\menu{Wortfilter aktivieren} ein. Ob Sie diese auf \menu{moderieren} oder
\menu{abweisen} stellen, hängt davon ab, wie "`scharf"' Sie Ihre
Wortfilter einstellen. Wenn Sie beispielsweise das Wort \cmd{arsch}
filtern, dann ist das erstmal ein guter Gedanke. Vielleicht denken Sie
aber nicht daran, dass ja diese Zeichenkette auch bei dem Wort
"`marschieren"' vorkommen könnte und in diesem Fall keineswegs
filterungswürdig wäre. Hätten Sie den Wortfilter hier auf \menu{abweisen}
gestellt, wäre ein Kommentar mit diesem Wort vollständig verloren, und
der Besucher wundert sich womöglich, warum sein Kommentar nicht
angenommen wurde.

Daher ist es ganz wichtig, dass Sie die folgenden Wortfilter so eng
wie möglich fassen, um gültige Buchstabenkonstellationen nicht auch zu
verhindern. Für obiges Beispiel wäre daher der Einsatz von
\cmd{\raisebox{-2.5pt}{$\sqcup$}arsch\raisebox{-2.5pt}{$\sqcup$}} eher
zu empfehlen. Durch die zusätzlichen Leerzeichen würde der Filter nur
noch dann aktiv werden, wenn das Wort isoliert vorkommt.

Empfohlene Einstellung: \emph{abweisen}

\index{Plugins!Spamschutz!Wortfilter für URLs, Autorennamen, Inhalt und E-Mail-Adressen}%
\ospitem{\menu{Wortfilter für URLs, Autorennamen, Inhalt und E-Mail-Adressen}}
Auf jedes Feld, das ein Kommentator ausfüllt, können Sie einen
Wortfilter anwenden.

Die zu filternden Wörter müssen mit dem Semikolon (\cmd{;}) getrennt
werden. Wenn Sie am Zeilenende angelangt sind, können Sie vor oder nach
diesem Semikolon auch gerne einen Zeilenumbruch (\taste{Return}-Taste)
zur besseren Lesbarkeit einfügen.

Jedes eingetragene Wort wird dabei einzeln auf das Vorhandensein im
Kommentar geprüft. Trifft eines der Wörter zu, wird der Kommentar
entsprechend der Wortfilter-Einstellung entweder moderiert oder
abgewiesen.

\index{Reguläre Ausdrücke}%
\label{regexp}%
Sämtliche Wortfilter werden als "`reguläre
Ausdrücke"'\footnote{\cmd{http://de.wikipedia.org/wiki/Regul\%C3\%A4rer\_Ausdruck}}
%FM einfach nur ae? Zeichensalat im PDF bei der URL 
%GH Geht leider nicht, da dann Wikipedia die URL nicht anerkennt
%GH @ Satz: Muss irgendwie hingekriegt werden so dass die URL-Entities enthalten
%   sind
interpretiert. Dies ist eine spezielle Syntax, in der Sie auch
Platzhalter verwenden können. Reguläre Ausdrücke sind ein Thema
für sich, aber hier ein Beispiel für einen Wortfilter-Ausdruck:

\begin{ospcode}
{\textbackslash}@[^{\textbackslash}s]+{\textbackslash}.jp{\textbackslash}s
\end{ospcode}

Dieser Ausdruck würde einen Kommentar dann sperren, wenn jemand eine 
E-Mail-Adresse angibt, die zu einer japanischen Domain führt. Ein Kommentar wie
"`Mail me at shyguy@yahoo.jp"' würde also blockiert werden.

\index{Escaping}%
Aufgrund des Einsatzes von regulären Ausdrücken gibt es bei den
Wortfiltern Besonderheiten für Zeichen, die bei regulären Ausdrücken
besonders genutzt werden. Solche Zeichen muss man, wenn sie im Wort
vorkommen sollen, \emph{escapen}. Dazu stellt man einfach den Backslash
(\textbackslash) vor eines der folgenden Sonderzeichen:

\begin{ospcode}
@ [ ] ( ) \{ \} . ? * ^ \$ | + -
\end{ospcode}

Wenn Sie also die große Flexibilität von regulären Ausdrücken nicht
nutzen wollen, können Sie die Wortfilter auch ganz einfach als
Wortliste verwenden. Einzig beim Auftreten eines Sonderzeichens müssen
Sie daran denken, den Backslash voranzustellen.

\index{Fehler!bei der Kommentarabgabe}%
Wenn Sie ungültige reguläre Ausdrücke eingeben, kann dies zu PHP-Fehlermeldungen bei der
Kommentarabgabe führen oder sogar dazu, dass keinerlei Kommentare mehr
gespeichert werden können. In diesem Fall sollten Sie versuchen, alle
Wortfilter zu löschen. Wenn es danach wieder klappt, können Sie nach und
nach die ursprünglichen Zeichenketten wieder einfügen und so
herausfinden, welche Regel falsch war.

Empfohlene Einstellung: \emph{Keine Empfehlung möglich}

\index{Plugins!Spamschutz!URL-Filterung anhand der blogg.de Blacklist aktivieren}%
\ospitem{\menu{URL-Filterung anhand der blogg.de Blacklist aktivieren}}
Der Blog-Provider \cmd{blogg.de} hat in der Vergangenheit eine Liste von URLs
geführt, die von Spammern benutzt wurden. Serendipity kann einen
Kommentar mit dieser schwarzen Liste abgleichen und bei einem Treffer
nach Wunsch \menu{moderieren} oder \menu{abweisen}.

Aufgrund des hohen Pflegeaufwands ist die Blacklist dieses Providers
seit längerer Zeit nicht mehr aktiv, daher ist die Aktivierung dieser
Option zum jetzigen Zeitpunkt zwecklos. Möglicherweise wird die Blacklist
irgendwann wieder aktiviert, daher wird diese Option weiterhin angeboten.

Empfohlene Einstellung: \emph{keine}

\label{Akismet}%
\index{Akismet}%
\index{Plugins!Spamschutz!Akismet API Key}%
\ospitem{\menu{Akismet API Key}}
\emph{Akismet} ist ein zentraler Web-Service, der eine Schnittstelle für
Blogsysteme wie WordPress, Serendipity und MoveableType anbietet. Ein
Kommentar wird vollständig an den Service übermittelt, der Service
überprüft den Kommentar und sieht nach, ob er Spam-Kriterien aufweist.

Da sehr viele Systeme Spam an diesen Service melden und die Datenbank
bereits sehr groß ist und aktiv gepflegt wird, kann Akismet relativ
verlässlich entscheiden, ob ein Kommentar Spam darstellt oder nicht.

Wenn Sie den Akismet-Dienst benutzen wollen, benötigen Sie einen
sogenannten API-Key, den Sie mit der Anmeldung\footnote{\cmd{http://akismet.com}} erhalten. Sie müssen ihn dann im
Spamschutz-Plugin im Konfigurationsfeld \menu{Akismet API Key} eintragen.

Die Abfrage des Akismet-Servers kann nur klappen, wenn Ihr Webserver
nicht von einer Firewall am Verbindungsaufbau gehindert wird.

Beachten Sie bei der Benutzung von Akismet, dass es auch hier zu
falsch erkanntem Spam kommen kann und dass in besonders geschützten
Intranet-Blogs Kommentare so an einen zentralen Server übertragen werden,
über den Sie keine Kontrolle haben. Blogs, bei denen Sie schützenswerte
Inhalte hinterlegen, sollten Sie daher nicht mit Akismet betreiben.

Empfohlene Einstellung: \emph{Akismet-Schlüssel beantragen!}

\index{Plugins!Spamschutz!Behandlung von Akismet-Spam}%
\ospitem{\menu{Behandlung von Akismet-Spam}}
Mit dieser Option legen Sie fest, wie von Akismet erkannter Spam
behandelt werden soll. Sie können derartigen Spam entweder
\menu{moderieren} oder \menu{abweisen}.

Der große Komfort von Akismet und die relativ geringe Fehlerquote
ermöglichen es, diese Option auf \menu{abweisen} einzustellen. So
erhalten Sie wirklich nur noch Moderationshinweise von Kommentaren, bei
denen die Einstufung als Spam aufgrund anderer Spamschutz-Kriterien nicht
eindeutig war.

Empfohlene Einstellung: \emph{abweisen}

\index{E-Mail-Adresse!verstecken}%
\index{Plugins!Spamschutz!E-Mail-Adressen bei Kommentatoren verstecken}%
\ospitem{\menu{E-Mail-Adressen bei Kommentatoren verstecken}}
Wird ein Kommentar bei einem Blog-Artikel angezeigt, sehen Sie auch
die Informationen zu demjenigen, der den Kommentar verfasst hat. Dabei
kann (je nach Template) auch die E-Mail-Adresse angezeigt werden, die
wiederum Spam-Roboter in Ihrem Blog sammeln könnten, um den
Kommentatoren mit Werbenachrichten zu belästigen.

Um dies zu verhindern, können Sie die E-Mail-Adresse Ihrer Besucher mit der
Option \menu{E-Mail-Adressen bei Kommentatoren verstecken} stets
ausblenden, bzw. automatisch mit der Dummy-Adresse \cmd{nospam@ex\-ample.com}
ersetzen.

Als Administrator können Sie die echte E-Mail-Adresse nach wie vor in der
Backend-Kommentar-Oberfläche einsehen.

Empfohlene Einstellung: \emph{Ja}

\index{Plugins!Spamschutz!auf ungültige E-Mail-Adressen prüfen}%
\ospitem{\menu{Auf ungültige E-Mail-Adressen prüfen?}}
Grundsätzlich ist es möglich, dass Kommentatoren in Ihrem Blog eine ungültige E-Mail-Adresse eintragen. Gerade
Spammer können dies benutzen, um statt einer E-Mail-Adresse einfach eine
Homepage zu übertragen.

Das Spamschutz-Plugin kann dies in gewissem Maße einschränken und eine
(grobe) Prüfung durchführen, ob eine E-Mail-Adresse ein gültiges Muster
besitzt (also \cmd{\cmdvar{user}@\cmdvar{domain.land}}).

Wenn Sie diese Option aktivieren, kann Serendipity jedoch nicht prüfen,
ob die E-Mail-Adresse auch tatsächlich existiert. Fantasie"=Adressen mit
gültigem Muster können also so nicht abgefangen werden.

Empfohlene Einstellung: \emph{Ja}

\index{Plugins!Spamschutz!Pflichtfelder}%
\ospitem{\menu{Pflichtfelder}}
Wenn ein Kommentator die Formularfelder ausfüllt, um einen Kommentar zu
hinterlassen, gibt es eine Reihe von optionalen Feldern. Serendipity
lässt Kommentare zu, bei denen lediglich der Kommen\-tartext ausgefüllt
wird und ansonsten alle Angaben anonym sind.

Wenn Sie dies verhindern wollen, können Sie Pflichtfelder im
Kommentarformular definieren. Alle Pflichtfelder tragen Sie dabei in dem
Eingabefeld ein. Folgende Felder stehen zur Verfügung: \menu{name} (Name
des Kommentators), \menu{email} (E-Mail-Adresse), \menu{url} (Homepage),
\menu{comment} (Kommentartext). Ein weiteres Feld ist \menu{replyTo}, das
angibt, auf welchen vorausgehenden Kommentar sich ein Benutzer bezieht.
Dieses Feld als Pflichtfeld zu bestimmen macht meistens keinen Sinn, weil
man einen Besucher dadurch zwingt, sich auf einen existierenden Kommentar
zu beziehen.

Wenn Sie Pflichtfelder definieren, müssen Sie Ihre Besucher auch darüber
in Kenntnis setzen. Schlagen Sie dazu im Kapitel \ref{commenttemplates} auf
Seite \pageref{commenttemplates} nach, wie Sie Anpassungen am Kommentarformular
vornehmen können.

Empfohlene Einstellung: \emph{comment}

\index{htaccess@.htaccess}%
\index{Plugins!Spamschutz!Block bad IPs via HTaccess?}%
\ospitem{\menu{Block bad IPs via HTaccess?}}
Eine sehr experimentelle Option stellt \menu{Block bad IPs via HTaccess}
dar. Innerhalb einer \cmd{.htaccess}-Datei können Sie bei
Apache-Webservern Regeln definieren, um Besucher mit einer bestimmten
IP-Adresse abzulehnen.

Diese Besucher können dann das gesamte Blog nicht mehr aufrufen und
belasten dabei glücklicherweise auch das System nur noch minimal -- denn
Serendipity kommt selbst gar nicht mehr zum Zuge, um den Aufruf dieses
Besuchers zu bearbeiten, da der Webserver ihn bereits zuvor abgewiesen
hat.

Derartige Verbote können mittels des Befehls \cmd{Deny From
\cmdvar{IP"=Adres\-se}} vorgenommen werden. Dieses Kommando stellt eine
Blacklist von ein oder mehreren IP-Adressen dar und könnte auch manuell
in der \cmd{.htaccess}-Datei eingestellt werden.

Das Spamschutz-Plugin ermöglicht jedoch eine interessantere Art der
Einbindung. Jedesmal, wenn beim Prüfen eines Kommentars dieser
abgewiesen wird, merkt sich das Spamblock-Plugin die IP der Person, die
diesen Kommentar hinterlassen hat. So entsteht eine Liste, mit der
man herausfinden kann, von welchen IPs in letzter Zeit Spam geschickt
wurde. Sobald dieser Tabelle eine IP hinzugefügt wird, aktualisiert das
Plugin die \cmd{.htaccess}-Datei und sperrt den Zugriff für alle IPs, die
in den letzten zwei Tagen dort eingetragen worden sind.

Daher kann ein Besucher mit einer "`verdächtigen"' IP-Adresse frü\-hes\-tens nach zwei
Tagen erneut probieren, einen Kommentar zu hinterlassen.

Der große Vorteil dieser Sperrungsart ist, dass Spammern so schnell die
Server-Ressourcen entzogen werden können. Die Nachteile sind jedoch, dass
zum einen nur Apache-Webserver mit dieser Option arbeiten können und man
zum anderen möglicherweise einen zu großen Benutzerkreis blockiert (siehe
Anmerkungen zur Option \menu{IP-Block Intervall} auf Seite
\pageref{ipblock}). Benutzen Sie die Option daher nur, wenn Sie wissen,
was sie bewirkt.

Empfohlene Einstellung: \emph{Nein}

\index{Wartung!Logfiles}%
\index{Plugins!Spamschutz!Protokollierung von fehlgeschlagenen Kommentaren}%
\ospitem{\menu{Protokollierung von fehlgeschlagenen Kommentaren}}
Wenn ein Kommentar oder Trackback moderiert oder abgewiesen
wird, bemerken Sie dies als Redakteur möglicherweise gar nicht. Daher
ermöglicht das Spamschutz-Plugin, solche Meldungen entweder in der
Datenbank oder in einer Datei zu speichern.

Dieses Protokoll können Sie dann von Zeit zu Zeit prüfen, um
herauszufinden, ob Ihre Anti-Spam-Einstellungen in der Gesamtheit noch
Wirkung haben.

Wenn Sie das Protokoll in einer \menu{Einfachen Datei} speichern, müssen
Sie einen Speicherplatz angeben. Sie können diese Datei dann von Zeit zu
Zeit herunterladen und auf dem Server wieder löschen, damit sie
nicht zu groß wird.

\index{Datenbank-Tabellen!serendipity\_spamblocklog}%
Für die Auswertung von Protokollen ist die Speicherung in einer \menu{Datenbank} sicher
empfehlenswerter. Die Datenbanktabelle \cmd{serendipi\-ty\_spamblocklog} können Sie
mit einem Programm wie \emph{phpMyAdmin} komfortabel ansehen und nach bestimmten
Kriterien filtern.\osplinebreak{} Fortgeschrittene Benutzer können die Datenbanktabelle nutzen,
um sich kleine Scripte zu schreiben, die täglich oder wöchentlich Statusberichte
per E-Mail verschicken oder auch im Blog anzeigen. Auch diese Datenbanktabelle
sollten Sie von Zeit zu Zeit leeren, um nicht zu viele alte Daten vorzuhalten.

\index{Plugins!Spamschutz!Speicherplatz für das Logfile}%
\ospitem{\menu{Speicherplatz für das Logfile}}
Wenn Sie die Protokollierung in eine einfache Datei aktiviert haben,
müssen Sie hier den vollständigen Dateisystem-Pfad auf dem Server
eintragen, wo das Logfile gespeichert werden soll. Der Webserver muss
Schreibrechte zu diesem Verzeichnis haben, daher können Sie z.\,B.\ auch Ihr
\cmd{uploads}-Verzeichnis dafür verwenden.

\end{ospdescription}

Unterhalb der Konfigurationsoptionen bindet das Plugin noch eine kleine
Vorschaugrafik der Captchas ein. Dort können Sie sehen, wie ein Captcha
für einen Besucher aussieht, und gegebenenfalls Änderungen der
Hintergrundfarbe vornehmen.

\label{Captcha-anpassen}%
\index{Captchas!Grafiken anpassen}%
\index{gdlib}%
Die Art der Captcha-Grafiken richtet sich danach, ob Ihr Webserver
das PHP-Modul \emph{gdlib} unterstützt. Ohne \emph{gdlib} gibt das
Spamblock-Plugin PNG-Grafiken im Verzeichnis
\cmd{plugins/serendipity\_event\_""spamblock} direkt aus. Für jeden
Buchstaben gibt es eine eigene \cmd{captcha\_""\cmdvar{zeichen}.png}-Da\-tei,
die Sie mit einem Bildbearbeitungsprogramm anpassen können.

\index{Schriftarten}%
\index{TTF}%
Wenn \emph{gdlib} vorhanden ist, gilt:
Die verwendeten Schriftarten der Captchas können Sie nur mit
etwas Aufwand verändern. Das Plugin kann mit beliebigen TTF-Schriftdateien, wie
sie Windows mitliefert, umgehen. Diese Dateien liegen im Verzeichnis
\cmd{plugins/serendipity\_event\_spamblock} und sind standardmäßig auf
die vier Schriftarten Vera, VeraSE, Chumbly und 36daysago beschränkt. Das
Auswahlkriterium der Schriftarten war, dass diese möglichst nicht
maschinenlesbar sein sollen. Wenn Sie lieber eine eigene, besser lesbare
Schriftart benutzen wollen, können Sie die vorhandenen TTF-Dateien 
mit anderen ersetzen und müssen dabei die Dateien lediglich umbenennen.

Das Plugin wählt zufällig eine der vier verfügbaren Schriftarten aus.
Wenn Sie mehr als vier Schriftdateien benutzen wollen, müssen Sie die
Plugin-Datei
\cmd{plugins/serendipity\_event\_spamblock/serendipity\_event\_\osplinebreak{}spamblock.php}
öffnen und bearbeiten. Suchen Sie nach der Zeile

\begin{ospcode}
\$fontfiles = array('Vera.ttf', 'VeraSe.ttf', 'chumbly.ttf', 
'36daysago.ttf');
\end{ospcode}

Dort müssen Sie (jeweils in Anführungszeichen) den Namen der Schriftdatei
kommasepariert eintragen.

Etwas oberhalb dieser Codezeile findet sich auch die Angabe, wie groß die
Captcha-Grafik ist:

\begin{ospcode}
\$width = 120; 
\$height = 40;
\end{ospcode}

Mit den beiden Zahlen \cmd{120} (Breite) und \cmd{40} (Höhe) können
Sie die Bildgröße anpassen.

Die Schriftgröße müssen Sie über eine weitere Variable anpassen, die
ebenfalls in der Nähe der obigen Stellen erscheint:

\begin{ospcode}
\$size  = mt_rand(15, 21);
\end{ospcode}

Diese Zeile bewirkt, dass das Plugin zufällig eine Schriftgröße zwischen
15 und 21 für jeden einzelnen Buchstaben benutzt. Sie können diese beiden
Zahlen auf den gewünschten Wert erhöhen (z.\,B.\ 21 und 26), um größere
Schriften anzuzeigen.

Das Plugin verzichtet bei der Ausgabe der Schriften auf einige Zeichen,
die häufig missverständlich aussehen. Die Zahlen 1, 5, 6 und 8 sowie die
Buchstaben I, O und S werden daher ausgelassen. Wenn Sie weitere
Buchstaben ausschließen wollen, können Sie auch diese in der
Spamschutz-Datei ändern. Suchen Sie dafür folgende Code-Stelle und passen
Sie sie an:

\input{snippets/spamblock}

\index{Plugins!Browser-Kompatibilität}%
\index{Plugins!serendipity\_event\_browsercompatibility}%
\subsection{Browser-Kompatibilität\newline 
serendipity\_event\_browsercompatibility}

\index{Fehler!Grafiken sind gestaucht/gestreckt}%

\index{Transparente Grafiken}%
\index{PNG-Transparent}%
Eines der simpelsten Ereignis-Plugins ist das
Plugin namens \emph{Browser"=Kompatibilität}. Es wurde damals erstellt, um ein
gravierendes Problem des Microsoft Internet Explorer 6 zu beheben. Dieser
Browser konnte standardmäßig keine Grafiken mit mehrstufiger
transparenter Hintergrundfarbe anzeigen, während alle anderen am Markt
verfügbaren Browser damit kein Problem hatten.

Leider war (und ist) dieser Browser stark verbreitet, aber Serendipity
sollte dennoch in der Lage sein, Icons mit transparentem Hintergrund in
der Oberfläche anzuzeigen. So sind beispielsweise die Grafiken des Uhr"=Symbols
oder des Hammers transparente Grafiken, die bei jeder
Hintergrundfarbe eingebunden werden können.

Mit Hilfe dieses Plugins konnte eine einfache Regel in die Ausgabe von
Serendipity aufgenommen werden, so dass die Grafiken dargestellt werden
können. Ursprünglich war geplant, auch weitere Browser-Unterschiede mit
diesem Plugin auszubügeln. Dies war jedoch seither nie wieder
nötig.

Wenn in Zukunft Version 7 des Internet Explorers noch größere Verbreitung
hat, wird dieses Plugin also nicht mehr erforderlich sein. Auch
heutzutage ist es eigentlich nur dann notwendig, wenn Sie die
Administrationsoberfläche mit Internet Explorer 6 ohne merkwürdige
Hintergrundfarben einsetzen wollen.

Einen gravierenden Nachteil hat dieses Plugin jedoch. Das Plugin sorgt
dafür, dass der Browser eine PNG-Grafik intern als Hintergrundbild
interpretiert und eine unsichtbare GIF-Grafikdatei darüberlegt. Das
klappt nur dann einwandfrei, wenn ein Bild im HTML-Code so eingebunden
ist, dass die \emph{width}- und \emph{height}-Angaben des
\emph{<img>}-Tags vorhanden sind. Fehlt diese Angabe, wird die PNG-Grafik
womöglich gestaucht oder in die Länge gestreckt. Wenn Sie also
später PNG-Grafiken in Ihrem Blog hinzufügen, achten Sie immer darauf,
dass die width/height-Angaben vorhanden sind. Oder benutzen Sie
alternativ das GIF- oder JPEG-Grafikformat, wenn die Transparenz nicht
wichtig ist. Eine weitere Möglichkeit bestünde natürlich darin, das
Plugin \emph{Browser-Kompatibilität} zu entfernen und darüber hinwegzusehen,
dass Besucher mit dem alten Internet Explorer 6 möglicherweise
eine pinke Hintergrundfarbe statt Transparenz sehen.

Das Plugin besitzt keine Konfigurationsoptionen.

\index{Plugins!Textformatierung: Serendipity}%
\index{Plugins!serendipity\_event\_s9ymarkup}%
\subsection{Textformatierung: Serendipity\newline serendipity\_event\_s9ymarkup}

\index{Fehler!falsche Textformatierung im Artikel}%

Das Textformatierungs-Plugin \emph{Serendipity} bietet einige ganz
einfache Umwandlungen für Ihre Artikeltexte an. Diese Umwandlungen sind
an alte Mailbox-Hervorhebungsmöglichkeiten angelehnt und stammen noch aus
einer Zeit, in der Formatierung via HTML gänzlich unbekannt war. Daher
haben sich viele alte Hasen an derlei Formatierung gewöhnt und können 
damit leichter umgehen als mit HTML-Code:

\begin{osplist}
\item \cmd{*Wort*} formatiert ein Wort fett.
\item \cmd{\_Wort\_} unterstreicht ein Wort.
\item \cmd{\^{}Wort\^{}} setzt ein Wort hochgestellt.
\item \cmd{@Wort@} setzt ein Wort tiefgestellt.
\end{osplist}


Aufgrund dieser besonderen Konventionen kann das
Serendipity"=Textformatierungs"=Plugin besonders bei Artikeln mit
Quellcode-Inhalten Probleme verursachen. Wenn Sie in einem Artikel
PHP-Code zitieren, könnten die oben aufgeführten Sonderzeichen ungewollte
HTML-Formatierungen auslösen.

Sie können dieses Problem meist beheben, indem Sie das Plugin im
Bedarfsfall für einen einzelnen Beitrag deaktivieren (über die
zusätzlichen Artikeloptionen des Plugins \emph{Erweiterte Eigenschaften
für Artikel}, siehe Seite \pageref{entryproperties}) oder indem Sie es 
vollständig deinstallieren. Wenn Sie das Plugin in Zusammenhang mit anderen
Quellcode-Hervorhebungs-Plugins benutzen, achten Sie möglichst darauf,
dass das Serendipity-Textformatierungs-Plugin als letztes
Textformatierungs-Plugin in der Plugin-Liste aufgeführt wird.

\label{emoticate}%
\index{Smileys}%
\index{Plugins!Textformatierung: Smilies}%
\index{Plugins!serendipity\_event\_emoticate}%
\subsection{Textformatierung: Smilies\newline  serendipity\_event\_emoticate}



Das wohl gebräuchlichste Textformatierungs-Plugin nennt
sich \emph{Smilies}. Es ersetzt typische Smiley-Zeichenketten wie :-) durch
einen grafischen Smiley.

Wenn Sie die Konfigurationsoptionen des Plugins aufrufen, sehen Sie eine
Liste aller verfügbaren Smiley-Umwandlungen. Auch Besucher können, falls
gewünscht, in ihren Kommentaren auf die Smiley-Grafiken zurückgreifen.

Vielfach wird den Serendipity-Smileys vorgeworfen, dass sie ziemlich
hässlich aussähen. Zum einen ist das natürlich Geschmackssache, aber zum
Teil kann man das auch nicht ganz von der Hand weisen. Da Serendipity
so freizügig wie möglich lizensiert wurde, können nur Smiley-Grafiken mit
Serendipity ausgeliefert werden, die derselben Lizens unterliegen. Die
meisten Smileys, die im Internet zu haben sind, sind jedoch entweder nur
kommerziell oder inkompatibel lizensiert oder von den Seiten ohne
Befugnis eingebaut. Da die Smiley-Grafiken auch mit einem
Serendipity-Template zusammen gebündelt werden können, gibt es auch
einige (wenige) Templates mit eigenen Grafikdateien: \emph{GreenMile},
\emph{kamouflage} und \emph{truth}.

Als Betreiber des Blogs können Sie aber glücklicherweise die Grafiken
einfach ersetzen. Das Plugin versucht Ihnen das so einfach wie möglich
zu machen, daher gibt es mehrere Möglichkeiten, eigene Smileys
einzubinden.

\begin{ospdescription}
\ospitem{Variante 1: Grafikdateien ersetzen}
Die einfachste Methode ist, die Smiley-Grafikdateien von
Serendipity durch eigene zu ersetzen. Diese Dateien befinden sich
standardmäßig im Verzeichnis \cmd{templates/default/emoticons/}. Die
Dateien haben eine \cmd{.png}-Dateiendung, Sie können aber auch die
Smiley-üblichen \cmd{.gif}-Dateien hochladen, wenn Sie in der
Konfiguration des Smilie-Plugins danach als \menu{Dateiendung} für
Smileys auch \cmd{.gif} eintragen.

Sie können die eigenen Smiley-Dateien entweder direkt in das genannte
Verzeichnis hochladen oder auch in ein gleichnamiges Unterverzeichnis
eines eigenen Templates. Wenn Sie die Dateien in ein eigenes
Template-Verzeichnis hochladen, werden die Grafiken automatisch von dort
eingebunden und Sie haben den Vorteil, später die Grafiken
zusammenhängend mit Ihrem Template archivieren oder verteilen zu können.

\ospitem{Variante 2: Smileys erweitern}
Beim Ersetzen von Smileys können Sie natürlich keine neuartigen Smileys
hinzufügen, sondern nur die bestehenden überarbeiten.

Um eigene zu erstellen, kann das Plugin eine Datei 
\cmd{emoticons.""inc.""php} auswerten. Diese Datei muss ein Array enthalten,
in dem Smileys beschrieben und einer Grafik zugewiesen werden.

Standardmäßig würde eine Datei so aussehen:

\input{snippets/emoticons.tex}

Pro Zeile sehen Sie jeweils den Text, der durch eine Grafik ersetzt
werden soll, und danach auf der rechten Seite einen Aufruf, der auf die
entsprechende Grafikdatei verweist.

Wenn Sie sich mit regulären Ausdrücken (siehe Seite \pageref{regexp})
auskennen, können Sie auch Smileys mit solchen Ausdrücken definieren.
Damit ist es leichter, diverse Plugin-Alternativen zu beschreiben, z.\,B.\
dass sowohl :-) als auch :) zur selben Grafik umgewandelt werden. Damit
das Array \cmd{\$serendipity['custom\_emoticons']} diese regulären
Ausdrücke nutzen kann, müssen Sie eine weitere Variable 

\begin{ospcode}
\$serendipity['custom_emoticons_regexp'] = true;  
\end{ospcode}

innerhalb der
\cmd{emoticons.inc.php} definieren.
\end{ospdescription}

\index{Plugins!Textformatierung: NL2BR}%
\index{Plugins!serendipity\_event\_nl2br}%
\subsection{Textformatierung: NL2BR \newline serendipity\_event\_nl2br}
\label{nl2br}%
\index{Fehler!Zeilenumbrüche werden nicht umgewandelt}%
\index{Fehler!ungewollte Zeilenumbrüche im Text}%

Das Plugin \emph{NL2BR} ist ein ebenfalls recht simples
Textformatierungs-Plugin. Es sorgt einfach dafür, dass von Ihnen
eingegebene Zeilenumbrüche in einem Beitrag später in einen korrekten
HTML-Zeilenumbruch (\cmd{<br />}) umgewandelt werden.

Das ist notwendig, weil der HTML-Standard normale Zeilenumbrüche nicht
als solche erkennt. Auch mehrere hintereinander eingetragene
Leerzeichen werden von HTML als ein einziges Leerzeichen
zusammengefasst.

Wenn Sie also ohne dieses Plugin Beiträge schreiben, müssten Sie selber
die korrekten HTML-Absätze (entweder mittels \cmd{<p>...</p>} oder
\cmd{<br />}) einfügen. Je nachdem, ob Sie einen WYSIWYG-Editor einsetzen,
tut dies der Editor auch bereits selbständig.

Wenn Sie also bei selbständiger Eingabe überflüssige Zeilenumbrüche in
Ihren Artikeln haben, sollten Sie das \emph{NL2BR}-Plugin deinstallieren.

Abhängig vom eingesetzten Template kann es sein, dass das Template die
Abstände zwischen Absätzen (den \cmd{<p>}-Tags) mittels
CSS-Formatierungen deaktiviert. Die eigentlich zu erwartenden Leerzeilen
zwischen zwei Absätzen würden somit also unterdrückt werden. In älteren
Templates wurde dies hauptsächlich deshalb eingefügt, um doppelte
Zeilenumbrüche in Verbindung mit dem \emph{NL2BR}-Plugin zu vermeiden.
Wenn Sie ein derartiges Template einsetzen, können Sie eine einfache
CSS-Formatierung am Ende der \cmd{style.css}-Datei  im entsprechenden
\cmd{templates}-Unterverzeichnis einfügen:

\begin{ospcode}
.serendipity\_entry p \{
  margin: 1em;
\}
\end{ospcode}

Dadurch wird der Abstand (\emph{margin}) zwischen Paragraphen auf eine
relative Einheit gesetzt, die dem üblichen Absatzabstand entspricht.

Ein weiteres Problem kann auftreten, wenn Sie in einem
Beitrag JavaScript oder anderweitigen Sourcecode platzieren möchten. Denn
auch hier würde das Plugin relativ stur sämtliche Leerzeichen durch
\cmd{<br />} umwandeln und dadurch JavaScript ungültig machen oder Ihre
spezielle Sourcecode-Formatierung in einem
\cmd{<blockquote>}-HTML-Konstrukt mit überflüssigen HTML-Zeilenumbrüchen
stören. Es gibt mehrere
Möglichkeiten (abgesehen vom Deinstallieren des NL2BR-Plugins), dieses Problem zu beheben:

\begin{osplist}
\item NL2BR-Plugin fallweise für einen einzelnen Artikel
    deaktivieren. Dies können Sie beim Erstellen eines Artikels im
    Abschnitt \emph{Erweiterte Optionen} erledigen, wenn Sie das
    Ereignis-Plugin \emph{Erweiterte Eigenschaften von Artikeln}
    installiert haben.

\item In der Konfiguration des NL2BR-Plugins die Liste von
    geschützten HTML-Tags so ändern, dass keine Zeilenumbrüche
    zwischen ungewünschten Tags eingefügt werden. So können Sie z.\,B.\
    \cmd{script} mit in die kommaseparierte Tagliste aufnehmen, damit
    das NL2BR-Plugin keine Zeilenumbrüche in JavaScript-Containern
    einfügt.

\item Bei der Reihenfolge der Textformatierungs-Plugins darauf achten,
    dass das NL2BR-Plugin als letztes ausgeführt wird. Dadurch wird
    verhindert, dass die Zeilenumbrüche zu früh eingefügt werden und
    möglicherweise andere Textformatierungs-Plugins durcheinanderbringen.
\end{osplist}

\section{Weitere mitgelieferte Plugins}

Über die bereits vorinstallierten Ereignis-Plugins hinaus liefert
Serendipity noch einige weitere Ereignis-Plugins mit, die Sie direkt über
die Plugin-Verwaltung installieren können.

Beachten Sie, dass bei Textformatierungs-Plugins die Reihenfolge der
Plugins für die endgültige Formatierung maßgeblich sein kann (siehe Seite
\pageref{Textformatierungs-Plugins}).

\index{Plugins!Textformatierung: BBCode}%
\index{Plugins!serendipity\_event\_bbcode}%
\subsection{Textformatierung: BBCode\newline serendipity\_event\_bbcode}

\index{BBCode}%
BBCode ist eine sehr weit verbreitete Möglichkeit, um einfachste
Formatierungen (fett, kursiv, Hyperlinks) durchzuführen. Grundsätzlich
könnte man sich natürlich auch die nicht viel komplizierteren HTML-Tags
aneignen, aber aus mehreren Gründen sollte man darauf verzichten.

BBCode wird seltener von den Redakteuren selbst
genutzt, sondern meist von Besuchern, die ihre Kommentare im Blog mittels
BBCode formatieren können. HTML stellt ein grundlegendes
Sicherheitsrisiko dar, wenn beliebige Besucher derartige Formatierungen auf
die Webseite setzen können. Denn in HTML kann man JavaScript einbinden,
das ungewünschte, sicherheitsrelevante Funktionen
auslösen kann -- so könnten möglicherweise Logindaten ausgespäht werden,
oder der Inhalt der Seite könnte von gewitzten Benutzern vollständig abgeändert
werden. Kurzum, als Betreiber eines Blogs sollte man es vermeiden,
HTML-Kommentare zuzulassen. Serendipity verhindert dies aus
Sicherheitsgründen vollständig, daher ist die einzige Möglichkeit zur
Formatierung von Kommentaren die Benutzung von Standards wie BBCode. Denn
diese Formatierungen können problemlos und sicher in HTML umgesetzt
werden. BBCode ist aufgrund seiner hohen Verbreitung so allgegenwärtig,
dass die Kommentatoren meist Kenntnis davon haben. Nicht nur Blogs,
sondern auch Internetforen oder auch E-Mail-Programme "`sprechen"' oft
BBCode.

Auch bei der Artikelerstellung kann BBCode hilfreich sein -- die Syntax,
um eine HTML-Auflistung zu erstellen, ist wesentlich unkomplizierter als
entsprechender HTML-Code.\footnote{Eine Auflistung von BBCodes gibt
\cmd{http://de.wikipedia.org/wiki/BBcode}.} BBCodes sind immer von eckigen
(statt bei HTML spitzen) Klammern umgeben. Um ein Wort zu fetten, würde man
\cmd{[b]Wort[/b]} verwenden, Bilder kann man mittels
\cmd{[img]http://www.ex\-ample.com/bild.jpg[/img]} einbinden und Hyperlinks
via \cmd{[url]http:""//www.example.com[/url]}. Die erwähnten Auflistungen
kann man mittels \cmd{[list] [*]Punkt [*]Punkt ... [/list]} formatieren.

In den Konfigurationsoptionen des Plugins können Sie zudem einstellen, ob
von BBCode formatierte Links standardmäßig in einem neuen Fenster
geöffnet werden sollen.

\index{Plugins!Textformatierung: Textile}%
\index{Plugins!serendipity\_event\_textile}%
\subsection{Textformatierung: Textile\newline serendipity\_event\_textile}

\index{Textile}%
Textile ist in Grundzügen ähnlich zu BBCode, benutzt jedoch eine leicht
andersartige (Wiki-ähnliche) Syntax, die manche Personen bevorzugen. Auf
eckige Klammern wird zugunsten von Formatierungen wie 
\cmd{"{}Mein Blog"{}:""http://www.example.com/serendipity/} verzichtet. 
Darüber hinaus bietet Textile eine weitaus höhere Abstraktion als BBCode. Während
BBCode so einfach wie möglich gehalten ist, bietet Textile eine
Flexibilität, mit der man fast ganz auf HTML verzichten kann.\footnote{Unter
\cmd{http://thresholdstate.com/articles/4312/the-textile-reference"=manual} finden Sie die vollständige Textile-Syntax.}

Textile ist eine relativ komplexe Bibliothek, die auch mehr Ressourcen
verbraucht als das BBCode-Plugin. Daher wird sie meist eher von
Redakteuren benutzt als von Kommentatoren.

Da Textile auch weitaus mehr Formatierungsmöglichkeiten für beliebiges
HTML enthält, sollten Sie sich gut überlegen, ob Sie diese Flexibilität
auch den Kommentatoren anbieten wollen, die so möglicherweise das Layout
innerhalb der Kommentare durcheinanderbringen könnten.

In den Konfigurationsoptionen des Plugins können Sie einstellen, ob die
Textile-Bibliothek in Version 1.0 oder 2.0 genutzt werden soll.

\index{Plugins!Textformatierung: Wiki}%
\index{Plugins!serendipity\_event\_textwiki}%
\subsection{Textformatierung: Wiki\newline serendipity\_event\_textwiki}
\index{Wiki}%

Eine sehr verbreitete und beliebte Form der Textauszeichnung stellt das
sogenannte \emph{Wiki markup} dar. Diese Formatierungsart hat aufgrund
des Wikipedia-Booms hohe Verbreitung gefunden. Da Wikis erschaffen wurden,
um auch Leuten ohne HTML-Kenntnisse die Möglichkeit zu bieten,
gemeinsam formatierte Texte zu erfassen, ist die Syntax dieses Plugins
ebenfalls einfach gehalten.

\index{PEAR}%
Serendipity benutzt hierfür das mitgelieferte PEAR Text::Wiki-Paket,
um die Wiki-Syntax in HTML umzuformen. Dieses PEAR-Paket hat eine gewaltige
Anzahl an Konfigurationsoptionen, mit denen Sie die möglichen Eingaben und
Ausgaben des Plugins kontrollieren können. Alle Optionen entsprechen
dabei den Optionen, die das PEAR-Paket bereitstellt.

Die vollständige Dokumentation der Syntax und der verfügbaren Optionen
befindet sich auf
\cmd{http://wiki.ciaweb.net/yawiki/index.php?area=""Text\_Wiki}.

\index{HTML!in Einträgen nicht dargestellt}%
\index{Eintrag!kein HTML dargestellt}%
Bei der Verwendung des Wiki-Plugins gilt es zu beachten, dass dieses Plugin
sämtliche HTML-Formatierungen eines Artikels umwandelt. So können Sie als
Redakteur keinerlei manuelles HTML mehr einfügen. Dieses Verhalten können
Sie jedoch in der Konfiguration des Plugins abstellen (\emph{Html: Ja}).
Weiterhin können Sie über die Plugin-Optionen auch alle anderen
Umwandlungsvarianten flexibel ein- oder ausschalten.

\index{Plugins!Textformatierung: Externe Links zählen}%
\index{Exit-Tracking}%
\index{Plugins!serendipity\_event\_trackexits}%
\subsection{Textformatierung: Externe Links zählen\newline
serendipity\_event\_trackexits}
\label{trackexits}%

Serendipity kann für Statistiken zählen, wie oft Ihre Besucher auf
externe Links in Ihrem Blog geklickt haben. So ist es für Sie als
Betreiber möglich, herauszufinden, welche von Ihnen genannten URLs für
Ihre Besucher besonders interessant sind.

Sobald ein Besucher eine externe URL klickt, verlässt er Ihr Blog.
Das bedeutet, dass Serendipity üblicherweise gar nicht herausfinden kann,
wenn ein Besucher Ihr Blog verlässt, denn dann findet kein Aufruf der
Seiten auf Ihrem Server mehr statt.

\index{Link Tracking}%
Um dies zu umgehen, müssen also fremde URLs so verändert werden, dass ein
Klick darauf erst Ihrem Blog die angeklickte Seite mitteilt und dann
erst die gewünschte Seite aufgerufen wird. So ein Mechanismus nennt sich
\emph{Link Tracking}. Eine externe URL wie \cmd{http://www.google.de/} 
wird dazu speziell aufbereitet, so dass in Ihrem Artikel ein Link wie
\cmd{http://www.example.""com/serendipity/exit.php?entry\_id=1\&url\_id=1}
erscheint.

Die Datei \cmd{exit.php} erkennt aufgrund der URL-Variablen, welche Seite
angefordert wurde. So kann in einer Datenbanktabelle die Anzahl der
Klicks zu der gewünschten URL mitgezählt und dann der Browser des
Besuchers zu der gewünschten Seite weitergeleitet werden.

Diese Methode ist die einzige Möglichkeit, externe Links
nachzuverfolgen. Die automatische Umformung von Links in das notwendige
Format nimmt das Plugin \emph{Externe Links zählen} vor. Ist dieses
aktiviert, wird jeder HTML-Code wie \cmd{<a
href='http://www.example.com'>Google</a>} erfasst und umgeschrieben.

Dieses Umschreiben hat für Sie Vorteile in der Statistik, für den Benutzer
jedoch mehrere Nachteile. Zum einen kann ein Besucher so eine URL nicht
mehr eindeutig identifizieren. Ob er nach einem Klick darauf wirklich auf
der Seite von Google landet, weiß er vorher noch nicht. Daher werden
viele Besucher (zu Recht) misstrauisch, wenn sie auf derart merkwürdig
formatierte Links stoßen. Den Besuchern wird dadurch auch sofort klar,
dass sie statistisch "`ausgespäht"' werden -- und letztlich kann ein
Besucher auch nicht einfach per Kopieren und Einfügen den Link
übernehmen, sondern er muss ihn erst aufrufen, um herauszufinden, auf welcher
URL er landet.

Überlegen Sie sich also beim Einsatz dieses Plugins gut, ob der
statistische Nutzen für Sie ausschlaggebend ist. In älteren Versionen
Serendipitys war dieses Plugin noch ein Standard-Plugin, wurde aber
aufgrund der Kritik von Blog-Besuchern aus der Standardinstallation
entfernt.

Wenn ein Besucher bei einem Kommentar seine Homepage angibt, kann auch diese
Homepage umgeformt und in der Statistik nachverfolgt werden. Dies hat den
Vorteil, dass potenzielle Spammer die angegebene Homepage nicht mit dem
Suchmaschinenrang Ihres Blogs aufwerten können. In der Konfiguration des Plugins
können Sie dieses Verhalten einstellen: Sie können die Nachverfolgung von
Kommentatoren-Homepages entweder ausstellen (\menu{keine}), Sie können das
angebotene Link Tracking aktivieren (\menu{Serendipity Exit-Tracking Routine})
oder auch auf eine Maskierung von Google (\menu{Google PageRank Deflector})
zurückgreifen. Diese Methode ist ein ähnliches Vorgehen, wie von der
\index{NoFollow-Initiative}%
NoFollow-Initiative\footnote{\cmd{http://de.wikipedia.org/wiki/Nofollow}} gefordert --
man verbietet so den Kommentatoren, vom Suchmaschinen-Wert (dem \emph{Google PageRank})
zu profitieren. Die berechtigte Kritik an diesem Vorgehen ist jedoch, dass man
aufrichtige Kommentatoren ruhig durch die Verlinkung auf ihre Seiten belohnen
soll. Ohne derartige Verlinkungen, die von Suchmaschinen berücksichtigt werden,
wären die Blogs von heute bei weitem nicht so verbreitet und weniger relevant bei
Suchergebnissen.

\index{Plugins!uebliche XHTML-Fehler@übliche XHTML-Fehler beseitigen}%
\index{Plugins!serendipity\_event\_xhtmlcleanup}%
\subsection{Übliche XHTML-Fehler beseitigen\newline
serendipity\_event\_xhtmlcleanup}

\index{XHTML}%
\index{Validierung}%
Da XHTML an XML angelehnt ist, besteht wenig Fehlertoleranz gegenüber
Syntaxfehlern. Sollte ein Redakteur also versehentlich ungültiges XHTML
produzieren, kann dies dazu führen, dass trotz barrierefreier Templates
die Seite nicht mehr validiert.

Abgesehen von logischen Fehlern (HTML-Tags öffnen und sie nicht wieder
schließen oder bei verschachtelten HTML-Tags die Reihenfolge
vertauschen), kann das Serendipity-Plugin \emph{Übliche XHTML-Fehler
beseitigen} dabei helfen, einige gängige Fehlerquellen auszuräumen:

\begin{osplist}
\item Das Sonderzeichen \cmd{\&} darf bei XHTML nur dann benutzt
    werden, wenn daraufhin ein HTML-Sonderzeichen folgt, also
    beispielsweise \cmd{\&gt;} (>), \cmd{\&euro;} (Euro-Symbol) oder
    andere. Wenn Sie jedoch das Zeichen \cmd{\&} auch so in einem
    Artikel anzeigen wollen, müssen Sie \cmd{\&amp;} benutzen.
    Normalerweise geben Redakteure selten HTML-Sonderzeichen ein und
    wissen nicht von der Regel, das \cmd{\&}-Zeichen nicht alleine zu
    setzen. Das Plugin kann sich daher darum kümmern, dass ein
    allein stehendes \cmd{\&} immer zu \cmd{\&amp;} umgewandelt wird.

\item Alle XHTML-Tags müssen immer ein schließendes Element
    verwenden. Ein \cmd{<p>} ist daher nur gültig, wenn auch ein
    schließendes \cmd{</p>} folgt. Das früher verbreitete HTML-Tag
    \cmd{<br>} musste, da es kein schließendes Element voraussetzt,
    zu \cmd{<br />} verändert werden. In den häufigsten Fällen wird
    das \cmd{/>}-Zeichen bei den Tags \cmd{<img>}, \cmd{<hr>} und
    eben jenem \cmd{<br>} vergessen. Das Plugin kann bei diesen Tags
    das fehlende \cmd{/} nachreichen.

\item XHTML-Bilder-Tags (\cmd{<img>}) benötigen stets ein
    \cmd{alt}-Attribut, das sehbehinderten Benutzern beschreibt, was
    ein Bild darstellt. Dieses ALT-Tag wird aufgrund des höheren
    Aufwands von vielen Redakteuren jedoch vernachlässigt oder
    vergessen. Das Plugin kann sicherstellen, dass zumindest immer
    ein leeres \cmd{alt}-Attribut gesetzt wird. Wenn Sie die Option
    \menu{Encode XML-parsed data} aktivieren, wird zudem
    sichergestellt, dass innerhalb eines Bild-Links keine ungültigen
    Sonderzeichen erscheinen können.

\item Bei Webseiten im UTF-8-Format sind HTML-Sonderzeichen wie
    \cmd{\&auml;} (\cmd{ä}) nicht erlaubt. Das Plugin kann solche
    Sonderzeichen in die korrekten UTF-8-Sonderzeichen umwandeln,
    wenn Sie die Option \menu{Cleanup UTF-8 entities} aktivieren.
\end{osplist}

Wenn Sie Wert darauf legen, dass Ihre Seite dem XHTML-Standard
entspricht, sollten Sie dieses Plugin installieren.

\index{Plugins!Wort-Ersetzer}%
\index{Plugins!serendipity\_event\_contentrewrite}%
\subsection{Wort-Ersetzer\newline serendipity\_event\_contentrewrite}

\index{Worte ersetzen}%
\index{Glossare verwalten}%
\index{Akronyme}%
Das Plugin \emph{Wort-Ersetzer} ist ein sehr komplexes Plugin, das es
Ihnen ermöglicht, beliebige Wörter von Kommentaren oder Blog-Artikeln
umzuwandeln. Sehr beliebt ist das Plugin daher bei schreibfaulen
Redakteuren oder Personen, die gerne mit Akronymen um sich werfen.

Jedes Mal, wenn Sie in einem Artikel beispielsweise die Zeichenfolge
\cmd{s9y} verwenden, kann das Plugin dafür sorgen, dass dies
umgewandelt wird zu \cmd{<a href='http://www.s9y.org/'
  title='s9y'>s9y</a>}. Man sieht also bereits, welches
Einsparungspotenzial das Plugin bietet, solange Sie das zu Grunde
liegende Wörterbuch gut pflegen.

Die Eingabemaske für diese Wörterbücher erreichen Sie über die
Konfiguration des Plugins. In dieser Oberfläche können Sie beliebig viele
Wörter erfassen, die jeweils eine \emph{Quelle} und ein \emph{Ziel}
darstellen, die anhand der konfigurierten \emph{Umformungsmaske} speziell
umgeschrieben werden.

Jedes Mal, wenn Sie einen neuen \menu{Titel} und eine neue
\menu{Beschreibung} eintragen und das Plugin speichern, wird dem Wörterbuch 
ein neues Wort hinzugefügt. Um ein Wort aus dem Wörterbuch zu entfernen,
können Sie es in der Konfigurationsmaske einfach aus dem Eingabefeld
löschen.

Bevor Sie jedoch eine \emph{Quelle} und ein \emph{Ziel} für die
Wortersetzung eintragen, müssen Sie global festlegen, wie die beiden
Eingaben behandelt werden sollen. Die \emph{Quelle} legt das
Wort fest, das Sie selbst in einem Artikel eintragen. Das \emph{Ziel} ist
später das Wort, das anstelle Ihrer Eingabe erscheinen oder ergänzt
werden soll.

Mittels der \menu{Umformungsmaske} legen Sie fest, wie die Wortquelle und
das Wortziel später umformatiert werden sollen. Dies ist weitaus
komfortabler, als jedes Mal den vollständigen Zieltext festzulegen.
Stellen Sie sich vor, Sie würden analog zur Umformung des Wortes
\cmd{s9y} auch das Wort \cmd{PHP} so umwandeln, dass ein Link darauf
gesetzt wird. Als Umformungsmaske würde man hier Folgendes festlegen:
\cmd{<a href='\{\cmdvar{ziel}\}' title='\{\cmdvar{quelle}\}'>""\{\cmdvar{quelle}\}</a>}

Tragen Sie nun als \menu{Neuer Titel} das Wort \cmd{s9y} ein, als
\menu{Neue Beschreibung} geben Sie \cmd{http://www.s9y.org/} ein.
Speichern Sie das Plugin, und Sie können das nächste Wörterpaar
\cmd{PHP} und \cmd{http://www.php.net} eintragen.

Die Umformungsmaske wird also in Zukunft bei jedem Vorkommen der
eingetragenen \emph{Quelle} das entsprechende \emph{Ziel} heraussuchen und
im Inhalt einsetzen.

Für jedes Plugin kann nur eine Umformungsmaske eingetragen werden. Sie
können daher mehrere \emph{Wort-Ersetzer}-Plugins installieren. So wäre
es also auch denkbar, als \menu{Umformungsmaske} nur \cmd{\{ziel}\}
einzutragen, damit Sie z.\,B.\ das Wort \cmd{gh} (als \emph{Quelle}) immer
einfach nur mit \cmd{Garvin Hicking} (als \emph{Ziel}) ersetzen.

\index{Rewrite-Zeichen}%
Das \menu{Rewrite-Zeichen} hat eine besondere Bedeutung. Wenn Sie im
Wörterbuch des Plugins eine \emph{Quelle} eintragen, die in gewöhnlichem
Text vorkommen kann, dann möchten Sie nicht immer, dass das Wort ersetzt
wird. Mit dem hier konfigurierten Sonderzeichen können Sie erreichen,
dass ein Wort nur dann ersetzt wird, wenn am Ende das hinterlegte
Sonderzeichen auftaucht. Wenn Sie also \cmd{*} als \menu{Rewrite-Zeichen}
eintragen, würde im obigen Beispiel nur \cmd{PHP*} und
\cmd{s9y*} ersetzt werden. Eine Nennung ohne das Rewrite-Zeichen würde
das Wort unangetastet lassen.

Das \emph{Wort-Ersetzer}-Plugin können Sie vom \emph{Ausgabe-Wrapper}-Plugin
(siehe Seite \pageref{ausgabewrapper}) in der Seitenleiste ausgeben lassen. Es
zeigt Ihnen dann das Wörterbuch der eingetragenen \emph{Quellen} und
\emph{Ziele}. Dieses Wörterbuch wird auch in der Konfigurationsmaske des Plugins
am Ende der Seite eingebunden.

\index{Reguläre Ausdrücke}%
\index{URL!automatisch klickbar machen}%
Während dieses Plugin relativ abstrakt gehandhabt wird, gibt es zwei
besondere Plugins, die die Thematik der Wortersetzung anders handhaben:
zum einen das \emph{Glossary}-Plugin (\cmd{serendipity\_event\_glossary}),
mit dem Sie eine einfache Wortliste hinterlegen können, die beim
Auftauchen in einem Text hervorgehoben wird. Zum anderen das Plugin
\emph{Markup: RegexpMarkup}, mit dem Sie komplexe reguläre Ausdrücke zum
Ersetzen von Wörtern definieren können. Letztgenanntes Plugin bietet so
die Möglichkeit, automatisch Links mit vorangestelltem \emph{http://}
anklickbar zu machen oder auch alle Wörter mittels spezieller
Formatierung (z.\,B.\ \cmd{[(Bismarck)]}) so umzuformen, dass ein Klick
darauf den entsprechenden Eintrag in der Wikipedia öffnet.


\index{Plugins!Erweiterte Eigenschaften von Artikeln}%
\index{Plugins!serendipity\_event\_entryproperties}%
\index{Plugins!Entryproperties}%
\subsection{Erweiterte Eigenschaften von Artikeln\newline
serendipity\_event\_entryproperties}
\label{entryproperties}%
\index{entryproperties}%
\index{Erweiterte Eigenschaften von Artikeln}%
\index{Cache}%

Das Plugin \emph{Erweiterte Eigenschaften von Artikeln} ist ein sehr
mächtiges Ereignis-Plugin, das Ihnen eine große Vielfalt an Möglichkeiten
eröffnet.
Zum einen bietet dieses Plugin mehrere Optionen bei der Erstellung von
Einträgen an, und zum anderen kann es dafür sorgen, Artikel zu cachen und
somit schneller darzustellen.

Die Konfigurationsoptionen des Plugins sind:

\begin{ospdescription}
\ospitem{\menu{Artikel cachen?}}
Wenn Sie mehrere Textformatierungs-Plugins benutzen, werden diese
nacheinander bei jeder Darstellung eines Artikels erneut durchgeführt.
Meistens verschwendet Serendipity bei dieser erneuten Ausführung einiges
an Ressourcen, die Sie aber mit diesem Plugin einsparen können.

Wenn Sie die Caching-Option aktivieren, wird das Plugin beim Speichern
eines Artikels die Ausgabe aller Textformatierungs-Plugins auswerten und
speichern. Bei der Anzeige eines Artikels wird dann nur diese Version
geholt -- alle Textformatierungs-Plugins werden übersprungen. Wenn Sie einen
Artikel überarbeiten, wird der Cache automatisch neu gefüllt.

Jedoch kann das Aktivieren des Cachings auch Probleme mit sich bringen.
Wenn Sie den Inhalt eines Artikels direkt über die Datenbank bearbeiten
oder einmal ein neues Textformatierungs-Plugin installieren, kann der Cache
vom aktuellen Stand abweichen. Daher können Sie den Cache über
den Menüpunkt \menu{Einträge\sm Cachen aller Artikel} neu aufbauen
lassen. Dies sollten Sie immer dann tun, wenn Sie ein
Textformatierungs-Plugin entfernen oder hinzufügen.

Auch für das Caching ist die Reihenfolge der Ereignis-Plugins von
entscheidender Bedeutung. Das Plugin kann nur die Ausgaben der
Textformatierungs-Plugins cachen, die in der Reihenfolge vor diesem Plugin
stehen. Alle danach aufgeführten Plugins werden weiterhin ausgeführt und 
nicht gecached.

Diese Tatsache können Sie ausnutzen, um Textformatierungs-Plugins hinter
diesem Plugin zu positionieren, wenn sie ohne Caching ausgeführt werden
sollen. Derartige Textformatierungs-Plugins gibt es jedoch wenige. Als
Faustregel gilt, dass man ein Plugin nicht cachen sollte, wenn es die 
Ausgabe eines Artikels abhängig von anderen Daten macht. Wenn ein Plugin 
also beispielsweise die Farbe eines Links abhängig von der aktuellen 
Tageszeit verändert, wäre ein Caching denkbar ungeeignet.

Denken Sie also vor allem bei der Erstellung eines eigenen Plugins an
diese Caching-Option, falls dessen Ausgaben Ihnen nicht korrekt
vorkommen.

\ospitem{\menu{Leserechte auf Gruppen/Benutzer beschränken}}
Bevor Serendipity es ermöglichte, Leserechte auf Kategorie-Ebene zu
vergeben, konnte man mit diesem Plugin pro Eintrag bestimmen, von wem er
gelesen werden darf.

Diese besonders flexible Leserecht-Setzung bietet das Plugin nach wie
vor an, wenn Sie die Option \menu{Leserechte auf Gruppen beschränken}
und/oder \menu{Leserechte auf Benutzer beschränken} auswählen. Der
Ressourcenbedarf bei der Datenbankabfrage ist relativ hoch, daher sollten
Sie diese Optionen nur aktivieren, wenn Sie individuelle Leserechte
tatsächlich benötigen.

\ospitem{\menu{Standard: Artikel können gelesen werden von}}
Wenn Sie die Beschränkung der Leserechte aktivieren, können Sie mit der
Option \menu{Standard: Artikel können gelesen werden von} festlegen, 
welche Leserechte ein neu erstellter Artikel standardmäßig besitzt.
\menu{Co-Autoren} bedeutet, dass jeder eingeloggte Besucher einen Artikel
lesen darf.

\index{Freie Felder}%
\label{Freie-Felder}%
\index{Custom Fields}%
\ospitem{\menu{Freie Felder}}
Die sogenannten \emph{Freien Felder} (oder \emph{Custom Fields}) bieten
eine sehr praktische Möglichkeit, um beliebige weitere Eingabefelder zu
einem Artikel auszufüllen.

In das große Eingabefeld \menu{Freie Felder} können Sie eine Liste von
kommaseparierten Feldnamen eintragen. Die Groß- und Kleinschreibung
dieser Feldnamen ist später von Bedeutung, außerdem sollten Sie bei einem
Feldnamen auf Leer- und Sonderzeichen verzichten.

Für jedes hier eingetragene Feld wird später beim Erstellen eines
Artikels ein eigenständiges Eingabefeld eingebunden. Dort können Sie dann
genauso wie beim \emph{Artikeltext} oder \emph{Erweiterten Eintrag}
beliebigen Text eintragen.

Später können Sie die eingetragenen Felder an beliebigen Stellen in
der Artikelausgabe des Frontends einbinden, indem Sie die Template-Datei
\cmd{entries.tpl} bearbeiten. Weitere Informationen zum Einbau von Freien
Feldern können Sie auf Seite \pageref{entryproperties-customprop} nachschlagen.
Um Artikel mit bestimmten Eigenschaften innerhalb eines Templates darzustellen,
können Sie den Parameter \cmd{entryprops} der Smarty"=Funktion
\cmd{serendipity\_fetchPrintEntries} nutzen, wie auf Seite
\pageref{entryproperties-customprop-fetch} beschrieben.

\end{ospdescription}

Wenn das Plugin konfiguriert und aktiviert ist, können Sie im Bereich
\menu{Erweiterte Optionen} beim Erstellen oder Bearbeiten eines
Blog-Artikels einige Einstellungen tätigen:

\begin{ospdescription}
\index{Dauerhafte Artikel}%
\index{Sticky Entries}%
\label{stickyentries}%
\ospitem{\menu{Dauerhafte Artikel}}
Wenn ein Artikel als \emph{Dauerhafter Artikel} (\emph{Sticky}) markiert
ist, wird er im Frontend immer als erster Artikel angezeigt. Ein
Blog-Beitrag kann durch diese Markierung hervorgehoben werden und
erscheint so außerhalb der üblichen chronologischen Übersicht. Oft wird dies
für besonders wichtige Artikel verwendet, oder als eine Art Einführung zum Blog.

\ospitem{\menu{Nicht in Artikelübersicht zeigen}}
Die Aktivierung dieser Option bewirkt, dass ein Artikel nicht in der
Artikelübersicht dargestellt wird. Er kann dann von einem Besucher nur
gefunden werden, wenn er sich in der Ansicht der zugehörigen Kategorie
des Eintrages befindet oder nach einem Artikel sucht.

\ospitem{\menu{Eintragsinhalt im RSS-Feed verstecken}}
Wenn Sie nicht wollen, dass ein Blog-Beitrag mit im RSS-Feed ausgeliefert
werden soll, können Sie diese Option aktivieren.

\ospitem{\menu{Artikel können gelesen werden von:}}
Mit diesem Auswahlfeld können Sie festlegen, ob ein Artikel nur von
eingeloggten Benutzern gelesen werden kann, nur von Ihnen selbst oder von
allen Besuchern. Diese Option wird nur dann angezeigt, wenn Sie in den
Optionen des Plugins die Beschränkung der Leserechte aktiviert haben.

\ospitem{\menu{Passwort}}
Sie können einen Artikel vor unbefugten Lesern schützen, indem Sie ein
Passwort für einen Artikel vergeben. Der Besucher kann dann in der
Artikelübersicht zwar den normalen Artikeltext wie gewöhnlich lesen, aber
der \emph{Erweiterte Eintrag} und die Detailansicht des Artikels können nur
aufgerufen werden, wenn der Besucher das richtige Passwort in einer
dargestellten Box einträgt.

\ospitem{\menu{Autor}}
Wenn ein Redakteur einen Beitrag erstellt, wird er als der Eigentümer
des Artikels festgelegt. Der Artikel kann danach nur noch vom
Eigentümer oder berechtigten Benutzergruppen gelesen werden.

In manchen Fällen möchten Sie den Eigentümer eines Artikels gerne ändern.
Das können Sie mithilfe dieses Plugins tun. Nur Chefredakteure bzw.
Administratoren haben (abgesehen vom derzeit eingetragenen Besitzer) die
Befugnis, den Autoren zu verändern.

Der hier eingestellte Autor ist auch derjenige, der in der
Artikelübersicht als Autor aufgeführt wird.

\index{Deaktivieren!Textformatierungs-Plugins (fallweise)}%
\index{Textformatierungs-Plugins!fallweise deaktivieren}%

\ospitem{\menu{Disable Markup plugins for this entry}}
Standardmäßig werden alle installierten Textformatierungs-Plugins auf
einen Artikel angewendet. In manchen Fällen kann es jedoch erforderlich
sein, dass gewisse Textformatierungen nicht ausgeführt werden,
beispielsweise wenn Sie HTML-Quellcode oder JavaScript in einem Beitrag
verwenden wollen und es durch ein möglicherweise installiertes
Wiki-Formatierungs-Plugin zu Veränderungen darin käme.

Über das Auswahlfeld können Sie bestimmen, welche Textformatierungen auf
den aktuellen Artikel \emph{nicht} angewendet werden sollen. Alle nicht
ausgewählten Plugins werden weiterhin ausgeführt.

\ospitem{\menu{Freie Felder}}
Abschließend folgt eine Liste aller in der Plugin-Konfiguration
eingerichteten \emph{Freien Felder}. Für jedes festgelegte Feld können
Sie hier einen beliebigen Inhalt hinterlegen: HTML-Text, kurze Sätze --
die Einsatzzwecke sind nur durch Ihre Fantasie begrenzt. Auch ist es
möglich, einen Verweis auf eine Datei in der Mediendatenbank einzutragen
-- so könnten Sie beispielsweise einfach eine MP3-Datei mit einem Artikel
verketten. Um eine Mediendatei leicht einzufügen, befindet sich hinter
jedem freien Feld direkt ein Link zum Aufruf der Mediendatenbank. In
diesem Popup können Sie wie beim Artikeltext gewohnt eine Datei zum
Einfügen auswählen.

\end{ospdescription}

\index{Spartacus}%
\label{Spartacus}%
\index{Plugins!Spartacus}%
\index{Plugins!serendipity\_event\_spartacus}%
\subsection{Spartacus\newline  serendipity\_event\_spartacus}

Im Kapitel \ref{spartacus} auf Seite \pageref{spartacus} wird das
Plugin-System \emph{Spartacus} beschrieben. Dies ist ein online
verfügbares Archiv, in dem zahlreiche Plugins und Templates für
Serendipity angeboten werden.

Damit Sie von Ihrem Blog aus leicht solche Plugins und Templates
installieren können, müssen Sie das Ereignis-Plugin \emph{Spartacus}
installieren.

Das Plugin bindet sich in Serendipity an allen Stellen ein, wo Plugins
(und Templates) zur Installation angeboten werden. Sobald das Plugin installiert
ist, werden zusätzliche Funktionen aktiviert und die Inhalte des
Plugin-Archivs eingebunden.

Da beim Betrieb von Spartacus einige Voraussetzungen erfüllt werden
müssen (siehe erwähntes Kapitel), ist das Plugin standardmäßig nicht
installiert.

\index{Mirror}%
Technisch funktioniert das Plugin so, dass es eine Paketdatei im
XML"=Format von einem festgelegten Internet-Server (\emph{Mirror}) abruft.
Diese Paketdatei (\cmd{package\_event\_de.xml} für Ereignis-Plugins mit
deutscher Beschreibung, \cmd{package\_sidebar\_de.xml} für
Seitenleisten-Plugins) wird auf Ihren eigenen Server heruntergeladen und
im Verzeichnis \cmd{templates\_c} gespeichert. Bei der Installation von
Plugins wertet Spartacus diese XML-Daten aus und stellt sie für Sie dar.
Sobald Sie nun ein Plugin installieren wollen, wird Spartacus vom
konfigurierten Internet-Server die Dateien einzeln herunterladen und im
\cmd{plugins}-Verzeichnis abspeichern.

Damit Spartacus die XML-Datei nicht jedesmal aufs Neue herunterladen und
auslesen muss, wird die XML-Datei für einen bestimmten Zeitraum
zwischengespeichert, und alle Informationen daraus werden in einer Datenbank
hinterlegt.

Folgende Konfigurationsoptionen bietet Spartacus:

\begin{ospdescription}
\ospitem{\menu{Enable the use of Spartacus for fetching plugins}}
Damit Spartacus sich in die Plugin-Verwaltung einbindet, muss diese Option
aktiviert sein. Wenn Sie Spartacus also beispielsweise nur für die
Verwaltung von Templates aktivieren möchten, können Sie dies gezielt
einstellen.

\ospitem{\menu{Enable the use of Spartacus for fetching themes}}
Ähnlich wie für die Einbindung in die Plugin-Verwaltung müssen Sie Spartacus
auch für das Herunterladen von Templates aktivieren, wenn Sie dies
wünschen.

\ospitem{\menu{Enable remote plugin version information, Secret key to Remote plugin}}
\ospadditem{\menu{version information}}
Spartacus verfügt über eine Art \emph{Fernwartungszugriff}. Unter einer
speziellen URL können Sie eine Liste aller installierten Plugins einsehen und
prüfen, ob für diese Plugins neue Versionen vorliegen. Diese Datei ist in einem
sehr einfachen Format abgelegt und kann so leicht von Ihnen geparst oder
regelmäßig z.\,B.\ via cronjob ausgelesen und per E-Mail versendet werden.

\osppagebreak

Diese Option ist nur für erfahrene Administratoren vorgesehen. Da die Ausgabe
etwaigen böswilligen Besuchern des Blogs detaillierte Informationen über Ihr Blog
geben kann, ist die Option standardmäßig deaktiviert. 

Wenn Sie die Fernwartung aktivieren, sollten Sie den Namen der URL unbedingt
ändern, so dass fremde Besucher den Namen zum Aufruf nicht raten können.

\ospitem{\menu{Datei/Mirror Speicherort (XML-Metadaten)}}
In diesem Auswahlfeld legen Sie fest, von welchem Internet-Server das
Plugin Paketinformationen beziehen kann. Nur \emph{Netmirror.org}
ist derzeit in Betrieb. Für die Zukunft ist der Eintrag \emph{s9y.org}
vorgesehen, der jedoch noch brach liegt.

\ospitem{\menu{Datei/Mirror Speicherort (Downloads)}}
Die eigentlichen Plugin- und Template-Dateien bezieht das Plugin von dem
hier ausgewählten Server. Hier haben Sie neben \emph{Netmirror.org} auch
noch die Alternative, den \emph{SourceForge.net}-Server zu wählen. Der
SourceForge-Server hat in der Vergangenheit jedoch öfter Ausfälle gehabt, daher
sollten Sie möglichst \emph{Netmirror.org} voreingestellt lassen.

Die beiden Server \emph{s9y.org} und \emph{berliOS.de} sind ebenfalls für
zukünftige Erweiterungen vorgesehen und lassen sich derzeit nicht
benutzen.

\index{Fehler!Schreibzugriff auf von Spartacus heruntergeladene Daten}%
\ospitem{\menu{Eigentümer der heruntergeladenen Dateien, Zugriffsrechte der}}
\ospadditem{\menu{heruntergeladenen Dateien/Verzeichnisse}}
Spartacus läuft auf Ihrem Webserver als ein normaler PHP-Prozess. Alle
Daten, die das Plugin auf die Festplatte Ihres Servers schreibt,
gehören somit standardmäßig dem PHP-Benutzer, meist \emph{nobody}
oder \emph{wwwrun}. Weitere Informationen zur Einrichtung von
Benutzerrechten lesen Sie in Kapitel \ref{Zugriffsrechte} ab Seite
\pageref{Zugriffsrechte}.

Je nach Konfiguration des Providers könnte es passieren, dass aufgrund
dieser Eigentumsrechte eine von Spartacus heruntergeladene Datei für Sie
mit FTP-Zugriffsrechten nicht mehr zu bearbeiten ist. Oft ist es jedoch
gewünscht, per FTP die Dateien eines Plugins anzupassen/zu bearbeiten.

Daher bietet das Spartacus-Plugin die Möglichkeit, dass Sie hier den
Namen Ihres FTP-Benutzers eintragen. Spartacus versucht dann, eine
heruntergeladene Datei diesem Benutzer zu übertragen. Nicht alle Provider
unterstützen diese \cmd{chown}-Kommandos!

Abgesehen von den Informationen über den Eigentümer eines Plugins können Sie auch
gezielt Zugriffsrechte einer Datei und eines Verzeichnisses für andere Benutzer
festlegen. Wenn Sie also auf Ihrem System die Dateien von Spartacus später nicht
mehr verändern dürfen, können Sie über die hier festgelegten Zugriffsrechte
Anpassungen vornehmen. Zugriffsrechte wie \cmd{0777} würden dafür sorgen, dass
jeder Benutzer auf dem Server die Dateien lesen und schreiben darf.

Wenn Sie die Zugriffsrechte oder Eigentümer an dieser Stelle ändern, gilt
dies nur für Dateien, die Spartacus in Zukunft herunterladen wird.
Bereits auf dem Server befindliche Dateien werden nachträglich nicht
verändert. Diese müssten Sie manuell z.\,B.\ mittels des
\emph{fixperm}-Scripts (siehe Seite \pageref{fixperm}) beheben.

\ospitem{\menu{FTP server address, username, password, serendipity directory}}
Seit Serendipity 1.3 bietet Spartacus die Möglichkeit, Dateien nicht
nur intern direkt per PHP-Befehl auf dem Server zu speichern, sondern auch per
FTP. 

\index{Safe Mode}%
Dieser FTP-Upload umgeht das Problem, dass auf einigen Servern der PHP
\emph{SafeMode} aktiviert ist. Der \emph{SafeMode} sorgt dafür, dass Dateien in
Ihrem Stammverzeichnis des Webservers nur durch den FTP-Besitzer verändert
werden dürfen. PHP selbst besitzt in diesem Fall häufig keinen Schreibzugriff.

Daher kann das Spartacus-Plugin, das über den PHP-Benutzer ausgeführt wird, auf
derartigen Servern nicht korrekt ausgeführt werden, da es die heruntergeladenen
Plugins nicht speichern kann. Durch Verwendung des FTP-Zugangs, den Sie auch zum
Hochladen Ihrer Dateien verwenden, kann das Plugin die Dateien jedoch über
diesen Umweg speichern.

In den Konfigurationsfeldern müssen Sie die Zugangsdaten Ihres
FTP-Benutzers eintragen. Das \menu{Serendipity directory} entspricht dabei dem
relativen Verzeichnis von Serendipity. Bei einer FTP"=Verbindung werden Sie
standardmäßig in das Stammverzeichnis Ihres Webauftritts geleitet, zum Beispiel
\cmd{/var/www/example.com/}. Wenn Serendipity im Unterverzeichnis \cmd{blog}
installiert wird, müssen Sie diesen Pfad auch in der Konfiguration eintragen.
Andernfalls würde das Spartacus"=Plugin die heruntergeladenen Dateien in einem
falschen Unterverzeichnis speichern.

\end{ospdescription}

\index{Plugins!Artikel mailen}%
\index{Plugins!serendipity\_event\_mailer}%
\subsection{Artikel mailen\newline serendipity\_event\_mailer}

\index{Mailingliste}%
\index{Eintrag!via E-Mail verschicken}%
\index{Eintrag!neuen \textasciitilde{} per E-Mail erhalten}%
\index{E-Mail!Einträge via \textasciitilde{} erhalten}%
Das Plugin \emph{Artikel mailen} ermöglicht es, einen neuen Artikel nach
der Veröffentlichung via E-Mail an einen (oder mehrere) Empfänger zu
verschicken.

\osppagebreak

Grundsätzlich stellen die RSS-Feeds (siehe Seite \pageref{RSS})
eine wesentlich einfachere Möglichkeit dar, Besucher über neue
Einträge zu informieren. Im Gegensatz zu E-Mails können
RSS-Feeds auf Wunsch und Initiative des Besuchers empfangen werden, daher
spricht man hier von einem \emph{Pull}-Dienst. Newsletter und E-Mails
zählen zu den \emph{Push}-Diensten, das bedeutet, dass Inhalte zu
beliebigen Zeitpunkten an den Benutzer geliefert werden, und nicht etwa
dann, wenn der Besucher dies auslöst.

Der Vorteil von RSS-Feeds liegt daher darin, dass ein Besucher sich aktiv
über Ihren Blog informieren möchte, während eine eingehende
Benachrichtigungs"=E-Mail bei ihm möglicherweise gerade unpassend ankommt.

Andererseits kann man natürlich auch argumentieren, dass ein 
E-Mail-Hinweis komfortabel ist, um Besucher an Ihre Webseite zu erinnern, so
dass sich der Benutzer "`berieseln"' lassen kann, anstatt selber
Initiative zu zeigen.

Wie immer man also zu RSS-Feeds vs. E-Mails steht, das Plugin ermöglicht
genau diesen Mail-Versand. Standardmäßig wird eine E-Mail jedoch nur an eine
zentrale Empfängeradresse versendet. Wenn Sie stattdessen mehrere
Benutzer informieren wollen, können Sie mehrere Empfängeradressen,
natürlich mit Kommas getrennt, auflisten. Sinnvoller wäre es in diesem Fall
aber, potenziell interessierte Besucher in einer Liste zusammenzufassen.
Eine neue Benachrichtigungsmail geht dann an eine zentrale Liste, und
diese Liste wiederum leitet die E-Mail an alle eingetragenen Empfänger
weiter. Dieses Konzept nennt man \emph{Mailingliste} oder auch
\emph{Newsletter}.

Der Versand von Massen-E-Mails mittels einer PHP-Anwendung (wie
Serendipity) ist aus Ressourcengründen nicht zu empfehlen. Daher bietet
dieses Plugin keine konfigurierbare Mailingliste an, sondern Sie müssen
sich selbst um die Einrichtung einer solchen kümmern. Das ist jedoch kein
Problem, da zahlreiche kostenlose Anbieter am Markt so etwas komfortabel
umsetzen: Google Groups (\cmd{http://groups.google.de}) und Yahoo Groups
(\cmd{http://de.groups.yahoo.com}) sind die bekanntesten Vertreter. Dort
können Sie schnell eine eigene Mailingliste erstellen. Die Dienstleister
bieten auch kleine Code-Schnipsel an, die Sie in Ihrem Blog einbinden
können, damit sich Besucher leicht in die Mailingliste eintragen können.
Sie tragen dann lediglich die E-Mail-Adresse der Mailingliste in der
Konfiguration des Plugins ein, und Yahoo bzw. Google erledigt den Rest
für Sie. Natürlich können Sie auch eigene Mailinglisten-Software
wie ezmlm (\cmd{http://www.ezmlm.org/}) oder Mailman
(\cmd{http://www.gnu.org/soft\-ware/mailman/mailman.html}) einsetzen, wenn
Sie dies auf Ihrem Server nutzen können.
\index{Mailman}%

Bei der Erstellung eines Blog-Artikels sehen Sie im Bereich \menu{Erweiterte
Optionen} eine Oberfläche, in der standardmäßig die E-Mail-Adressen aufgeführt
sind, an die der Artikel verschickt wird. Zudem können Sie die Auswahlbox
\menu{An alle Redakteure schicken} markieren, damit der Blog-Artikel an alle
Redakteure des Blogs geht. Sobald Sie einen Artikel veröffentlichen,
gibt das Plugin aus, an welche E-Mail-Adressen eine E-Mail geschickt wurde.

Die weiteren Konfigurationsoptionen des Plugins sind:

\begin{ospdescription}
\ospitem{\menu{Inhalt}}
Mit diesem Auswahlfeld können Sie festlegen, ob die E-Mails den
vollständigen Artikeltext (bestehend aus \menu{Eintrag} und
\menu{Erweitertem Eintrag}) enthalten sollen oder eine beliebige
Kombination aus beidem. Wenn Sie bei einem ausführlichen Artikel also den
erweiterten Eintrag weglassen wollen, geben Sie so Ihren Besuchern einen
Anreiz, trotzdem Ihr Blog zu besuchen.

\ospitem{\menu{Mail-Empfänger}}
In dieses Feld tragen Sie den eingangs erwähnten E-Mail-Empfänger ein,
oder die Adresse einer Mailingliste.

\ospitem{\menu{An alle Redakteure schicken}}
Legt die Standardeinstellung für die Auswahlbox \menu{An alle Redakteure
schicken} bei der Erstellung eines Blog-Artikels fest.

\ospitem{\menu{URL des Artikels mailen}}
Wenn Sie diese Option aktivieren, wird die URL Ihres Artikels mit in die
E-Mail aufgenommen. Dies ist wichtig, damit die Leser einer E-Mail auch
leicht zu Ihrem Blog gelangen können.

\ospitem{\menu{HTML entfernen}}
Artikeltexte können HTML-Formatierungen enthalten, die in einer E-Mail
nicht sinnvoll dargestellt werden. Wenn Sie die Option \menu{HTML
entfernen} aktivieren, stellt das Plugin sicher, dass sämtliche HTML-Tags
(mittels PHP \cmd{strip\_tags()}-Befehl) aus der E-Mail entfernt werden.

Mögliche \cmd{<a>}- und \cmd{<img>}-Tags für Bilder und Hyperlinks werden
dabei so entfernt, dass die referenzierte URL trotzdem im Text bestehen
bleibt.

\ospitem{\menu{HTML-Paragraphen in Leerzeilen wandeln}}
Wenn Sie die Option \menu{HTML entfernen} aktiviert haben, kann dies dazu
führen, dass die Zeilenumbrüche verloren gehen, die bei der HTML-Ansicht
eines Artikels für die Gliederung sorgen. Daher können Sie die Option
\menu{HTML-Paragraphen in Leerzeilen wandeln} aktivieren, damit nach
einem HTML-Absatz (\cmd{</p>}) ein gewöhnlicher E-Mail"=Zeilenumbruch
eingefügt wird.

\ospitem{\menu{Kategorien}}
Für jede im Blog erstellte Kategorie sehen Sie ein zusätzliches
Eingabefeld. Dort können Sie eine kategorieabhängige E-Mail-Adresse
eintragen, damit ein Artikel dieser Kategorie nur an die E-Mail-Adressen
geschickt wird, die für die Kategorie hinterlegt wurden.

E-Mails zu Artikeln, die keiner Kategorie zugeordnet sind, werden dann an
die Standardadresse verschickt.
\end{ospdescription}

\index{Plugins!LiveSearch}%
\index{Plugins!serendipity\_event\_livesearch}%
\subsection{LiveSearch\newline serendipity\_event\_livesearch}

\index{Livesuche@Live-Suche}%
\index{AJAX!Suche}%
Das \emph{LiveSearch}-Plugin ist eine Erweiterung des
Seitenleisten"=Plugins für die Suche (siehe Seite \pageref{quicksearch}).

Sobald es installiert ist, wird ein kleines JavaScript in das
Suchformular eingebunden. Wenn Sie als Besucher einen Begriff in das
Suchformular eintragen, wird die LiveSuche alle zutreffenden Artikel in
einer Aufklappbox unter dem Suchformular anzeigen, und Sie können einfach
darauf klicken.

Diese Art der Suche erspart Ihnen bei aktiviertem JavaScript im
Browser also, erst eine lange Artikelübersicht durchforsten zu müssen, bevor
Sie den gewünschten Artikel finden.

\index{Plugins!Hebe Suchwörter hervor}%
\index{Plugins!serendipity\_event\_searchhighlight}%
\subsection{Hebe Suchwörter hervor\newline
serendipity\_event\_searchhighlight}

\index{Suchwörter}%
\index{Suchmaschinen}%
Wenn ein Besucher Ihr Blog mittels einer Suchmaschine gefunden hat und
aufruft, wird von den Suchmaschinen der Suchbegriff übermittelt. Diesen
Suchbegriff kann das Plugin ermitteln und in Ihren Beiträgen hervorheben.
So kann ein Besucher dann komfortabel sehen, wo der ursprünglich
benutzte Suchbegriff in Ihrem Artikel auftaucht.

Das Plugin kann Suchwörter folgender Suchmaschinen ermitteln und
hervorheben: Google, Yahoo, Lycos, MSN, Altavista, AOL.de und AOL.com.
Die Art der Hervorhebung können Sie mittels der CSS-Klasse
\cmd{.serendipity\_""searchQuery} beeinflussen (siehe Kapitel \ref{template-css}
ab Seite \pageref{template-css}).

Das Plugin setzt die Smarty-Sondervariable
\index{Template-Variablen!\$smarty.SESSION.search\_referer}%
\ospsmarty{smarty.SESSION.search\_""referer}
auf die URL der Suchmaschine, von welcher der aktuelle Besucher kam. Wenn der
Besucher über eine Suchmaschine auf das Blog gelangte, ist weiterhin die Variable
\index{Template-Variablen!\$smarty.SESSION.is\_searchengine\_visitor}%
\ospsmarty{smarty.SESSION.is\_searchengine\_vis\-itor} auf \cmd{true} gesetzt. So
können Sie innerhalb Ihrer Template-Dateien individuelle Ausgaben darstellen,
falls der Besucher über eine Suchmaschine auf Ihre Seite gelangte. Für solche
Besucher sind z.\,B.\ einleitende Worte zu Ihrem Blog und weiteren interessanten
Artikeln sehr hilfreich.


\index{Plugins!Karma}%
\index{Plugins!serendipity\_event\_karma}%
\subsection{Karma\newline serendipity\_event\_karma}

\label{Karma}%
\index{Karma}%
\index{Statistik}%
\index{Bewertungen}%
Der Begriff \emph{Karma} beschreibt ein spirituelles Konzept, wonach
jede gute oder schlechte Tat sich in guten oder schlechten Erfahrungen
niederschlagen wird. Gerade im Hinduismus oder bei
Religionsgemeinschaften, die an die Wiedergeburt glauben, ist diese
Vorstellung wichtig für die Handlungsweisen der Menschen.

Das Karma-Plugin wendet dieses Konzept auf Blog-Beiträge an: Ihre
Besucher können zu jedem Beitrag abstimmen, wie "`gut"' oder
"`schlecht"' sie diesen finden. Das kann Ihnen dann Aufschluss
darüber geben, wie gezielt Sie auf Ihre Besucher eingehen.

Das Plugin ermöglicht eine Bewertung in fünf Stufen: -{}- (sehr
schlecht), - (schlecht), 0 (neutral), + (gut) und ++ (sehr gut). Die
Abstimmungen können nur bei aktiviertem JavaScript durchgeführt werden,
damit Suchmaschinen nicht auch abstimmen können. 

Seit der neuen Version des Plugins mit Serendipity 1.3 können auch beliebige
Grafiken für die Abstimmung eingebunden werden.


Zusätzlich bietet das Karma-Plugin auch "`statistische Fähigkeiten"'. Es
kann zählen, wie viele Besucher die Detailseiten eines Artikels angesehen
haben. Dafür legt das Plugin eine eigenständige Datenbanktabelle an, in
der die Abstimmungen und Statistiken gespeichert werden. Diese
Statistiken können direkt in der Artikelansicht dargestellt
werden und werden auch bei den Ausgaben des \emph{Statistik}-Plugins
(siehe Seite \pageref{statistics}) berücksichtigt.

Die grafische Gestaltung der Abstimmungslinks kann via CSS und den
entsprechenden Plugin-CSS-Klassen vorgenommen werden (siehe auch Seite
\pageref{template-css}).

Das Plugin bietet die folgenden Konfigurationsoptionen, aufgeteilt in drei
Bereiche namens \menu{Globales}, \menu{Darstellung} und \menu{Texte}:

\begin{ospdescription}
\ospitem{\menu{Karmavoting aktivieren}}
Wenn Sie den Besuchern die Abstimmungsmöglichkeit zu einem Artikel
anbieten wollen, müssen Sie diese Option aktivieren. Sie können sie
deaktivieren, wenn Sie beispielsweise nur die Aufrufstatistik erhalten
möchten.

\ospitem{\menu{Nur erweiterte Artikel}}
Die Abstimmungsmöglichkeit kann vom Plugin sowohl in der
Artikelübersicht als auch in der Detailansicht eines Artikels angezeigt
werden. Wenn Sie die Option \menu{Nur erweiterte Artikel} aktivieren,
kann ein Besucher nur in der Detailansicht eines Artikels abstimmen. Dies
kann möglicherweise hilfreich sein, um Ihre Artikelübersichten einfacher
zu strukturieren.

\ospitem{\menu{Maximaler Abstimmungszeitraum}}
In diesem Eingabefeld legen sie fest, nach welchem Zeitraum seit der 
Veröffentlichung eines Artikels keine Abstimmung mehr zugelassen 
wird. Häufig interessiert Sie nur die Meinung Ihrer Besucher zu 
aktuellen Beiträgen, daher ist standardmäßig die Abstimmung über 
Artikel nur bis zu 7 Tage nach deren Veröffentlichung möglich.

\ospitem{\menu{Abstimmungszeitraum}}
Mit der Option \menu{Abstimmungszeitraum} legen Sie fest, wie lange die
"`Zwangspause"' eines Besuchers dauert, die er nach einer Bewertung eines
Beitrags abwarten muss, bis er über einen weiteren Artikel abstimmen
darf. Standardmäßig sind dies 5 Minuten.

Der Abstimmungszeitraum gilt nur für Artikel, die älter als das in der
Option \menu{Abstimmungszeitraum nach Veröffentlichung eines Artikels}
festgelegte Alter sind.

\ospitem{\menu{Abstimmungszeitraum nach Veröffentlichung eines Artikels}}
Wenn Sie das Karmavoting aktiviert haben, kann ein Besucher einen Artikel
bewerten. Nach jeder Bewertung erfolgt eine "`Zwangspause"' für den
Besucher, bis er einen neuen Artikel bewerten kann.

Diese Zwangspause gilt jedoch nicht für gerade erst veröffentlichte
Artikel. Stellen Sie sich vor, Sie veröffentlichen drei neue Artikel, und
ein Besucher müsste erst mehrere Minuten warten, bevor er alle drei neuen
Artikel nacheinander bewerten kann. Dies wäre keine besonders sinnvolle
Einschränkung. Dennoch macht eine Zwangspause später Sinn, damit ein
böswilliger Besucher nicht einfach alle Artikel Ihres Blogs nacheinander
schlecht bewertet.

In dem Eingabefeld \menu{Abstimmungszeitraum nach Veröffentlichung eines
Artikels} tragen Sie eine Zeitdauer in Minuten ein, die das Alter eines
Eintrages festlegt, bei dem ein Benutzer ohne Zwangspause abstimmen darf.
Standardmäßig sind dies 1440 Minuten, also ein Tag. Alle Artikel, die
jünger als ein Tag sind, können dann ohne Pause von jedem Besucher
nacheinander bewertet werden.

\ospitem{\menu{Minimale Anzahl an Stimmen für Darstellung}}
Wenn Sie die Ergebnisse der Abstimmung erst ab einer gewissen Anzahl an Stimmen
anzeigen wollen, können Sie dies hier festlegen.

\ospitem{\menu{Aufrufstatistik aktivieren}}
Wenn Sie möchten, dass das Plugin jeden Aufruf eines einzelnen Artikels
zählt, können Sie diese Option aktivieren. Wenn ein Artikel in einer
Übersicht dargestellt wird, zählt dies nicht als Aufruf.

\ospitem{\menu{Aufrufstatistik auch für eingeloggte Benutzer}}
Falls diese Option deaktiviert wird, werden die Besuche eingeloggter Redakteure
in der Aufrufstatistik nicht mitgezählt.

\ospitem{\menu{Minimale Besucheranzahl}}
Wenn Sie die Ergebnisse der Besucherzählung erst ab einer gewissen Anzahl an Besuchern
anzeigen wollen, können Sie dies hier festlegen.

\ospitem{\menu{Zeigt die Top-Exit-Links des Blogs}}
Wenn Sie das Plugin \emph{Externe Links zählen} installiert haben, kann
jeder Klick auf eine in Ihren Artikeln genannte Webseite gezählt werden.
Da diese Seitenaufrufe in der Datenbank gespeichert werden, können sie
nicht nur mittels des Plugins \emph{Top Exits} in der Seitenleiste
eingebunden werden, sondern das Karma-Plugin kann auch auf diese Daten
zugreifen. Wenn Sie die Option \emph{Zeigt die Top-Exit-Links des Blogs}
aktivieren, wird die Summe der Aufrufe aller in einem Beitrag genannten
Links am Ende des Artikels dargestellt. Sinnvoll ist diese Möglichkeit
vor allem bei Blogs, die pro Artikel immer nur einen oder zumindest
ähnliche Links aufführen, da durch die Summenbildung die Individualität
mehrerer Links verloren geht.

\ospitem{\menu{Protokollieren}}
Jede Abstimmung über einen Beitrag kann in der Datenbanktabelle
\index{Datenbank-Tabellen!serendipity\_karmalog}%
\cmd{serendipity\_karmalog} protokolliert werden, sofern diese Option 
aktiviert ist. Die Datenbanktabelle können Sie dann manuell mittels 
phpMyAdmin ansehen (und von Zeit zu Zeit löschen).

\ospitem{\menu{Konfigurationsbereich Darstellung}}
In diesem Bereich können Sie über mehrere Konfigurationsoptionen bestimmen, ob
der Abstimmungsbereich durch Text- oder Grafikdarstellung eingebunden werden
soll und welchem grafischen Stil dieser entsprechen soll.

\ospitem{\menu{Konfigurationsbereich Texte}}
Die einzelnen Texte für die Umfrage können von Ihnen frei eingetragen werden.

\end{ospdescription}

\subsubsection{Datenbanktabellen}

\index{Datenbank-Tabellen!serendipity\_karma}%
Die Datenbanktabelle \cmd{serendipity\_karma} enthält die Abstimmungen zu jedem
Blog-Artikel. Zu jedem Blog-Artikel gibt es nur einen Eintrag, d.\,h.\ die Werte
der Abstimmung werden jeweils zu diesem Eintrag hinzuaddiert. 

\begin{ospdescription}
\ospitem{\cmd{entryid}} enthält die ID des Blog-Artikels.
\ospitem{\cmd{points}} enthält die aktuelle Punktzahl des Artikels.
\ospitem{\cmd{votes}} enthält die Anzahl der abstimmenden Besucher.
\ospitem{\cmd{lastvote}} enthält das Datum der letzten Abstimmung.
\ospitem{\cmd{visits}} enthält die Anzahl an Besuchen des Artikels.
\end{ospdescription}

\index{Datenbank-Tabellen!serendipity\_karmalog}%
Damit alle Abstimmungen einzeln nachverfolgt werden können, wird bei aktivierter
Logging-Option des Plugins die Datenbanktabelle \cmd{serendipity""\_karmalog}
befüllt: 

\begin{ospdescription}
\ospitem{\cmd{entryid}} enthält die ID des Blog-Artikels.
\ospitem{\cmd{points}} enthält die abgegebene Punktzahl.
\ospitem{\cmd{ip}} enthält die IP-Adresse des abstimmenden Besuchers.
\ospitem{\cmd{user\_agent}} enthält den verwendeten Browser des Besuchers.
\ospitem{\cmd{votetime}} enthält das Datum, an dem diese Punktzahl abgegeben wurde.
\end{ospdescription}

\index{Plugins!Einträge ankündigen}%
\index{Plugins!serendipity\_event\_weblogping}%
\subsection{Einträge ankündigen\newline serendipity\_event\_weblogping}
\label{weblogping}%

Nach der Veröffentlichung eines Artikels möchten
Sie natürlich auch, dass Ihre Besucher diesen lesen. Damit
Internet-Surfer auf neue Blog"=Einträge aufmerksam werden (und auch
Suchmaschinen neue Beiträge direkt aufnehmen), kann das Plugin
\emph{Einträge ankündigen} Verbindung zu Webservices aufnehmen.

Zur Benachrichtigung für neue Einträge existiert eine Standard-API, die
sich "`Ping"' nennt. Die API (\cmd{weblogUpdates.ping} und
\cmd{weblogUpdates.""extendedPing}) wird mittels XML-RPC-Schnittstelle
aufgerufen. Damit Serendipity einen Artikel bei einem Webservice
ankündigen kann, muss der Webservice diese Schnittstelle auch
bereitstellen. Weiterhin muss Ihr Webserver in der Lage sein, ausgehende
HTTP-Verbindungen zu anderen Internet"=Servern herzustellen. Eine Firewall
muss also entsprechend konfiguriert werden.

Sobald das Plugin installiert ist, sehen Sie in dem Abschnitt
\emph{Erweiterte Optionen} beim Erstellen eines Artikels ein Feld, in dem
Sie auswählen können, zu welchen Webservices ein Ping gesendet werden
soll. Jeden gewünschten Webservice können Sie dort ankreuzen, die
Voreinstellungen können Sie über die Konfiguration des Plugins
beeinflussen.

Abhängig von der Sprache des Blogs werden unterschiedliche Webservices
angeboten. Für deutsche Blogs sind dies: Ping-o-matic, blo.gs,
blogrolling.""com, technorati.com, weblogs.com, ge.bloggt.org, Yahoo! und
Google.

\index{Fehler!langsames Speichern von Artikeln}%
\index{Fehler!Abbruch beim Speichern von Artikeln}%
Jeder Dienst, den Sie über einen neuen Artikel informieren, wird beim
Veröffentlichen des Artikels etwas Zeit in Anspruch nehmen. Wenn das
Speichern eines Artikels sehr lange dauert oder zu Fehlern führt, kann
dies also am Plugin \emph{Einträge ankündigen} liegen. In diesem Fall
sollten Sie die Anzahl der gepingten Services reduzieren oder das Plugin
vollständig deaktivieren. Einige Webservices dienen als "`Weiterleitung"'
von Pings, z.\,B.\ der Dienst Ping-o-matic. Wenn Sie diesen benutzen, können
Sie sich das Pingen anderer Dienstleister sparen, allerdings ist
Ping-o-matic nicht immer vollständig funktionstüchtig\footnote{Siehe
\cmd{http://pingomatic.com/}}. Das Plugin wird automatisch die
Webservices in der Liste abwählen, die bereits von einem solchen Meta-Service
verwaltet werden.

In der Konfiguration des Plugins können Sie zusätzlich eigene Webservices
eintragen, zu denen Sie Pings setzen wollen. Tragen Sie diese mit einem
Komma voneinander getrennt in \menu{Selbstdefinierte
Ping-Services} ein. Da jeder Webservice unter einer speziellen URL
aufrufbar ist, müssen Sie diese im Format \cmd{host.domain/pfad} (also
z.\,B.\ \cmd{rpc.blogrolling.com/pinger/} für den Webservice von
BlogRolling.com) im Eingabefeld eintragen. Die XML-RPC-Spezifikation
ermöglicht entweder einen \emph{einfachen} oder einen \emph{erweiterten}
Ping. Beim erweiterten Ping wird die URL Ihres RSS-Feeds an den
Webservice übermittelt, der anhand des Feeds weitere Daten Ihres Blogs
einlesen kann. Wenn ein selbst definierter Webservice diese Option
unterstützt, können Sie ein \cmd{*} vor den Hostnamen setzen.


\section{Auswahl externer Plugins}

Über die mitgelieferten Plugins hinaus finden Sie auch eine große Auswahl
an Plugins über \cmd{http://spartacus.s9y.org/}. Eine Auswahl an häufig
genutzten Ereignis-Plugins finden Sie auf den folgenden Seiten.

\index{Plugins!Einträge automatisch sichern}%
\index{Plugins!serendipity\_event\_autosave}%
\subsection{Einträge automatisch sichern\newline serendipity\_event\_autosave}
\label{automatic-backup}%
\index{Backup}%
\index{Artikel!automatisch speichern}%
\index{Fehler!Artikel verloren}%

Bei der Benutzung einer Web-Anwendung in Ihrem Browser kann es öfter als
bei normalen Desktop-Anwendungen 
passieren, dass Ihre mühsame Arbeit verloren geht. Der Browser stürzt ab,
möglicherweise weil Sie in einem anderen Fenster gerade eine
fehlerhafte Webseite besucht haben; oder Sie haben aus Versehen die
Taste oder den Button gedrückt, mit dem der Browser zurück zur vorherigen Seite
wandert. In beiden Fällen wäre der mühsam geschriebene Blog-Artikel
vermutlich verloren.

Das häufigste Problem bei Web-Anwendungen, in denen man lange Texte
schreibt, ist, dass man fleißig eine Stunde oder länger damit verbringt,
den Text perfekt zu formulieren. Während dieser Zeitspanne sendet Ihr
Browser keine Daten zum Server, daher ist die Zeit, die Sie mit einem
Artikel verbringen, für eine Web-Anwendung so, als würden Sie überhaupt
nichts tun.

Wenn Sie nach einer Stunde des "`Nichtstuns"' also plötzlich einen
Artikel veröffentlichen wollen, muss Serendipity Sie erst einmal wiedererkennen. Dies erfolgt üblicherweise anhand der Session-Cookies (siehe
Seite \pageref{sessioncookies}).

Session-Cookies sind jedoch nur für einen fest eingestellten Zeitraum
gültig. Ist die Haltbarkeit eines Cookies überschritten, löscht PHP
sämtliche Session-Daten. Für Serendipity bedeutet dies, dass Ihr Login
nicht mehr erkannt werden kann und Sie sich daher neu einloggen müssen.
Dies gilt natürlich nur, wenn Sie beim Login die Auswahlbox \menu{Daten
merken?} \emph{nicht} aktiviert haben. Ist die Box aktiviert, kann
Serendipity Sie auch nach dem Überschreiten der Session-Haltbarkeit
automatisch neu einloggen.

\index{phpini@php.ini!session.gc\_maxlifetime}%
Die Haltbarkeit einer PHP-Session wird in der PHP-Konfigurationsvariable
\cmd{session.gc\_maxlifetime} in Sekunden
festgelegt. Per Default sind dies 1440 Sekunden, also 24 Minuten. Zwar kann man
diesen Wert verändern, aber da es einige Besonderheiten zu beachten gilt (siehe
\cmd{http://de2.php.""net/manual/de/ref.session.php}), sollte man dies nicht
unbedingt tun. Zumal die Standardeinstellung einen guten Mittelwert
zwischen normaler Inaktivität und Sicherheitserwägungen darstellt. Je länger eine
Session gilt, desto eher kann ein böswilliger Benutzer diese Daten möglicherweise
ausspähen und sich unberechtigten Zugang verschaffen.

Daher sollten Sie bei der Benutzung von Serendipity eher 
entweder die Login-Option \menu{Daten merken?} aktivieren oder bei
einem ungewollten Logout folgenden Trick anwenden: Wenn Sie eine Aktion
in Serendipity ausführen, sendet Ihr Browser die Daten (z.\,B.\ den
Artikeltext) an den Server. Meldet Serendipity daraufhin, dass Sie sich
neu einloggen müssen, dann sind diese an den Server gesendeten Daten noch
im Zwischenspeicher des Browsers. Der Trick ist nun, dass Sie einfach ein
weiteres Browser-Fenster öffnen und sich dort in die
Serendipity-Administrationsoberfläche einloggen. Nun haben Sie ein
neues, gültiges Session-Cookie, mit dem Sie Serendipity wie gewohnt
bedienen können. Gehen Sie nun zurück in das Browser-Fenster, bei dem das
Speichern des Artikels fehlschlug, und laden die Seite erneut. Die meisten
Browser tun dies, wenn Sie die Taste \taste{F5} drücken oder auf den
\menu{Neu laden}-Menübutton klicken. Ihr Browser sollte Sie nun fragen,
ob die Formulardaten (die Daten Ihres Artikels) erneut geschickt werden
sollen. Bestätigen Sie dies, und Ihr ursprünglich übermittelter Artikel
wird nun mit einem gültigen Session-Cookie korrekt gespeichert.

Diesen Trick können Sie nur nutzen, wenn Sie sich im Browser-Fenster noch
nicht neu eingeloggt und das Ursprungsfenster noch nicht geschlossen
haben.

Ein grundsätzlicher Tipp ist jedoch, dass Sie besonders lange Artikel im
\emph{Entwurfsmodus} speichern. Ab und zu klicken Sie dann einfach auf
den Button \menu{Speichern}, um einen Zwischenstand des Artikels in der
Datenbank zu sichern. Wenn Ihr Browser abstürzt, können Sie so den
letzten Stand direkt über Serendipity wieder einsehen. Ein anderer Tipp
wäre, dass Sie besonders lange Artikel in einem Schreibprogramm wie
OpenOffice vorschreiben und erst später per Kopieren \& Einfügen
in das Blog übernehmen. Wenn Sie das XML-RPC Plugin (siehe Seite
\pageref{xmlrpc}) benutzen, können Sie zudem Schreibprogramme verwenden, die
solche vorgeschriebenen Artikel automatisch zwischenspeichern und später an den
Server senden.

Neben den aufgeführten Möglichkeiten gibt es auch ein Plugin namens
\emph{Einträge automatisch sichern} (\emph{Autosave}), das Ihnen die
Arbeit des regelmäßigen Speicherns teilweise abnehmen kann.

Dabei verwendet das Plugin ein spezielles JavaScript (AJAX), das in
einem regelmäßigen Intervall den Artikel als Entwurf speichert. Wurde ein
Artikel derart gespeichert, zeigt das Plugin einen Hinweis darauf in der
Artikel-Erstellungsmaske an. Wenn Ihr Browser abstürzt, können
Sie einen so gespeicherten Artikel als \emph{Entwurf} in Ihrer
Artikelübersicht fortsetzen.

\index{Schattenkopie}%
Wenn Sie einen bereits veröffentlichten Artikel überarbeiten, wird eine
Sicherungskopie davon angelegt. Somit werden Änderungen, die Sie
ausführen, nicht automatisch am veröffentlichten Artikel dargestellt.
Derartige Sicherungskopien, die nicht den ursprünglichen Artikel
betreffen, nennt man \emph{Schattenkopien}, da sie vor dem Benutzer
versteckt werden. Solche Schattenkopien markiert das Plugin mit dem
vorangestellten \cmd{[AUTO\-SAVED]} im Titel des Artikels. Die
Schattenkopie eines Artikels finden Sie wie einen gewöhnlichen Artikel in
der Übersicht, und sie wird beim Speichern des Originalbeitrags
automatisch wieder gelöscht.

Wenn Sie nach einem Browser-Absturz eine Schattenkopie wiederherstellen 
wollen, bearbeiten Sie den Originalartikel (\emph{nicht} die
Schattenkopie) und klicken oberhalb der Artikelerfassung auf den Button
\menu{Der Eintrag hat Sicherungsdaten, zur Wiederherstellung hier
klicken}. Dadurch wird die Schattenkopie in den Ursprungsartikel
eingefügt.

Das Plugin besitzt zwei Konfigurationsoptionen. Zum einen können Sie
einstellen, nach wie vielen Sekunden ein Artikel automatisch gespeichert
wird. Stellen Sie dieses Intervall nicht zu gering ein, da ansonsten
viel Redundanz und unnötige Serverlast entsteht.

\osppagebreak

Die zweite Option stellt den HTTP-Pfad zu dem Plugin ein. Da
Serendipity Plugins aus beliebig verschachtelten Unterverzeichnissen
laden kann, weicht Ihre Einstellung möglicherweise von dem
Standard-Plugin-Pfad ab. Wenn das Plugin im Unterverzeichnis
\cmd{plugins/spartacus\_plugins/se\-ren\-dipity\_event\_autosave} gespeichert
wäre, würde der einzutragende Pfad 
\cmd{http://www.example.com/serendipity/plugins/spartacus\_\osplinebreak{}plugins/serendipity\_event\_autosave}
lauten.

\index{Plugins!frei definierbare Permalinks zu Einträgen}%
\index{Plugins!Permalinks}%
\index{Plugins!serendipity\_event\_permalinks}%
\subsection{Frei definierbare Permalinks zu Einträgen\newline
serendipity\_event\_custom\_permalinks}

\index{Permalinks}%
\index{SEO}%
\index{Suchmaschinenoptimierung|see{SEO}}%
\index{slug}%
Ein Blog-Artikel ist standardmäßig unter der URL
\cmd{http://www.example.""com/serendipity/archives/1-Mein-Blogartikel.html}
verfügbar. Wie genau die Pfadkomponenten benannt sind und welche
zusätzlichen Komponenten (Datum des Artikels, mit oder ohne Artikeltitel
oder ID etc.) in einem solchen Detail-Link (\emph{Permalink})
erscheinen, können Sie in der Serendipity"=Konfiguration im Bereich
\emph{Permalinks}\footnote{Siehe Kapitel \ref{permalinkconfig} ab Seite
\pageref{permalinkconfig}.} einstellen.

Für besonders interessante Artikel können Sie aber auch individuelle URLs
für einen Beitrag vergeben, die von dieser Konvention abweichen. Diese URL
kann dann zusätzlich zur "`echten"' URL benutzt werden, um zu dem
gewünschten Artikel zu führen. Diese Extra-URL bietet das Plugin
\emph{Frei definierbare Permalinks zu Einträgen} bei der Erstellung eines
Artikels in einem Feld der \emph{Erweiterten Optionen} an. Andere
Blogsysteme nennen einen derartigen Permalink auch \emph{slug}.

Dort tragen Sie den vollständig gültigen Pfad zu einem Artikel ein.
Dieser Link wird später auch im Frontend anstelle der vordefinierten
Struktur angezeigt. Ein Standardpfad wird in dieser Box vorausgefüllt
dargestellt (z.\,B.\ \cmd{/serendipity/permalink/Mein-Blogartikel.html}).
Wenn Sie den Pfad anpassen, dürfen Sie nur die Teile anpassen, die hinter
der Stamm-URL von Serendipity (in unserem Beispiel \cmd{/serendipity/})
aufgeführt sind. Sie können beliebige gültige
URL-Zeichen\footnote{Sonderzeichen und Leerzeichen müssen entsprechend
der RFC 1738 (\cmd{http://www.""faqs.org/rfcs/rfc1738.html}) konvertiert werden.
Das URL-Sonderzeichen \cmd{;} würde
daher als \cmd{\%3B} umgeschrieben werden. Da dies eher unschön aussieht,
sollten Sie auf derartige Sonderzeichen in Permalinks besser verzichten.}
als Permalink einsetzen. Die einzige Regel dabei ist, dass der Permalink
auf \cmd{.htm} oder \cmd{.html} endet, damit Serendipity ihn korrekt
erkennen kann. Auch dürfen Sie bereits bestehende interne Permalinks
(wie \cmd{/serendipity/archives/1-""Mein-Blogartikel.""html}) nicht
verwenden, da Serendipity dann eine URL nicht eindeutig einem Inhalt
zuweisen könnte. Die verwendeten Verzeichnisnamen werden nur virtuell
belegt, Sie müssen also keine entsprechende Verzeichnisstruktur auf Ihrem
Server anlegen.

Das Plugin wird gerne dann verwendet, wenn man besonders
lange Artikeltitel benutzt, die man in der URL aber lieber auf Stichworte
eingrenzen möchte. Oder im umgekehrten Fall, wenn man aus
Gründen der Suchmaschinenoptimierung einer URL mehr Stichworte mitgeben
möchte, als der Artikeltitel enthält.

\index{Plugins!Sonderzeichen/Erweiterte Buttons für Non-WYSIWYG}%
\index{Plugins!serendipity\_event\_typesetbuttons}%
\subsection{Sonderzeichen/Erweiterte Buttons für Non-WYSIWYG\newline
serendipity\_event\_typesetbuttons}

Wenn Sie als Redakteur nicht den WYSIWYG-Editor beim Verfassen von
Artikeln einsetzen, sind Sie gezwungen (oder eher in der glücklichen
Lage), HTML-Code selbständig einzugeben. Serendipity bietet zwar zum
Einfügen von Bildern/Links und für gängige Textformatierung (fett,
unterstrichen, kursiv) eigenständige Buttons an, aber dies ist Ihnen
möglicherweise noch nicht komfortabel genug.

Glücklicherweise erlaubt die Serendipity-Plugin-API, dass
Ereignis-Plugins eigenständig Buttons oberhalb der Artikelmaske einbinden
können. Das Plugin \emph{Sonderzeichen/Erweiterte Buttons für
Non-WYSIWYG} tut genau dies.

In der Plugin-Konfiguration können Sie einstellen, welche Buttons das
Plugin darstellen soll. Damit die Artikelmaske nicht überfrachtet wird,
sollten Sie hier nur die Buttons aktivieren, die Sie wirklich gerne (und
häufig) nutzen möchten.

Eine sehr wichtige Konfigurationsoption des Plugins ist, ob Sie für die
Sonderzeichen HTML oder XHTML benutzen wollen. Je nachdem, welchen dieser beiden
Standards Sie für Ihre Webseite benutzen wollen, müssen die Sonderzeichen
unterschiedlich eingebunden werden. Wenn Ihr Blog-Template das XHTML-Format
benutzt (was bei fast allen Serendipity"=Templates der Fall ist), würde ein
HTML-Sonderzeichen unter Umständen dazu führen, dass Ihre Seite ungültigen Code
enthält, der bei manchen Browsern zu Fehldarstellungen der Seite führen könnte.

Da sich XHTML bereits etabliert hat und von allen Browsern unterstützt wird,
sollten Sie möglichst XHTML-Sonderzeichen einsetzen. Lediglich \emph{alte
Hasen}, die sich von ihren liebgewonnenen HTML-Tags einfach nicht trennen
können, interessieren sich womöglich für die HTML-Variante der Sonderzeichen.

Die einzelnen Konfigurationsoptionen des Plugins sind:

\begin{ospdescription}
\ospitem{\menu{Center Button aktivieren}}
Bindet einen Button ein, mit dem Sie ausgewählten Text im Artikel
zentrieren können. Dies geschicht mittels \cmd{<center>}-HTML-Tag oder
\cmd{<div class="{}s9y\_typeset\_center"{}}-XHTML-Tag.

\osppagebreak

\ospitem{\menu{Strike-through Button aktivieren}}
Hiermit können Sie Texte als durchgestrichen auszeichnen, um z.\,B.\ eine
Änderung in Ihren Artikeln hervorzuheben (\cmd{<del>} für HTML, \cmd{<s>}
für XHTML).

\index{Geschützte Leerzeichen}%
\ospitem{\menu{Leerzeichen-Button aktivieren}}
Bei (X)HTML werden mehrere Leerzeichen immer zu einem einzelnen
Leerzeichen zusammengefasst. Um mehrere Leerzeichen hintereinander in
einem Artikel einzubinden, müssen Sie sogenannte \emph{geschützte}
Leerzeichen verwenden. Dieses wird durch das HTML-Sonderzeichen
\cmd{\&\#160;} repräsentiert.

\ospitem{\menu{Kaufmännisches-Und-Button aktivieren}}
Das Kaufmännische Und (\cmd{\&}) ist bei HTML ein Zeichen, das eine
Formatierung für ein Sonderzeichen einleitet. Daher kann man ein
\cmd{\&}-Zeichen nicht einfach alleinstehend einsetzen, sondern muss es
speziell maskieren. Der Button bindet dafür das Sonderzeichen
\cmd{\&\#38;} ein.

\ospitem{\menu{Gedankenstrich-Button aktivieren}}
Der lange Gedankenstrich wird durch das Sonderzeichen \cmd{\&\#8212;}
repräsentiert. Wenn Sie die Option \menu{Use Named Entities} aktivieren,
wird stattdessen das (gleichwertige) Sonderzeichen \cmd{\&mdash;}
eingebunden, das man sich zugegebenermaßen für eine manuelle Eingabe
besser merken kann.

\ospitem{\menu{Kurzer Gedankenstrich-Button aktivieren}}
Analog zum langen Gedankenstrich gibt es auch einen kurzen
Gedankenstrich, der \cmd{\&\#8211;} bzw. \cmd{\&ndash;} entspricht.

\ospitem{\menu{Aufzählungszeichen-Button aktivieren}}
Das Aufzählungszeichen (ein mittig ausgerichteter Kreis) wird durch das
Sonderzeichen \cmd{\&\#8226;} bzw. \cmd{\&bull;} eingebunden.

\ospitem{\menu{Doppelte Anführungszeichen-Button aktivieren}}
Ein Wort kann in typografischen Anführungszeichen eingebunden werden,
wenn Sie diesen Button aktivieren. Welche Anführungszeichen Sie verwenden
möchten, können Sie mit der darunterstehenden Option festlegen. Abhängig
von der Option \menu{Use Named Entities} werden später auch für diese
Anführungszeichen entweder numerische Codes oder die Namen der
Sonderzeichen (\cmd{\&laquo;, \&raquo;} etc.) eingefügt.

\ospitem{\menu{Choose the type of double quote to use}}
Hier können Sie einen gewünschten Anführungszeichen-Typ (1 bis 8)
auswählen. Welche Anführungszeichen möglich sind, wird anhand von
Beispielen dargestellt.

\ospitem{\menu{Einfache Anführungszeichen-Botton aktivieren}}
Analog zu doppelten Anführungszeichen können Sie ein Wort auch in
einfachen Anführungszeichen einschließen.

\ospitem{\menu{Choose the type of single quote to use}}
Wie bei den doppelten Anführungszeichen wählen Sie mit dieser Option den
gewünschten Typ (1 bis 8) aus.

\index{Apostroph}%
\ospitem{\menu{Apostroph-Button aktivieren, Use real apostrophe}} Der
Apostroph (\cmd{'}) ist wohl das im deutschen Sprachraum am häufigsten
falsch eingesetzte Sonderzeichen. Oft sieht man stattdessen die
gedrehte Variante (\cmd{`}). Auch im HTML-Standard gibt es mehrere
Möglichkeiten.

Das Plugin verwendet entweder \cmd{\&\#39;}, \cmd{\&\#8217;} oder
\cmd{\&rsquo;}.

\cmd{\&\#39;} wird benutzt, wenn Sie die Option \menu{Use real
apostrophe} aktivieren. Dies ist der "`einzig wahre"' Apostroph.

\cmd{\&\#8217;} wird eingesetzt, wenn Sie die beiden Optionen \menu{Use
real apostrophe} und \menu{Use Named Entities} nicht aktiviert haben. Das
daraus resultierende Sonderzeichen ist eigentlich ein einfaches
Anführungszeichen, das wie ein hochgestelltes Komma aussieht.

\cmd{\&rsquo;} wird bei deaktiviertem \menu{Use real apostrophe} und
aktiviertem \menu{Use Named Entities} angezeigt und sieht 
genauso wie \cmd{\&\#8217;} aus.

\ospitem{\menu{Akzent-Button aktivieren}}
Das häufig als Apostroph missbrauchte Zeichen kann über diesen Button
eingebunden werden (\cmd{\&\#x0301;}).

\ospitem{\menu{Schräger-Akzent-Button aktivieren}}
Der umgekehrte Akzent wird über diesen Button als \cmd{\&\#x0300;}
eingebunden.

\ospitem{\menu{XHTML-1.1-Standard verwenden}}
Mit dieser Option bestimmen Sie, ob die Tags für Center und
Strike-Through anhand des HTML- oder des XHTML-Standards eingefügt werden
sollen.

\ospitem{\menu{Use Named Entities}}
Wenn Sie diese Option aktivieren, werden anstelle der Namen einiger
Sonderzeichen die Zahlencodes verwendet. Wenn Sie sich die Sonderzeichen
nicht einprägen wollen, ist es empfehlenswert, diese Option zu
deaktivieren. Die Zahlenwerte (wie \cmd{\&\#8211;}) können
sys\-tem\-übergreifend besser von Browsern interpretiert werden als die
benannten Sonderzeichen (wie \cmd{\&ndash;}).

\osppagebreak

\index{Eigene Buttons}%
\ospitem{\menu{Custom HTML-Tags}}
Eine sehr flexible Option zum Hinzufügen von beliebigen Buttons in Ihre
Eintragsmaske stellt die Option \menu{Custom HTML-Tags} dar. Dort können
Sie eine Liste von HTML-Codes einfügen, die durch Klick auf den
entsprechenden Button einen gewählten Text mit dem gewünschten HTML-Code
umgeben.

Ein klassisches Einsatzgebiet hierfür ist die Bereitstellung eigener
Formatierungsvorlagen. Wenn Sie Ihren Redakteuren spezielle
HTML-DIV-Container in der zentralen Stylesheet-Datei (siehe Kapitel
\ref{template-css} ab \pageref{template-css})
angelegt haben, den Redakteuren aber nicht zumuten wollen, eigenes
HTML zu schreiben, können Sie für die vorhandenen Container jeweils einen
eigenen Button hinzufügen. Wenn Sie beispielsweise Zitate durch den
HTML-Code

\begin{ospcode}
<div class="{}MyQuote"{}>
 Errare humanum est
</div>
\end{ospcode}

auszeichnen wollen, können Sie dieses \cmd{<div>}-Konstrukt  als
Button oberhalb der Texteingabemaske einbinden. Der Redakteur muss sein
Zitat dann nur markieren, klickt auf den Button, und daraufhin wird der
gewählte Text in das aufgeführte HTML-Konstrukt überführt.

Welche HTML-Tags Sie einbinden, ist völlig Ihren Wünschen
überlassen. So könnten Sie dort auch einen Button für das Einfügen von
JavaScript einbinden.

Die Liste der HTML-Tags tragen Sie in dem Konfigurationsfeld \menu{Custom
HTML-Tags} ein. Diese Liste muss in einem ganz speziellen Format
vorliegen.

Zum einen werden mehrere Buttons mit dem Zeichen \cmd{|} (das
\emph{Pipe}-Symbol) voneinander getrennt. Der Übersichtlichkeit halber
können Sie nach jedem \cmd{|} auch gerne einen Zeilenumbruch einfügen.

Jeder einzelne Button muss daraufhin drei Attribute besitzen: Wie der
Button benannt wird, welches HTML-Tag bei einem Klick vor einem
ausgewählten Text eingefügt wird und welches HTML-Tag nach der
Textauswahl eingefügt wird. Diese drei Attribute werden von dem
\cmd{@}-Zeichen voneinander getrennt.

Demnach wäre obiges Beispiel durch folgende Syntax umzusetzen:

\begin{ospcode}
Zitat@<div class="{}MyQuote"{}>@</div>
\end{ospcode}

Der Button wird also mit dem Text \emph{Zitat} in der Symbolleiste
oberhalb des Eintrags eingebunden. Bei einem Klick auf diesen Button wird
dem Text, den Sie ausgewählt haben, ein \cmd{<div\ldots>}
vorangestellt und ein \cmd{</div>} angefügt.

\end{ospdescription}


\index{Plugins!Trackbacks kontrollieren}%
\index{Plugins!serendipity\_event\_trackback}%
\subsection{Trackbacks kontrollieren\newline serendipity\_event\_trackback}
\label{trackbacks}%
\index{Trackbacks}%
\index{Fehler!Trackbacks}%
\index{Fehler!Firewall}%
\index{Proxy}%
\index{Fehler!Proxy}%
Wenn Serendipity Ihren Artikel speichert, durchsucht es den Eintrag nach
allen Links. Dabei werden Trackbacks an automatisch erkannte Blogs
verschickt (siehe Seite \pageref{trackback}).

Manche Blogs binden jedoch leider ihre Trackback-URL in einem
Artikel nicht standardkonform so ein, dass Serendipity sich dorthin automatisch
verbinden kann. In einem solchen Fall benötigen Sie das Plugin \emph{Trackbacks
kontrollieren}, denn dieses Plugin ermöglicht es Ihnen, manuelle
Trackback-URLs zu einem Eintrag hinzuzufügen.

Zusätzlich bietet das Plugin Ihnen die Möglichkeit, ausgehende Trackbacks
global in Ihrem Blog zu deaktivieren. Dann sendet Serendipity beim
Speichern Ihrer Artikel keinerlei Trackbacks, dies empfiehlt sich also
besonders bei versteckten Blogs oder Intranet-Blogs, die mit der
Außenwelt nicht in Kontakt treten sollen. Abgesehen von diesem Plugin
regelt auch die Variable \cmd{\$serendipity['noautodiscovery']} der Datei
\cmd{serendipity\_config\_\osplinebreak{}local.inc.php} die globale Deaktivierung von
Trackbacks, wie auf Seite \pageref{noautodiscovery} beschrieben.

Ein weiteres praktisches Feature des Plugins ist, dass Sie in der Konfiguration
einen Web-Proxy eintragen können. Ein Proxy ist ein Server, der als Bindeglied
zwischen Webserver und dem Internet steht. Oft ist es einem Webserver aus
Sicherheitsgründen nicht erlaubt, direkt auf andere Server zuzugreifen. Dies ist
auch der häufigste Grund dafür, dass das Spartacus-Plugin (siehe Seite
\pageref{Spartacus}) nicht funktioniert. Wenn der Webserver jedoch auf
einen Proxy-Server zugreifen darf, können die Zugriffe auf fremde Server über
den Proxy geleitet werden.

Auch wenn Serendipity Trackbacks verschickt, muss es direkt auf einen
Server zugreifen können. Damit Sie einen Proxy dazwischensetzen können,
bietet das Trackback-Plugin die Möglichkeit, einen solchen Server
einzutragen. Serendipity wird dann nicht nur beim Senden von Trackbacks,
sondern schon beim Zugriff auf Spartacus diesen Proxy-Server
benutzen, da fast alle URL-Aufrufe von Serendipity über denselben
Mechanismus (die PEAR \cmd{HTTP::Request}-Bibliothek) ausgeführt werden.

Abgesehen von der Proxy-Konfiguration bietet das Plugin die Option
\menu{Dis\-able the global use of trackbacks}, die bei Aktivierung dafür
sorgt, dass keine Trackbacks verschickt werden. Da Serendipity
üblicherweise auch Trackbacks zu Ihren eigenen Artikeln schickt, können
Sie dies ebenfalls im Plugin über die Option \menu{Send trackbacks to
your own blog} deaktivieren.

Wenn Sie das Trackback-Plugin installiert haben und Trackbacks nicht
global deaktiviert sind, sehen Sie in den \emph{Erweiterten Optionen} beim
Erstellen eines Artikels eine neue Eingabemaske. Dort werden bereits im
Eintrag erkannte Links aufgeführt, und zusätzlich können Sie hier weitere
URLs eintragen, zu denen Serendipity ein Trackback schicken soll. Mehrere
Links werden durch ein Leerzeichen oder einen Zeilenumbruch getrennt.

Mitttels dreier Optionsfelder können Sie bestimmen, wie Trackbacks für den
jeweiligen Eintrag gesendet werden sollen:

\begin{ospdescription}
\ospitem{\menu{Trackbacks an erkannte Links im Eintrag senden}}
Diese Option bewirkt, dass Serendipity automatisch alle im Eintrag eingetragenen
URLs auf Trackbacks prüft. Etwaige weitere, manuell eingefügte Links in der Box
\menu{Weitere Links für Trackbacks} werden zusätzlich geprüft.

\ospitem{\menu{Ausgehende Trackbacks deaktivieren}}
Ist diese Option ausgewählt, prüft Serendipity weder automatisch die Links
innerhalb Ihres Beitrags, noch sendet es Trackbacks an die Liste weiterer,
manuell eingefügter URLs.

\ospitem{\menu{Trackbacks nur an unten aufgeführte URLs schicken}}
Wenn Sie Trackbacks ausschließlich an die manuell eingetragenen Trackback-URLs
senden wollen, wählen Sie diese Option. Dadurch wird die automatische Erkennung
von Links in Ihrem Artikel deaktiviert. 

\end{ospdescription}

Bitte achten Sie darauf, dass Serendipity bei jedem Speichern eines
veröffentlichten Eintrags Trackbacks prüft. Wenn Sie also später mal
einen Artikel überarbeiten, bei dem Sie ursprünglich die Option zum
Versenden von Trackbacks deaktiviert hatten, müssen Sie daran denken,
auch beim neuen Speichern diese Option zu deaktivieren.

Stellen wir uns also konkret folgendes Beispiel vor: Sie schreiben einen
Artikel zu einem fremden Blog-Beitrag auf \cmd{http://example.com/wp/?p=15}.
Dafür würden Sie folgenden HTML-Code in Ihrem Beitrag verwenden:

\begin{ospcode}
Hanni und Nanni <a href="http://example.com/wp/?p=15">berichten in ihrem
Blog</a> darüber, wie man von WordPress auf Serendipity umsteigen kann
und damit höchste Glückseligkeit erreicht. Sehr spannender Artikel, ich
habe es direkt ausprobiert und lasse gerade mein Shakra richtig entspannt
herumbaumeln.
\end{ospcode}

Wenn Sie diesen Artikel speichern, greift Serendipity auf die genannte
URL \cmd{http://example.com/wp/?p=15} zu. Wäre in dem Beitrag die
Trackback-URL korrekt enthalten, würde Serendipity das Trackback direkt
abschicken. In unserem Beispiel gehen wir aber davon aus, dass die
automatische Erkennung fehlschlägt, da Hanni und Nanni leider ein
Blog-Template benutzen, das die Trackback-URL nicht korrekt über
RDF-Metadaten einbindet (siehe Trackback-Kapitel ab Seite \pageref{trackback}).

Daher müssen wir uns nun auf die Jagd nach der Trackback-URL machen. Dazu
rufen wir das Blog selber im Browser auf, und meist stößt man auf eine Angabe
des Blogs zu einer manuellen Trackback-URL. Auch Serendipity gibt eine derartige URL
auf den Artikel-Detailseiten für fremde Blogsysteme an. In unserem Fall
wäre die gewünschte URL
\cmd{http://example.com/wp/""wp-trackback.php?id=15}. Diese URL notieren
Sie sich und fügen sie in die Eingabebox \menu{Weitere Links für
Trackbacks} ein, speichern den Artikel dann erneut ab -- und Serendipity
wird nun das Trackback an diese genannte URL schicken, da es die
automatische Erkennung nicht mehr benötigt.

Bei dem Beispiel ist es extrem wichtig, dass Sie die manuelle
Trackback-URL \emph{nicht} im Artikel erwähnen! Wenn Sie dies machen,
würde Serendipity weiterhin denken, es müsste bei dieser URL einen
automatischen Trackback erkennen, der zwangsweise scheitern wird. Wie
man in so einem Fall Trackbacks erneut vollständig ausführen kann,
entnehmen Sie ebenfalls Kapitel \ref{trackback} ab Seite \pageref{trackbacks-resend}.


%HIER

\index{Backend!RSS-Feeds}%
\index{Plugins!Display RSS-Feed in Backend Overview}%
\index{Plugins!serendipity\_event\_backendrss}%
\subsection{Display RSS-Feed in Backend Overview\newline
serendipity\_event\_backendrss}

Wenn Sie sich ins Backend einloggen, sehen Sie üblicherweise eine ziemlich
leere Seite. Diesen Platz können Sie ausnutzen, um etwas gehaltvollere
Informationen darzustellen, wie beispielsweise einen RSS-Feed.

Ähnlich wie das Plugin \emph{Fremder RSS/OPML-Blogroll Feed} (siehe Seite
\pageref{remoterss}) bietet das Plugin \emph{Display RSS-Feed in Backend
Overview} die Möglichkeit, beliebige RSS-Feeds einzubinden. Die
Konfigurationsoptionen sind dabei ähnlich gestaltet:

\begin{ospdescription}
\ospitem{\menu{Anzahl der Einträge}}
Bestimmt, wie viele Einträge aus dem RSS-Feed angezeigt werden sollen. Die
Zahl \cmd{0} entspricht allen Einträgen des Feeds. Sie können immer nur
maximal so viele Einträge darstellen, wie der Feed enthält.

\ospitem{\menu{Feed-Titel}}
Hiermit legen Sie die Überschrift des RSS-Feeds fest. Da Sie mehrere
RSS-Feeds im Backend darstellen können, sollten Sie die Überschriften zur
Abgrenzung eindeutig vergeben.

\ospitem{\menu{RSS/OPML-URI}}
In diesem Eingabefeld tragen Sie die vollständige URL des RSS-Feeds ein,
den Sie darstellen möchten.

\ospitem{\menu{Zeichensatz}}
Die Option \menu{Zeichensatz} legt fest, in welchem Zeichensatz der
fremde RSS-Feed formatiert ist. Bei den meisten RSS-Feeds ist dies
\menu{UTF-8}.

\ospitem{\menu{Link-Target}}
Der RSS-Feed zeigt nur die Überschriften der Beiträge an, ein Klick auf
den jeweiligen Beitrag öffnet diesen standardmäßig in einem neuen Fenster
(\cmd{\_blank}). Wenn Sie stattdessen den Beitrag gerne im selben
Browser-Fenster lesen möchten, können Sie hier ein anderes Ziel (z.\,B.\
\cmd{\_self} oder leer) eintragen.

\ospitem{\menu{Wann wird der Feed aktualisiert}}
Der RSS-Feed wird vom Plugin gecached, damit nicht bei jedem Aufruf des
Backends der fremde Webserver kontaktiert wird. Tragen Sie in diesem
Feld ein, wie lange ein Feed zwischengespeichert werden soll.
Standardmäßig sind dies 3 Tage (10800 Sekunden).

\end{ospdescription}

Sie können diesen RSS-Feed in der Admin-Oberfläche gut dazu benutzen,
den RSS-Feed vom offiziellen
Serendipity-Blog\footnote{\cmd{http://blog.s9y.org/rss.php}} zu
abonnieren. So können Sie direkt beim Login in Ihr Blog erkennen, ob
es möglicherweise neue Versionen der Software gibt, in der z.\,B.\
Sicherheitslücken behoben worden sind.

\index{Plugins!HTML-Code für den head-Bereich}%
\index{Plugins!serendipity\_event\_head\_nugget}%
\index{Plugins!HTML-Nugget@HTML Nugget on Page}%
\index{Plugins!serendipity\_event\_page\_nugget}%
\subsection{HTML-Code für den head-Bereich (HTML-Kopf-Klotz) und HTML
Nugget on Page\newline serendipity\_event\_head\_nugget,\newline
serendipity\_event\_page\_nugget}
\index{HTMLKlotz@HTML-Klotz}%
\label{headnugget}%

Ähnlich wie der berühmte HTML-Klotz (siehe Seite \pageref{htmlnugget})
ermöglicht es das Plugin \emph{HTML-Code für den head-Bereich}, beliebigen HTML-Code (oder
JavaScript) in Ihr Blog einzubinden. Dieser HTML-Code wird dann im 
HTML-\cmd{<head>}-Bereich eingebunden. In diesem Bereich findet man
üblicherweise Meta-Tags und seitenübergreifende JavaScripts. Google
Analytics beispielsweise muss in diesen Kopf-Bereich eingefügt werden.

Grundsätzlich können Sie derartigen Code natürlich auch in die
Template-Datei \cmd{index.tpl} einfügen. Der Nachteil dieser Methode wäre
allerdings, dass Sie ihn bei jedem neuen Template neu einfügen müssen
und nicht einfach das Template wechseln können. Auch müssen Sie zum
Einfügen extra das FTP-Programm und einen Editor bemühen, während der
HTML-Kopf-Klotz eine einfachere Eingabe über ein zentrales Plugin
ermöglicht.

Zugleich ist dieses Plugin wohl das kleinste existierende
Serendipity-Plugin, und daher sehr geeignet, um einmal in die
Programmierweise von Plugins hineinzuschnuppern.

Komplexere Möglichkeiten zum Einfügen von \emph{Klötzen} bietet das
Plugin namens \emph{HTML Nugget on Page} (\cmd{serendipity\_event\_page\_nugget}).
Dort kann man einen Klotz beliebig im Kopf-Bereich oder im Inhaltsbereich
(Header, Footer, Seitenende) platzieren. Dieses Plugin ermöglicht auch
die Benutzung der verfügbaren Textformatierungs-Plugins und lässt sich
analog zum \emph{HTML-Klotz} auch so konfigurieren, dass es nur auf
Artikel"=Detailseiten oder nur auf Artikel-Übersichtsseiten angezeigt
wird.

\index{Plugins!Versioning of entries}%
\index{Plugins!serendipity\_event\_versioning}%
\subsection{Versioning of entries\newline serendipity\_event\_versioning}

\index{Versionierung}%
\index{Backup}%
\index{Sicherheitsmaßnahmen}%
Jedesmal wenn Sie einen Blog-Artikel neu speichern, wird die vorige
Version überschrieben. Wenn Sie einen Beitrag versehentlich durch ein
einziges Wort ersetzen und speichern, ist also sämtlicher voriger Text
unwiderruflich verloren.\footnote{Es sei denn, Sie haben vorausschauend
regelmäßig Backups angelegt.}

Um dieses Problem zu umgehen, gibt es das Plugin \emph{Versioning of
entries}. Wie der englische Titel suggeriert, kümmert sich das Plugin um
eine Versionskontrolle von Artikeln. Jedes Speichern eines Artikels mit
unterschiedlichem Text führt dazu, dass das Plugin den Artikeltext
(\emph{Eintrag} und \emph{Erweiterter Eintrag}) in einer zweiten
Datenbanktabelle (\cmd{serendipity\_versioning}) speichert. Diese
Datensatzkopie wird mit dem aktuellen Datum und Autor verknüpft.

In der Konfiguration des Plugins können Sie einstellen, ob mehrere
Versionen eines Artikels auch für Ihre Besucher im Frontend dargestellt
werden sollen. Ein Besucher kann dann eine beliebige vorige Version
aufrufen und so nachlesen, was sich zwischen den einzelnen
Bearbeitungszuständen verändert hat.

Ein Redakteur hat im Abschnitt \emph{Erweiterte Optionen} beim Erstellen
oder Bearbeiten eines Artikels die Möglichkeit, eine beliebige
vorhergehende Version wiederherzustellen und neu abzuspeichern. Die
Zwischenversionen bleiben dabei intakt, da die Übernahme einer alten
Version lediglich eine neue, aktuelle Version einführt.

Bitte beachten Sie, dass das Plugin außer dem Artikeltext keine anderen
Veränderungen\footnote{Beispielsweise an \emph{Erweiterten Optionen}, der
Kategoriezuweisung oder auch dem Artikeltitel.} speichern und auch
in der jetzigen Version keinen Vergleich innerhalb der Versionen
durchführen kann.

\subsubsection{Datenbanktabelle}

\index{Datenbank-Tabellen!serendipity\_versioning}%
Die Datenbanktabelle \cmd{serendipity\_versioning} enthält alle gespeicherten
Versionen eines Artikels:

\osppagebreak

\begin{ospdescription}
\ospitem{\cmd{id}} enthält die fortlaufende Versionsnummer.
\ospitem{\cmd{entry\_id}} enthält die Artikel-ID der jeweiligen Version. 
\ospitem{\cmd{version}} enthält eine numerisch erhöhte Versionsnummer. 
\ospitem{\cmd{body}} enthält den Artikeltext dieser Version. 
\ospitem{\cmd{extended}} enthält den erweiterten Artikeltext dieser Version. 
\ospitem{\cmd{version\_date}} enthält das Datum, an dem diese Revision angelegt wurde. 
\ospitem{\cmd{version\_author}} enthält die ID des Redakteurs, der diese Revision
erstellt hat. 
\end{ospdescription}

\label{Cronjobsched}%
\index{Plugins!Cronjob scheduler}%
\index{Plugins!serendipity\_event\_cronjob}%
\subsection{Cronjob scheduler\newline serendipity\_event\_cronjob}

\index{Cronjob}%
\index{Automatische Ausführung}%
Der Begriff \emph{Cronjob} ist die Kurzform für eine wiederkehrende
(\emph{chronologische}) Aufgabe und stammt ursprünglich von
Unix-Betriebssystemen. Bei derartigen Betriebssystemen kann in beliebigen
Zeit-Intervallen automatisch ein Programm oder eine Aktion ausgeführt werden.

Solche regelmäßigen Cronjobs sind auch im Blog-Umfeld von Interesse.
Beispielsweise bietet Serendipity Plugins an, die regelmäßig RSS-Feeds
importieren (Aggregator, siehe Seite \pageref{aggregator}) oder regelmäßig E-Mails als
Blog-Artikel abrufen (Popfetcher, siehe Seite
\pageref{serendipity-event-popfetcher}).

Eine solch regelmäßige Aktion kann Ihr PHP-Webserver üblicherweise nicht selbst
ausführen. Serendipity ist keine Anwendung, die wie ein Betriebssystem
ständig im Hintergrund läuft, sondern man muss sich das System eher wie einen Bären im
Winterschlaf vorstellen. Der Bär ist nur dann wach, wenn gerade ein Besucher
seine Höhle aufsucht und ihn mit großem Lärm aufweckt. Wenn der ungebetene Gast
vom Bären \emph{versorgt} wurde, kehrt wieder Ruhe ein und der Bär schläft
weiter. Für unser Blog bedeutet das: Wenn kein Besucher oder Redakteur gerade das
Blog aufruft, ist Serendipity inaktiv und kann keine Aktionen ausführen.

Daher kann Serendipity von sich aus nicht einfach einen Vorgang
auslösen, sondern ist abhängig von Ihren Aktionen. Bei der Benutzung
der genannten Plugins müssen Sie selber dafür sorgen, dass eine spezielle URL
aufgerufen wird, die wiederum die eigentliche Funktionalität aufruft. Wenn Sie
einen eigenen Webserver administrieren, könnten Sie diese URL in die Liste der Cronjobs
(die \emph{Crontab}) aufnehmen und automatisch aufrufen.

Jedoch ist diese Möglichkeit für viele Benutzer keine Option. Hier kommt
das Plugin \emph{Cronjob scheduler} ins Spiel. Das Plugin ermöglicht es
Ihnen, unterstützte Plugins in einem gewünschten Intervall aufzurufen.

Dabei bedient sich das Plugin eines kleinen Tricks. Es bindet im Frontend
eine unsichtbare Datei ein, die von jedem Besucher aufgerufen
wird, ohne dass dieser das merkt. Die Datei prüft, wann der
letzte automatische Aufruf stattfand, und startet gegebenenfalls die
notwendigen Aktionen. Andernfalls tut das Plugin nichts und
wartet auf den nächsten Aufruf.

Dieser Aufruf durch einen Besucher hat natürlich den Nachteil, dass man
niemals exakt voraussagen kann, ob auch wirklich zum benötigten Zeitpunkt
jemand das Blog besucht. Wenn ein Job alle fünf Minuten ausgeführt
werden soll, aber statistisch nur alle zwei Stunden ein Besucher
vorbeikommt, dann wird dieser Job faktisch auch nur alle zwei Stunden
ausgeführt. In den meisten Fällen ist das kein Problem, da, wenn es früher
keine Besucher gibt, die neu importierten Daten des Jobs sowieso nicht
benötigt werden. Das Cronjob-Plugin wird zentral über die URL
\cmd{http://www.ex\-ample.com/serendipity/index.php?serendipity[cronjob]=true}\osplinebreak{}
aufgerufen. Dies ist die erwähnte \emph{unsichtbare Datei}, die ein
Besucher aufruft. Natürlich können Sie diese URL auch von einer Crontab
aus alle fünf Minuten aufrufen, anstatt dies Ihren Besuchern zu überlassen.
In so einem Fall können Sie das Plugin über die Konfigurationsoptionen so
einstellen, dass die \menu{visitor-based cronjobs} deaktiviert werden.

Welche Aktionen der Cronjob ausführt, stellen Sie nicht innerhalb des
Cron\-job-Plugins ein, sondern in dem jeweiligen Plugin. Bei jedem
unterstützten Plugin können Sie in den Konfigurationsoptionen 
einstellen, in welchem Zeitraum (alle fünf Minuten, 30 Minuten,
stündlich, halbtäglich, täglich, wöchentlich, monatlich) die Aktion
ausgeführt wird. In der Konfiguration des Cronjob-Plugins sehen Sie eine
Liste aller eingerichteten Cronjobs, und wann diese zuletzt ausgeführt
worden sind.

\index{Datenbank-Tabellen!serendipity\_cronjoblog}%
Bei jedem Aufruf schreibt das
Plugin einen kleinen Logfile-Eintrag in die Datenbanktabelle
\cmd{serendipity\_cronjoblog}. Diese können Sie jederzeit leeren (nicht löschen),
wenn Sie Speicherplatz sparen wollen. Die Spalte \cmd{timestamp} enthält das
Datum der Cronjob-Ausführung, \cmd{type} die Cronjob-Art und \cmd{reason} einen
Informationstext zur Ausführung.

\index{Plugins!QuickNotes}%
\index{Plugins!serendipity\_event\_adminnotes}%
\index{Kommunikation!unter Redakteuren}%
\subsection{QuickNotes\newline serendipity\_event\_adminnotes}

Die Kommunikation unter Redakteuren läuft in einem Blog meist 
informell ab: Man spricht sich persönlich, via Telefon oder
E-Mail ab -- und Gerüchten zufolge ist es vielen Bloggern auch egal, was
ihre Co-Autoren so treiben.

Das Plugin \emph{QuickNotes} nimmt sich des Kommunikationsproblems an und
verwandelt die Startseite des Backends in ein Nachrichtenzentrum. Dort
können Chefredakteure Anweisungen an die Benutzer weiterreichen,
Administratoren können über etwaige neue Plugins berichten und einfache
Redakteure über ihre Artikel informieren.

Die Nachrichten arbeiten grundsätzlich gruppenorientiert. Eine Nachricht
wird immer für eine festgelegte Autorengruppe eingeblendet, das heißt,
dass Mitglieder anderer Gruppen die Nachricht nicht sehen können. Notizen
können zudem nur an die Gruppen geschrieben werden, in denen man Mitglied
ist. Daher ist es unter Umständen für dieses Plugin notwendig, dass Sie
als Administrator auch anderen Benutzergruppen beitreten (siehe
Seite \pageref{verboteneplugins}), um Nachrichten an diese zu verfassen.

In der Übersicht werden QuickNotes wie in folgender Abbildung dargestellt:


\ospfigure{0.98}{img/quicknotes.eps}{Beispiel für QuickNotes}{fig:img/quicknotes.eps}%

Nachrichten, die Sie noch nicht gelesen haben, werden speziell
hervorgehoben, bereits gelesene Nachrichten werden normal dargestellt. In
jedem Kasten befindet sich der Titel einer Notiz, die Angabe des
Herausgebers der Information und das dazugehörige Datum. Besonders
lange Hinweise können nach einer gewissen Textmenge abgeschnitten werden,
ein Klick auf den Button \menu{Alle Optionen ein/ausblenden} zeigt
den vollständigen Text an. Alle QuickNotes werden chronologisch
sortiert, ihre Anzahl richtet sich nach der Konfiguration des Plugins.

Sie können eine neue Notiz anlegen, indem Sie auf den Menüpunkt
\menu{Einträge\sm QuickNotes} klicken. Dort sehen Sie eine Liste aller Notizen, chronologisch 
sortiert. Mittels der Buttons \menu{Bearbeiten}
und \menu{Löschen} können Sie eine bestehende Notiz verändern, der Button
\menu{Neuer Eintrag} legt eine neue Notiz an.

Beim Anlegen einer neuen Notiz tragen Sie den \menu{Titel} und den
\menu{Text} in den vorhergesehenen Feldern ein. In dem
Mehrfach-Auswahlfeld \menu{Gruppenzugehörigkeit} markieren Sie alle Gruppen, 
für die die Nachricht bestimmt ist.

Die Konfigurationsoptionen des Plugins ermöglichen Ihnen weitere
Einstellungen zu Menge und Darstellung der Notizen:

\begin{ospdescription}
\ospitem{\menu{Sollen Autoren eigene Hinweise anlegen dürfen}}
Wenn Sie diese Option nicht aktivieren, können nur Chefredakteure und
Administratoren\footnote{Die Identifikation erfolgt anhand des
Benutzerrangs, nicht der Zugehörigkeit zu den gleichnamigen
Benutzergruppen.} QuickNotes anlegen. Bei aktivierter Option können auch
normale Autoren Nachrichten an die Mitglieder ihrer Benutzergruppen
senden.

\ospitem{\menu{Wie viele Elemente sollen angezeigt werden}}
Tragen Sie in dieses Feld die Anzahl der QuickNotes ein, die auf der
Startseite angezeigt werden sollen.

\ospitem{\menu{HTML-Formatierung erlauben}}
Standardmäßig dürfen die QuickNotes (aus Sicherheitsgründen) nur normalen
Text enthalten und keinen HTML-Code. So können Sie verhindern, dass
böswillige Redakteure möglicherweise JavaScript einschleusen. 
Mit dieser Option können Sie gezielt HTML"=Formatierungen auch nur
für Benutzer mit Administrator-Rang zugänglich machen.

\ospitem{\menu{Textformatierung(en) durchführen}}
Der Text einer QuickNote kann, wie auch bei Blog-Artikeln üblich, mit den
installierten Textformatierungs-Plugins behandelt werden. Standardmäßig
ist dies aktiviert. Wenn Sie jedoch den Text ohne weitere Umformatierung
darstellen wollen, können Sie diese Option deaktivieren.

\ospitem{\menu{Nachrichten nach X Bytes kürzen}}
Lange Notizen werden in der Übersicht nach einer festgelegten Anzahl an
Zeichen gekürzt. Längere Notizen müssen dann erst durch einen Klick auf
den Button \menu{Alle Optionen ein/ausblenden} gezielt geöffnet werden
und belegen so keinen wertvollen Bildschirmplatz.

\end{ospdescription}

Das Aussehen der Admin-Notes können Sie über das Admin-Stylesheet (siehe Seite
\pageref{template-css}) beeinflussen, indem Sie die CSS-Klassen
\cmd{.serendipity\_note} und \cmd{.note\_new} der Plugin-Datei
\cmd{plugins/serendipity\_event\_admin\-notes/notes.css} entweder anpassen oder in
die \cmd{admin/style.css}-Tem\-plate-Datei übernehmen. Weitere HTML-Klassen bei der
Ausgabe der Notizen sind verfügbar, diese können Sie im Bedarfsfall anhand des
HTML-Quelltextes in Ihrem Browser einsehen und dann dem Stylesheet hinzufügen.

\subsubsection{Datenbanktabellen}

\index{Datenbank-Tabellen!serendipity\_adminnotes}%
QuickNotes werden in der Datenbanktabelle \cmd{serendipity\_adminnotes}
gespeichert: 

\begin{ospdescription}
\ospitem{\cmd{noteid}} enthält die fortlaufende ID einer QuickNote.
\ospitem{\cmd{authorid}} enthält die ID des Redakteurs, der die QuickNote erstellt
hat.
\ospitem{\cmd{notetime}} enthält die Erstellungszeit der QuickNote.
\ospitem{\cmd{subject}} enthält den Betreff der QuickNote.
\ospitem{\cmd{body}} enthält den Inhalt der QuickNote.
\ospitem{\cmd{notetype}} gibt die Art der QuickNote an (derzeit nur \cmd{note} unterstützt).
\end{ospdescription}

\index{Datenbank-Tabellen!serendipity\_adminnotes\_to\_groups}%
\cmd{serendipity\_adminnotes\_to\_groups} ist eine 
1:n"=Zuordnungstabelle, die erstellte QuickNotes den Empfänger-Benutzergruppen
zuordnet. In Spalte \cmd{noteid} wird die ID der QuickNote gespeichert,
\cmd{groupid} enthält die ID der jeweiligen Benutzergruppe.


\index{Plugins!Benutzerprofile}%
\index{Plugins!serendipity\_event\_userprofiles}%
\index{Benutzerprofile}%
\subsection{Benutzerprofile\newline serendipity\_event\_userprofiles}

Bei Blogs, in denen mehrere Redakteure schreiben, ist es für den Besucher
oft interessant, Details über einzelne Redakteure zu erfahren. Redakteure
wiederum möchten möglicherweise gerne auch etwas mehr Informationen über
sich preisgeben.

Viele Blogs regeln dies durch Einführungsartikel, in denen sich ein
Redakteur vorstellt. Solche Artikel sind aber später 
möglicherweise nicht immer im Blickfeld eines Besuchers.

Deshalb bietet das Plugin \emph{Benutzerprofile} eine Möglichkeit, mit der
jeder Redakteur Details zu seiner Person in vorausgefüllte Felder (wie
Wohnort, Land, Hobbies, Homepage etc.) eintragen kann. Diese Felder
können Besucher des Blogs dann einsehen, wenn sie im Frontend auf den
Namen eines Redakteurs klicken. Oberhalb der Übersicht der von dem jeweiligen Redakteur
geschriebenen Artikel sehen sie dann eine Box mit den
eingetragenen Profildaten.

\index{Timestamps}%
\index{Unix-Zeitstempel}%
\index{Terminologie!Timestamps}%
Die Benutzerprofile verwaltet das Plugin, indem es sich in den
Admin-Bereich \menu{Eigene Einstellungen} einklinkt. Unterhalb der
bekannten Einstellungen sehen Sie einen neuen Bereich, in dem die
verfügbaren Redakteure aufgelistet sind, wobei Ihr Name standardmäßig
hervorgehoben ist. Direkt darunter befinden sich die jeweiligen
Profilfelder wie \emph{Voller Name}, \emph{Homepage}, \emph{Hobbies} und
so weiter. Dort kann der jeweilige Redakteur sämtliche Felder seiner Datei
ausfüllen und auf \menu{Speichern} klicken. Bitte beachten Sie, dass
aus technischen Gründen Geburtstage vor dem
01.01.1970\footnote{Dieses Datum markiert Sekunde 1 der Unix-Zeitrechnung. Alle
Unix-Server arbeiten intern mit sogenannten Timestamps, daher werden auch
in vielen Datenbanken Timestamps zur Formatierung von Zeitpunkten
verwendet, da damit leichter zu rechnen ist und sie sich einfacher in
beliebige Zeitzonen umrechnen lassen.} von dem Plugin leider nicht
korrekt ausgewertet werden können.

Zusätzlich bindet das Plugin dieselbe Oberfläche auch unter dem
eigenständigen Menüpunkt \menu{Administration\sm Benutzerprofile} ein.

In dem Ausklappfeld der Benutzerprofile können Sie auch die Daten anderer
Redakteure bequem einsehen. Als höherrangiger Chefredakteur oder
Administrator können Sie außerdem alle Profildaten der niederrangigeren
Redakteure bearbeiten. Profildaten von Redakteuren des gleichen
Benutzerranges können Sie nur ansehen, aber nicht bearbeiten.

Wenn Sie auf den Button \menu{Erweiterte Optionen} klicken, können Sie
dort einstellen, welche Ihrer eingetragenen Profildaten für Besucher des
Blogs angezeigt werden sollen. Alle anderen Daten sind nur für
eingeloggte Redakteure über die Benutzerprofilauswahl im Backend zu
sehen. So können Sie bestimmte Daten, wie Ihre Telefonnummer, nur den
Redakteuren zugänglich machen. Auch werden im Frontend nur dann wirklich
aktivierte Datensätze angezeigt, wenn Sie sie auch ausgefüllt haben. Wenn
Sie also keine Hobbies eingetragen haben, wird das leere Feld einfach
übersprungen. Standardmäßig sind alle Profilfelder deaktiviert, damit ein
Redakteur nur auf seinen ausdrücklichen Wunsch seine Informationen
veröffentlichen kann.

\index{vCard}%
Bearbeiten Sie einen Datensatz, erscheint neben dem Ausklappfeld der
Benutzerprofile ein weiterer Button \menu{VCard-Datei erstellen}. Wenn
Sie darauf klicken, wird eine VCard-Datei in der Mediendatenbank erstellt
(\cmd{uploads/""\cmdvar{Benutzername}.vcf}). Diese Datei können Sie dann
 herunterladen
(\cmd{http:""//www.""example.com/serendipity/uploads/\cmdvar{Benutzername}.vcf})
bzw.\osplinebreak{} später in Blog-Einträgen einbinden. Eine VCard-Datei ist ein
standardisiertes Format für eine Visitenkarte und enthält die
Profildaten des Redakteurs. VCards können zum Beispiel in E-Mail-Programme
eingebunden werden.

Abgesehen von den Benutzerprofilen bietet das Plugin auch noch weitere
Funktionalität an. Zum einen ist dies, dass für jeden Redakteur ein
eigenes Bild für dessen Einträge eingebunden werden kann. Ein Besucher
muss so nicht erst nach einem Autorennamen suchen, sondern kann anhand des
Bildes leichter unterschiedliche Redakteure zuordnen.

Das jeweilige Bild muss dazu zuerst in der
Konfiguration des Plugins mit der Option \menu{Bild des Autoren im
Eintrag zeigen} aktiviert werden. Die Bilder, die das Plugin einbindet,
müssen sich in einem Unterverzeichnis \cmd{img} Ihres jeweiligen
Template-Verzeichnisses befinden. Der Dateiname richtet sich nach dem
vollständigen Namen des Redakteurs sowie der im Plugin konfigurierten
\menu{Dateiendung} (standardmäßig jpg). Damit der Redakteursname in einen
gültigen Dateinamen umgewandelt werden kann, müssen Sie für den
Dateinamen alle Sonderzeichen, Umlaute und Leerzeichen mit einem
Unterstrich (\cmd{\_}) ersetzen. Für den Redakteur \emph{John Doe}
müssen Sie also eine Datei wie \cmd{templates/default/img/John\_Doe.jpg}
erstellen. Beachten Sie dabei die Groß- und Kleinschreibung des
Redakteursnamens!

\index{Gravatar}
Da diese Art der Bildereinbindung relativ komplex ist und ein Redakteur
ohne FTP-Zugriff zum Blog keine Bilder einstellen kann, bietet das Plugin
auch eine andere Möglichkeit für individuelle Redakteursbilder. Diese
können nämlich alternativ über den Webservice
\cmd{http://www.gravatar.com} eingebunden werden. Der Gravatar-Dienst
ermöglicht es Ihnen, eine beliebige Grafikdatei hochzuladen, die mit
einer E-Mail-Adresse verbunden wird. Die E-Mail-Adresse eines Redakteurs
wird bei der Darstellung seiner Artikel ausgewertet und somit das Bild
vom Gravatar-Server eingebunden. Das heißt, jeder Redakteur kann für
seine E-Mail-Adresse einen Gravatar registrieren, und dieser wird dann
ohne weiteres Zutun dargestellt. Damit dies klappt, muss in der
Plugin-Konfiguration die Option \menu{Gravatar-Bild bevorzugen} aktiviert
werden. Einige weitere Optionen regeln zudem, welche Standard-Bilddatei
bei Redakteuren angezeigt wird, die keinen Gravatar besitzen, und welche
Größe die Bilder haben sollen. 

Für weitere Möglichkeiten der Gravatar-Unterstützung bietet sich das Plugin
\menu{Avatar Plugin} an, das über Spartacus erhältlich ist. Dies bindet
Gravatare auch für Besucher des Blogs ein.

Die Option \menu{Anzahl der Kommentare zeigen} des Plugins stellt eine
besondere Möglichkeit dar, mit der bei jedem Kommentar eines Benutzers
angezeigt wird, wie viele Kommentare dieser insgesamt bereits im Blog
hinterlassen hat. Diese Option ist besonders dann interessant, wenn Sie
ein geschlossenes Blog führen, in dem Kommentare nur für registrierte
Benutzer möglich sind. Solche Benutzer besitzen meist keine
Redakteursrechte, sondern kommentieren lediglich Artikel. Mit der
Aktivierung der genannten Option kann man als Besucher des Blogs so
leicht nachverfolgen, welche Benutzer oft kommentieren. In dem
Auswahlfeld dieser Option haben Sie die Wahl zwischen mehreren
Optionen.

\begin{ospdescription}
\ospitem{\menu{keine}}
Diese Option deaktiviert die Einbindung von Kommentarzählern.

\ospitem{\menu{An Kommentartext anhängen}}
Bei dieser Option wird die Anzahl der Kommentare in Klammern hinter dem
jeweiligen Kommentar angezeigt. Wenn ein Benutzer also den Kommentar
"`\emph{Das war sehr interessant!}"' schreibt, dann wird dahinter
"`\emph{Kommentare (42)}"' eingefügt. Der Kommentartext wird innerhalb
eines HTML-Containers mit der Klasse \cmd{.serendipity\_com\-ment\-count}
eingebunden, den Sie in der CSS-Datei Ihres Templates beliebig
formatieren können. Standardmäßig ist dieser Kommentarblock rechtsbündig
gesetzt.

\ospitem{\menu{Vor Kommentartext setzen}}
Diese Option ist identisch zur vorangehenden, setzt den Kommentar\-zäh\-ler
aber an den Anfang.

\ospitem{\menu{Eigenes Smarty Template}}
Statt den Kommentartext zu modifizieren, können Sie die Anzahl der
Kommentare auch an einer speziellen Position innerhalb der
Kommentardarstellung einbinden. Kommentare werden mit der
Smarty-Template-Datei \cmd{comments.tpl} dargestellt, dort können Sie die
Variable
\index{Template-Variablen!\$comment.plugin\_commentcount}%
\cmd{\$comment.plugin\_commentcount} an beliebiger Stelle setzen.

\end{ospdescription}

Das \emph{Benutzerprofile}-Plugin ermöglicht es Besuchern des Blogs, eine
Übersicht aller Benutzergruppen des Blogs einzusehen. Gerade bei
Gruppenblogs ist die Aufteilung in Benutzergruppen von großem Interesse,
wie man es auch von Foren her kennt.
Über 
\cmd{http://www.example.com/serendi\-pity/index.php?serendipity[subpage]=userprofiles}
kann der Besucher diese Liste einsehen. Er kann über ein Auswahlfeld die
jeweilige Benutzergruppe aussuchen und mit einem Klick auf \menu{Los}
alle Mitglieder der Gruppe anzeigen lassen. Standardmäßig werden der
Benutzername, die Anzahl der Artikel des Redakteurs, der echte Name des
Redakteurs und seine E-Mail-Adresse angezeigt.

Zusätzlich bietet das Benutzerprofile-Plugin zwei kleine
Seitenleisten"=Plugins an. Zum einen das gleichnamige Plugin
\emph{Benutzerprofile}, welches eine Liste aller verfügbaren Benutzer und
Benutzergruppen anzeigen kann, und zum anderen das Plugin namens
\emph{Geburtstage von Redakteuren}, mit dem Sie die zukünftigen
Geburtstage darstellen können.

Das Layout und die dargestellten Datensätze der Benutzerliste können Sie
über die Smarty-Template-Datei
\index{Template-Dateien!plugin\_groupmembers.tpl}%
\cmd{plugin\_groupmembers.tpl} anpassen. Es gibt dort folgende Variablen, 
die für Smarty-Kenner wichtig sind:

\begin{ospdescription}
\index{Template-Variablen!\$userprofile\_groups}%
\ospitem{\cmd{\$userprofile\_groups}: Array(\cmd{id, name})}
Enthält eine Liste aller verfügbaren Gruppen.

\cmd{\$userprofile\_groups.X.id} enthält die ID einer jeweiligen Gruppe,
\cmd{\$userprofile\_groups.X.name} den Namen.

\index{Template-Variablen!\$selected\_group}%
\ospitem{\cmd{\$selected\_group}: Int}
Enthält die ID der vom Besucher ausgewählten Gruppe. Falls nicht gesetzt,
ist noch keine Gruppe gewählt.

\index{Template-Variablen!\$selected\_group\_data}%
\ospitem{\cmd{\$selected\_group\_data}: Array (\cmd{id, name})}
Enthält die ID und den Namen der vom Besucher ausgewählten Gruppe.

\index{Template-Variablen!\$selected\_members}%
\ospitem{\cmd{\$selected\_members}: Array (\cmd{realname, username, authorid,}%
%)
}%
\ospadditem{\cmd{email, userlevel, posts} ...)}
In diesem Array werden die Mitglieder der vom Besucher gewählten Gruppe
gespeichert. Als Schlüssel des Arrays sind alle Tabellenfelder der
\cmd{serendipity\_authors}-Tabelle verfügbar sowie zusätzlich der
Schlüssel \cmd{\$selected\_membmers.X.posts} für die Anzahl der vom
Redakteur geschriebenen Artikel.

\end{ospdescription}

Die Darstellung der jeweiligen Benutzerprofile wird über die Template"=Datei
\index{Template-Dateien!plugin\_userprofile.tpl}%
\cmd{plugin\_userprofile.tpl} gesteuert. In dieser Datei sind die 
nötigen IF-Abfragen enthalten, die bestimmen, welche Datensätze angezeigt 
werden. Folgende Variablen sind verfügbar:

\begin{ospdescription}
\index{Template-Variablen!\$userProfile}%
\ospitem{\cmd{\$userProfile}: Array}
In diesem Array speichert das Plugin alle Angaben eines Benutzerprofils.
Für jede Profilangabe besteht ein Schlüssel, dessen Wert die Eingabe des
Benutzers enthält: 

\begin{ospcode}
\$userProfile.(city, street, country, url, occupation, hobbies, 
yahoo, aim, jabber, icq, msn, skype, birthday)
\end{ospcode}

\index{Template-Variablen!\$userProfileProperties}%
\ospitem{\cmd{\$userProfileProperties}: Array}
Dieses Array enthält eine Liste aller möglichen Konfigurationsoptionen
eines Datensatzes: 

\begin{ospcode}
\$userProfileProperties.(show\_city,
show\_street, show\_country, show\_url, show\_occupation, show\_hobbies,
show\_yahoo, show\_aim, show\_jabber, show\_icq, show\_msn, show\_skype,
show\_birthday, city, street, country, url, occupation, hobbies,
yahoo, aim, jabber, icq, msn, skype, birthday) 
\end{ospcode}

Zu jedem Schlüssel gibt es 
ein weiteres Array, in dem der Typ der Eigenschaft und dessen
Beschreibung enthalten ist. \cmd{\$userProfile\-Properties.show\_city.type}
enthält "`boolean"', 
\cmd{\$userProfile\-\osplinebreak{}Properties.show\_city.desc} enthält "`Stadt anzeigen"'.

\index{Template-Variablen!\$userProfileLocalProperties}%
\ospitem{\cmd{\$userProfileLocalProperties}: Array}
Analog zum Array \cmd{\$userProfileProperties} enthält dieses Array alle
lokalen Benutzerdaten. Diese werden nicht im Benutzerprofil gespeichert,
sondern stammen aus der Datenbanktabelle \cmd{serendipity""\_authors} und
sind gleich benannt: 


\begin{ospcode}
\$userProfileLocalProperties.(realname, username, email)
\end{ospcode}

 Auch hier enthält der Array-Unterschlüssel \cmd{.desc}
die Beschreibung einer Konfigurationsoption und \cmd{.type} den Typen.

\index{Template-Variablen!\$userProfileTitle}%
\ospitem{\cmd{\$userProfileTitle}: String}
Diese Variable enthält den Namen des Benutzerprofil-Plugins.
\end{ospdescription}

Die Standardausgabe des Plugins lässt sich weiterhin über die CSS-Klasse
\cmd{.serendipityAuthorProfile} optisch anpassen.

Wenn Sie mehr als die festgelegten Profilfelder anzeigen wollen,
können Sie das Plugin relativ leicht anpassen. Dazu müssen Sie 
\cmd{plugins/serendipity""\_event\_userprofiles/serendipity\_event\_userprofiles.php}
editieren und die Variablen \cmd{\$properties} und
\cmd{\$option\_properties} ergänzen. Sie können dazu das bestehende
Format mittels Kopieren \& Einfügen übernehmen und lediglich die
Benennung der Felder anpassen. Die neuen Variablen können daraufhin
automatisch in der Profilverwaltung eingetragen werden; damit diese
angezeigt werden können, müssen Sie noch die jeweiligen Variablen in der
Template-Datei \cmd{plugin\_userprofile.tpl} ergänzen.

Wenn Sie beispielsweise eine neue Profiloption namens "`Lieblingsfarbe"'
einbauen möchten, fügen Sie Folgendes dem Array \cmd{\$properties} in der
PHP-Datei des Plugins am Ende hinzu:

\begin{ospcode}
, 'farbe' => array('desc' => 'Lieblingsfarbe',
                 'type' => 'string')
\end{ospcode}

Wenn Sie die Farbe als letztes Element einfügen (hinter 
\cmd{'birthday'}), müssen Sie darauf achten, dass hinter der Klammer nach
\cmd{'date')} ein neues Komma eingefügt werden muss, damit PHP weiß,
dass dies nicht das letzte Element einer Liste war. Daher ist in obigem
Code-Beispiel das notwendige Komma enthalten. Wenn Sie die Liste
fehlerhaft (ohne Komma oder mit doppelten Kommas) eintragen, wird das
Plugin nicht mehr funktionieren. Sie müssen den Fehler dann erst
aufspüren und korrigieren.

Nun können Sie bereits das neue Profilfeld \cmd{farbe} ausfüllen, aber
noch nicht bestimmen, ob es angezeigt werden soll. Dazu müssen Sie noch
das Array \cmd{\$option\_properties} anpassen und genauso wie vorher
eine neue Zeile einfügen:

\begin{ospcode}
, 'show\_farbe' => array('desc' => 'Lieblingsfarbe anzeigen',
                         'type' => 'boolean')
\end{ospcode}

Der Redakteur kann jetzt auch bestimmen, dass seine Lieblingsfarbe
angezeigt wird. Damit sie auch erscheint, fehlt nur noch eine neue
Zeile in der \cmd{plugin\_userprofile.tpl}-Datei, die Sie ebenfalls
hinter der bereits bestehenden Ausgabe an IF-Abfragen einsetzen:

\begin{ospcode}
\{if \$userProfile.farbe and \$userProfile.show_farbe == "true"\}
    <dt>\{\$userProfileProperties.farbe.desc\}</dt>
    <dd>\{\$userProfile.farbe\}</dd>
\{/if\}
\end{ospcode}

Dieser Codeschnipsel prüft, ob ein Redakteur die Lieblingsfarbe
ausgefüllt hat und ob er diese auch darstellen möchte. Im folgenden HTML-Tag
\cmd{<dt>} wird dann die oben eingetragene Beschreibung namens
\cmd{Lieblingsfarbe} eingefügt, und im HTML-Tag \cmd{<dd>} erscheint die
Lieblingsfarbe des Redakteurs.

\subsubsection{Datenbanktabellen}

\index{Datenbank-Tabellen!serendipity\_profiles}%
Das Plugin erstellt die Datenbanktabelle \cmd{serendipity\_profiles}, in der die
jeweiligen Profileigenschaften zu jedem Autor gespeichert werden.

Jeder Datenbankeintrag steht dabei für eine Profileigenschaft, so dass beliebig
viele und verschiedene Eigenschaften für einen Autor vergeben werden können.
Das Feld \cmd{authorid} enthält dabei die ID des Redakteurs, \cmd{property}
enthält den Namen der Profileigenschaft und \cmd{value} den jeweils zugeordneten
Wert.


%revised
\index{Plugins!Seitenleisten!ein-/ausklappbar machen}%
\index{Plugins!Sidebarhider}%
\index{Plugins!serendipity\_event\_sidebarhider}%
\index{Seitenleisten!verstecken}%
\index{Seitenleisten-Plugins!verändern}%
\subsection{Seitenleisten ein-/ausklappbar machen\newline
serendipity\_event\_sidebarhider}

\label{sidebarhider}%
\index{Seitenleisten}%
\index{Verstecken!Seitenleisten-Plugins}%
Als \emph{Seitenleiste} gelten in Serendipity die Bereiche des Frontends,
in denen Ihre Seitenleisten-Plugins dargestellt werden. Meist sind sie
links und/oder rechts neben den Artikeln eingebunden.

Mit dem Plugin \emph{Seitenleisten ein-/ausklappbar machen} können Sie
zwei Dinge für jedes Element der Seitenleiste anpassen. Zum einen können
Sie Inhalte der jeweiligen Seitenleisten-Plugin-Container ausblenden, so
dass sie der Benutzer durch einen Klick auf einen Button wieder
einblenden kann. Dadurch sparen Sie einiges an Bildschirmplatz, jedoch müssen
die Besucher dann gezielt Seitenleisten-Container ausklappen, um deren Inhalt
zu sehen. 

Zum anderen können Sie bestimmte Elemente in gewissen Fällen vollständig
ausblenden.

Sobald das Plugin installiert wurde, bietet es einen neuen Menüpunkt im
Backend-Bereich \menu{Einträge\sm Seitenleisten verwalten} an. Zugleich ändert
es etwas in der Darstellungsart der Seitenleisten in Ihrem Frontend --
dort ist für jedes Seitenleisten-Plugin ein kleiner Link \menu{-} bzw.
\menu{+} hinzugekommen. Dank eines JavaScripts kann ein Besucher
nun auf diesen Link klicken, und das entsprechende Plugin wird ein- bzw.
ausgeblendet, um weniger Platz zu belegen. Beachten Sie, dass diese
Icons/Links nur dann verfügbar sind, wenn Ihr gewähltes Template die
CSS-Klassen des Standard-Templates benutzt. Ohne diese übereinstimmende
Benennung kann das JavaScript nicht aktiv werden (Details siehe Seite
\pageref{sidebar-css}).

Über das neue Menü \menu{Einträge\sm Seitenleisten verwalten} im Backend
können Sie nun detailliert einstellen, wie die Seitenleisten-Plugins
versteckt werden sollen. Wenn Sie diesen Bereich betreten, sehen Sie eine
Oberfläche, die an die \menu{Pluginverwaltung} angelehnt ist. Für jede
Seitenleiste des Templates werden die dort eingerichteten
Seitenleisten-Plugins in der eingestellten Reihenfolge angezeigt.

Standardmäßig sind alle Seitenleistenelemente ausgeklappt, das heißt,
der Besucher muss sie von sich aus verstecken. Mithilfe der Oberfläche
können Sie jedoch auch auswählen, welche Seitenleisten-Plugins
standardmäßig versteckt sein sollen, indem Sie für jedes gewünschte
Plugin die Auswahlbox \menu{Versteckt} aktivieren.

Unterhalb dieser Auswahlbox befinden sich weitere Einstellungsmöglichkeiten
für die Sichtbarkeit des jeweiligen Seitenleistenelements. So können Sie auch
festlegen, ob ein Plugin nur für spezielle Benutzer angezeigt werden soll. Wenn Sie
die Option \menu{Jeder Besucher} auswählen, kann jeder Besucher das
jeweilige Element sehen. Bei Aktivierung der Option \menu{Nur Mitglieder}
wird das Seitenleisten-Plugin nur Redakteuren angezeigt, die sich vorher
im Backend eingeloggt haben. Die Option \menu{Nur ich} legt fest, dass
ein Seitenleisten-Plugin nur für den Redakteur angezeigt wird, der gerade
im Backend die Änderungen vornimmt (also Sie selbst). Jeder Redakteur, der
Rechte zum Erstellen von Einträgen hat, darf standardmäßig die Elemente der
Seitenleisten verwalten. Wollen Sie dies nur einigen Redakteuren
genehmigen, müssen Sie in der Gruppenverwaltung das Plugin über
den Event-Hook
\cmd{backend\_sidebar\_entries\_event\_display\_sidebarhider} für andere
Benutzergruppen als die gewünschten verbieten (siehe Seite
\pageref{verboteneereignisse}).

Ein Seitenleisten-Element kann so konfiguriert werden, dass es nur
für Mitglieder einer gewählten Benutzergruppe dargestellt wird. In der
Mehrfach-Auswahlbox zum Konfigurationspunkt \menu{Gruppe} müssen Sie
daher alle Benutzergruppen wählen, für die ein Seitenleisten-Plugin
angezeigt werden soll. Wählen Sie keine Gruppe aus, wird ein Plugin
für alle Benutzergruppen angezeigt. Sobald Sie hier eine Gruppe
auswählen, entspricht dies automatisch der Einstellung \menu{Nur
Mitglieder}, da nicht eingeloggte Benutzer keiner Gruppe angehören und
somit ein Plugins niemals sehen.

Abgesehen vom Verstecken eines Plugins in Abhängigkeit vom Status eines
Besuchers können Sie ein Seitenleisten-Plugin auch dann verstecken, wenn
ein Besucher eine spezielle Kategorie des Blogs ansieht. Auch hier gilt
wieder, dass Sie bei der Benutzung der \menu{Nur Kategorien}-Option alle
Kategorien auswählen müssen, bei denen ein Seitenleistenelement angezeigt
werden soll. Die Sonderoption \menu{Alle Kategorien} ist standardmäßig
vorausgewählt, so dass ein Seitenleisten-Plugin immer angezeigt wird.  \menu{<Front Page>} bezieht sich auf die Standard-Artikelübersicht
von Serendipity, in der ein Besucher noch keine besondere Einschränkung
zu einer gewählten Kategorie getroffen hat.

Sobald ein Plugin über die Optionen \menu{Nur Mitglieder/Nur
ich/Gruppe/Nur Kategorien} ausgeblendet wird, kann ein Besucher im
Frontend das Plugin (abhängig von seinem Status) nicht mehr sehen. Es
wird also nicht einfach nur standardmäßig eingeklappt, sondern es wird
vollständig aus der Ausgabe entfernt.

Diese Möglichkeit können Sie gezielt benutzen, um gewisse
HTML-Klötze oder andere Seitenleistenelemente kategoriebezogen
anzuzeigen oder bestimmte Informationen nur Redakteuren zugänglich zu
machen.

Nachdem Sie Änderungen an der Sichtbarkeit der Plugins vorgenommen haben,
müssen Sie diese über den Button \menu{Änderungen am Layout speichern}
aktivieren. Wenn Sie später einmal die Reihenfolge der Plugins über die
übliche Plugin-Verwaltung ändern, müssen Sie das Layout der eingeklappten
Seitenleisten-Plugins erneut anpassen. Die Seitenleistenelemente werden anhand
ihrer Positionsindizes versteckt. Wenn Sie die Position des ersten und
zweiten Plugins vertauschen, würde nach wie vor das erste Seitenleistenelement
versteckt werden, anstelle des eigentlich logischen zweiten Plugins. Nur
durch eine entsprechende Einstellung über die Layout-Verwaltung des
\emph{Seitenleisten-verstecken}-Plugins kann dies korrigiert werden.

Die Funktionalität des Ein- und Ausklappens eines Seitenleisten-Plugins
kann über die globale Konfiguration des Plugins beinflusst werden. Wenn
Sie diese JavaScript-Funktionalität nicht benötigen, sondern nur das
Anzeigen/Verstecken von Seitenleisten-Plugins nutzen möchten, können Sie
dies gezielt über die Option \menu{Seitenleisten ein-/ausklappbar machen}
einstellen.

\index{Template-Dateien!sidebar.tpl}%
Die weiteren Konfigurationsoptionen können Sie benutzen, um die Gestaltung
des Ein- und Ausklappens an Ihr Template anzupassen. Damit dies überhaupt
klappen kann, muss die Smarty-Template-Datei \cmd{sidebar.tpl} Ihres Templates
von dem Standard-Template abgeleitet sein. Das JavaScript benötigt einen
HTML-Container mit der CSS-Klasse \cmd{.serendipitySide\-Bar\-Item}, in dem
die jeweiligen Seitenleistenelemente eingebunden sein müssen. Jedes
Seitenleistenelement muss den Titel des Plugins in einem HTML-Container
mit der CSS-Klasse \cmd{.serendipitySideBarTitle} einbinden, und den
Inhalt mit der CSS-Klasse \cmd{.serendipitySideBarContent}. Schauen Sie
sich die Datei \cmd{templates/default/sidebar.tpl} für ein Beispiel
dieser Gestaltung an. Das JavaScript kann ebenfalls standardmäßig nur mit einer
linken und einer rechten Seitenleiste umgehen, die jeweils in einem
HTML-Container mit der ID \cmd{\#serendipityLeftSideBar} und
\cmd{\#serendi\-pi\-tyRightSideBar} eingebunden sind. Wenn Ihr Template
andere Seitenleisten einbindet, müssen Sie gegebenenfalls die Datei
\cmd{sidebar\-hider.js} des Plugins anpassen und die Funktion
\cmd{sideBarHideRun()} mit Ihren eigenen Seitenleisten-Containernamen
erweitern.

Sobald durch das JavaScript ein Seitenleisten-Element versteckt wird,
weist es einen speziellen CSS-Stil zu, den Sie über die
Konfigurationsoptionen des Plugins manuell beeinflussen können.

Anstelle der HTML-Links \menu{+} und \menu{-} können Sie auch beliebigen
anderen HTML-Code einbinden, zum Beispiel eine Grafik oder einen
ausführlichen Text wie \cmd{Verstecken} und \cmd{Anzeigen}.

Sollten Ihnen die Optionen dieses Plugins nicht ausreichen, um ein
Seitenleisten"=Plugin abhängig vom umgebenden Inhalt zu verstecken, müssen Sie dies
manuell mittels Smarty-Syntax in der \cmd{sidebar.tpl} lösen. Dort können Sie
auch beispielsweise Abfragen einfügen, so dass bestimmte Seitenleistenelemente für
statische Seiten nicht angezeigt werden. Generelle Informationen zu diesen
Anpassungsmöglichkeiten finden Sie ab Seite \pageref{Smarty-Templates}.

\index{Plugins!Externe PHP-Anwendung}%
\index{Plugins!serendipity\_event\_externalphp}%
\subsection{Externe PHP-Anwendung\newline serendipity\_event\_externalphp}

\index{Fremde PHP-Anwendungen einbinden}%
\index{Code-Include}%
\index{Include}%
Oft werden Sie sich wünschen, Ihr Blog mit anderen, externen
PHP"=Anwendungen zu erweitern. Serendipity kann nicht alles, und gerade
bei der Einbindung von Bildergalerien möchten viele Blog-Betreiber gerne
ihr liebgewonnenes XYZ-Script einsetzen.

Serendipity versteht sich als ein Framework, das sowohl die Einbindung in
andere Systeme erleichtern, als auch andere Systeme einbinden können
soll. Viele Möglichkeiten der Einbindung eröffnen sich durch die
geschickte Anwendung von Smarty-Templating (siehe Seite
\pageref{Smarty-Templates}) oder von eigenen Ereignis-Plugins (siehe Seite
\pageref{pluginapi}).

Wem dies zu komplex ist, der kann mit dem kleinen Plugin
\emph{Externe PHP-Anwendung} ein PHP-Script
\emph{includen}\footnote{Der Fachterminus \emph{include} bezeichnet ein
PHP-Konstrukt, das eine Datei mit PHP-Anweisungen aus einem anderen
Script heraus einlesen und interpretieren kann.}. Das Plugin darf nur von
Administratoren konfiguriert werden, da die Einbindung fremder
PHP"=Anwendungen potenziell Sicherheitslücken öffnen kann, um beliebigen
Code von Serendipity auszuführen. Benutzen Sie es daher mit Vorsicht und
binden Sie nur vertrauenswürdige PHP-Anwendungen ein!

\osppagebreak

Das Ziel des Plugins ist, dass Sie bei dem Aufruf einer konfigurierbaren
URL die Inhalte eines fremden PHP-Scripts sehen können. Die Ausgabe
dieses Scripts wird im Inhaltsbereich angezeigt. PHP-Anwendungen wie
Counter-Scripte oder Dinge, die in der Seitenleiste angezeigt werden
sollen, sind daher für dieses Plugin nicht geeignet und müssen
stattdessen eher über die oben genannten Alternativen eingebunden werden.
Scripte wie eine Bildergalerie, eine Google-Maps-Unterseite oder alle
anderen Anwendungen mit eigener Ausgabe, die im Serendipity-Layout
erscheinen sollen, sind Anwendungsziel dieses Plugins.

Wenn Sie das Plugin installiert haben, können Sie in der Konfiguration
folgende Eigenschaften festlegen:

\begin{ospdescription}
\ospitem{\menu{Permalink}}
Globaler Permalink, um die Ausgabe des Plugins im Frontend sehen zu
können. Details siehe Seite
\pageref{Standardpluginkonfiguration-Permalink}.

\ospitem{\menu{URL-Titel der Seite}}
Globale Variable, die einen alternativen Permalink zur Ausgabe des
Plugins im Frontend bereitstellt. Details siehe Seite
\pageref{Standardpluginkonfiguration-Pagetitle}.

\ospitem{\menu{Einzubindende Datei}}
Dieses wichtige Feld darf nur von Administratoren ausgefüllt werden. Sie
müssen hier den vollständigen Dateipfad zu der externen PHP-Anwendung
eintragen, wie beispielsweise
\cmd{/var/www/example.com/""php\_gallery/include.php}. An dieser Stelle
dürfen Sie keine URL eintragen, da PHP-Includes aus Sicherheitsgründen
nur aus Dateien auf demselben Server ausgeführt werden sollten. Wenn Sie den
Inhalt einer fremden URL einbinden wollen, sollten Sie sich lieber das
Plugin \emph{WrapURL} (siehe Seite \pageref{wrapurl}) ansehen.

Es ist sehr wichtig, dass die fremde PHP-Anwendung sich an folgende
Richtlinien hält: Sie sollte keine HTML Header und Footer setzen (da dies
Serendipity bereits erledigt), sollte bestehende Datenbankverbindungen
nicht kappen, und wenn sie spezielle Namensräume verwendet, muss sie darauf
achten, die Variablen gegebenenfalls per \cmd{\$GLOBALS[...]} anzusprechen. Das
PHP-Include wird von Serendipity innerhalb einer Objektmethode
ausgeführt und verfügt daher nicht über den üblichen globalen
Namensraum.

\ospitem{\menu{Als Artikel formatieren}}
Gibt an, ob die Ausgaben des Plugins wie ein Blog-Eintrag dargestellt
werden sollen. Details siehe Seite
\pageref{Standardpluginkonfiguration-Articleformat}.

\end{ospdescription}

Sobald Sie das Plugin entsprechend konfiguriert haben, können Sie die
Ausgabe unter dem von Ihnen konfigurierten Permalink aufrufen und in
Ihrem Blog über einen Seitenleisten-HTML-Klotz oder Ähnliches
verlinken.

\index{Plugins!WrapURL}%
\index{Plugins!serendipity\_event\_wrapurl}%
\subsection{WrapURL\newline serendipity\_event\_wrapurl}
\label{wrapurl}%
\index{iframe}%
\index{Fremdinhalte einbinden}%
Ähnlich wie das vorausgehende Plugin kümmert sich das
\emph{WrapURL}-Plugin darum, einen fremden Inhalt in Ihrem Blog
einzubinden.

Dabei nutzt dieses Plugin einen kleinen Trick namens \emph{iframe}.
Iframes werden von Browsern so genutzt, dass die Inhalte einer
anderen Seite verschachtelt innerhalb einer Oberseite eingebunden werden.
Der technische Vorteil dabei ist, dass man beliebige fremde (und
auch eigene) Inhalte so auf einer Seite ohne \emph{Layoutnarben}
einbinden kann. Die Darstellung wirkt im Browser wie aus einem Guss,
obwohl in Wirklichkeit zwei unabhängige Seiten geladen werden.

Der Vorteil besteht darin, dass man zwei unabhängige
Anwendungen ohne viel technischen Aufwand miteinander verbinden kann. Die
fremde Anwendung kann also eigene Kopf-/Fußzeilen und HTML-Konstrukte
ausgeben und muss sich nicht um die Umgebung kümmern, in der die
Anwendung eingebettet ist.

Das einzige layout-technische Problem des Plugins ist, dass der
unsichtbare \emph{Frame} der fremden Anwendung eine Mindesthöhe in Pixeln
enthalten muss, da sich die Höhe des Frames in der Wirtsumgebung leider
nicht dynamisch an die Seitenhöhe der Anwendung anpassen kann.

Folgende Optionen können für das Plugin eingestellt werden:


\begin{ospdescription}
\ospitem{\menu{Headline}}
Oberhalb der eingebundenen Zielseite kann Serendipity eine Überschrift im
Layout des Blogs einbinden. Welche Überschrift benutzt wird, können Sie
im Feld \menu{Headline} einstellen.

\ospitem{\menu{Permalink}}
Globaler Permalink, um die Ausgabe des Plugins im Frontend sehen zu
können. Details siehe Seite
\pageref{Standardpluginkonfiguration-Permalink}.

\ospitem{\menu{URL shorthand name}}
Globale Variable, die einen alternativen Permalink zur Ausgabe des
Plugins im Frontend bereitstellt. Details siehe Seite
\pageref{Standardpluginkonfiguration-Pagetitle}.

\ospitem{\menu{The URL}}
Im Feld \menu{The URL} tragen Sie das Ziel des iframes ein. Diese URL
entspricht der externen Webseite, die Sie einbinden wollen, und muss
vollständig (also z.\,B. \cmd{http://www.example.com/googlemap.htm})\osplinebreak{} eingetragen
werden. Sie können auch vollständige URLs mit GET"=Parametern einbinden:
\cmd{http://www.example.com/users?id=15\&out""put=html}

\osppagebreak

\ospitem{\menu{Height in Pixels}}
Ein iframe benötigt eine Höhenangabe innerhalb der Einbindung einer
Webseite. Damit die fremde Webseite in Ihrem Blog-Layout möglichst
vollständig eingebunden werden kann, müssen Sie eine maximale Höhe in
Pixeln für den iframe eintragen. Der iframe wird dabei in eine Tabelle
eingebunden, in der die Höhe der Tabellenzelle der von Ihnen festgelegten
Pixelzahl entspricht. Der iframe selbst wird innerhalb dieser Zelle mit
100-prozentiger Höhe eingebunden, da man durch diese Technik die spätere
Höhe relativ genau festlegen kann.

\ospitem{\menu{Append GET-Variables}}
Wenn Sie eine fremde Webanwendung über einen iframe einbinden, müssen Sie
oft spezielle Parameter in der URL übergeben, beispielsweise für die
Einbindung einer Bildergalerie:
\cmd{http://www.example.""com/galerie/index.php?album=Albumname}. Diese
Variable müssten Sie jedoch eigentlich im Eingabefeld \menu{The URL}
festlegen und danach für jedes Album einer Galerie ein
eigenes WrapURL-Plugin installieren. Das wäre ein gewaltiger
Verwaltungsaufwand; besser wäre es, wenn Sie einfach die benötigte
Variable \cmd{album} an das Wrap-URL Plugin übergeben, und dies
leitet die Variable an den iframe weiter.

Dies erreichen Sie durch  Aktivierung von \menu{Append
GET-Variables}. In diesem Fall können Sie Ihren
WrapURL"=Permalink per
\cmd{http:""//www.""example.com/serendipity/wpages/""page\-title.html?album=Al\-bumname}
bzw.
\cmd{http://www.example.com/serendipity/index.php""?serendipity[subpage]=alternativurl\&album=Albumname}
auf\-rufen und so die Variable \cmd{album} an den iframe weiterreichen.

\ospitem{\menu{Hide sidebars}}
Standardmäßig wird der Inhalt eines iframes innerhalb Ihres gewöhnlichen
Blog-Templates eingebunden, daher bleiben auch die Seitenleisten"=Plugins
erhalten. Gerade dies macht Ihr Blog-Layout meistens aus, und so ist
es durchaus gewünscht, das vollständige Layout zu sehen.

Wenn Sie die Option \menu{Hide sidebars} aktivieren, können Sie die
Anzeige der Seitenleisten"=Plugins unterbinden.

\end{ospdescription}

\index{Plugins!Show links to services like Digg, Technorati, del.icio.us etc.}%
\index{Plugins!serendipity\_event\_findmore}% 
\subsection{Show links to services like Digg, Technorati, del.icio.us etc. related to your
entry\newline serendipity\_event\_findmore}
\label{findmore}%
\index{Social Web}%
\index{Digg}%
\index{Technorati}%
\index{del.icio.us}%
\index{Webservices}%
\index{Community}%
Ein ganz wesentlicher Faktor von Blogs ist deren Popularität und
Vernetzung untereinander. Durch die gegenseitige Verlinkung werden Blogs
erst allgemein bekannt, und dies ist letztlich ausschlaggebend für die
hohe Relevanz von Blog-Artikeln in Suchmaschinen wie Google.

\index{Blogosphäre}%
Durch die Entstehung zahlloser Blogs wurde es im Laufe der
Zeit immer schwieriger, einen Überblick über die Themen der \emph{Blogosphäre} zu
behalten. Welche Artikel werden gerade heiß diskutiert, welche Themen sind
in Blogs angesagt? Dieser Fragestellung nahmen sich mehrere Webservices
an, die Blogs durchsuchen und mittels Automatismen analysieren. Aber auch
durch Webservice-Communities wie \cmd{http://del.icio.us} wurde es
schnell populär, beliebte Links zentral zu verwalten. Ein Leser kann
nun einen interessanten Blog-Artikel als
öffentliches Lesezeichen speichern, auf das die Mitglieder der Community
Zugriff haben. Wenn diese Mitglieder einen Link auch informativ
finden, übernehmen sie ihn ebenfalls als eigenes Lesezeichen,
markieren oder bewerten ihn. So entsteht schnell eine qualitative und
quantitative Bewertung aktueller Blog-Artikel. Übersichtsseiten der
Social-Web-Communities stellen die populärsten Blog-Artikel übersichtlich
dar und erhöhen so den Andrang auf beliebte Blogs noch weiter.

Die Teilnahme an so einer Community ist vergleichsweise einfach: einen
Account erstellen, Browser-Plugins installieren oder über die jeweilige
Webseite selbst die Lesezeichen mit anderen Benutzern teilen. Weitaus
schwerer ist es, in der Community seine eigenen Blog-Artikel populär zu
machen.

Damit das gelingt, muss man mehrere Dinge tun. Das Allerwichtigste ist,
dass Sie für die Allgemeinheit oder ein Fachpublikum interessante
Blog-Artikel verfassen, die Ihren Besuchern einen Anreiz bieten, einen
Artikel überhaupt zu "`bewerten"' oder zu "`empfehlen"'. Sobald Sie
willige Besucher auf sich aufmerksam gemacht haben, müssen Sie diesen nun
eine Möglichkeit bieten, Ihren Blog-Artikel in der jeweiligen
Web-Community zu bewerten.

An dieser Stelle kommt das Plugin \emph{Show links to services like Digg
etc.} zum Tragen. Dieses bietet eine Einbindung fast aller verfügbaren
Link-Services, so dass Sie unterhalb jedes Blog-Artikels einen kleinen
Button des jeweiligen Services finden, der Ihre Besucher dorthin führt
und Ihre Seite in der Community verbreitet. Grundsätzlich benutzen die
meisten aktiven Besucher zwar ihre eigenen Browser-Tools zu diesem Zweck,
aber durch Ihre Einbindung zu diesen Services motivieren Sie einen
Besucher stärker, sich in der Community zu beteiligen.

Da es mittlerweile eine fast unüberschaubare Anzahl an Link-Communities
gibt, bietet das Plugin für jeden Dienst einen einzelnen Button an.
Folgende Services sind dabei standardmäßig enthalten: Del.icio.us, Digg,
Bloglines, Technorati, Fark, MyWeb2, Furl, Reddit, BLinklist, Spurl,
Newsvine, Simpy, Blogmarks, Wists, ma.gnolia, Mister Wong, addthis.

Es ist empfehlenswert, dass Sie in dieser großen Liste eine eigene
Einschränkung bzw. Gewichtung vornehmen, um so nur die Link-Communities
einzubinden, die für Ihre Zwecke Sinn machen. Bei deutschen Blogs sind
beispielsweise Mister Wong, Digg und Del.icio.us sehr populär.
Überwältigen Sie Ihre Besucher daher nicht unbedingt mit einer riesigen Liste von
Verlinkungsmöglichkeiten, sondern überzeugen Sie durch eine sinnvolle
Einschränkung. Schauen Sie sich ruhig jeden Link-Service an, damit Sie
entscheiden können, welche Ihnen am meisten zusagen.

Sobald Sie das Plugin installiert haben, finden Sie die erwähnte Leiste
an Link-Services unterhalb jedes Beitrags. Ein Klick auf einen Button
ruft dabei die jeweilige Community auf und fügt dort einen Link zu Ihrem
ursprünglichen Blog-Artikel mitsamt dem Titel des Beitrags hinzu.

Die eingebundenen Linkservices werden in einem HTML-Container mit der
CSS-Klasse \cmd{.serendipity\_findmore} ausgegeben. Der Inhalt der Leiste
richtet sich nach der Template-Datei
\index{Template-Dateien!plugin\_findmore.tpl}%
\cmd{plugin\_findmore.tpl}, die sich innerhalb des 
Plugin-Verzeichnisses \cmd{plugins/serendipity\_event\_find\-more/} befindet.

In dieser Template-Datei sind sämtliche Link-Services übersichtlich
untereinander aufgeführt. Jeder Linkservice lässt sich meist gleichartig
einbinden und unterscheidet sich nur in der Benennung von Variablen.
Diese Variablen werden mithilfe der Smarty-Platzhalter
\index{Template-Variablen!\$entrydata}%
\cmd{\{\$entrydata.*\}} später durch die Inhalte Ihres jeweiligen
Blog-Artikels ersetzt. Folgende Smarty-Variablen stehen zur Verfügung:

\begin{ospdescription}
\index{Template-Variablen!\$entrydata.url}% 
\ospitem{\cmd{\{\$entrydata.url\}}}
Enthält die vollständige URL des Blog-Artikels. Wenn eine URL an einen
Linkservice übermittelt wird, müssen etwaige Sonderzeichen in der URL
über einen Zusatz wie \cmd{\{\$entrydata.title|escape:url\}} eingebunden
werden (siehe Kapitel \ref{Smarty-Templates} ab Seite
\pageref{Smarty-Templates}).

\index{Template-Variablen!\$entrydata.title}% 
\ospitem{\cmd{\{\$entrydata.title\}}}
Enthält den Titel des Blog-Artikels. Diese Variable wird im Template
meist über den Befehl \cmd{\{\$entrydata.title|escape\}} eingebunden. Das
zusätzliche \cmd{|escape} sorgt dafür, dass Sonderzeichen im Artikeltitel
durch HTML-Sonderzeichen ersetzt werden. \cmd{|escape:url} sorgt im
Unterschied dazu dafür, dass Sonderzeichen durch URL"=Sonderzeichen ersetzt
werden.

\index{Template-Variablen!\$entrydata.path}% 
\ospitem{\cmd{\{\$entrydata.path\}}}
Enthält den HTTP-Pfad zu dem Bildverzeichnis des Plugins. Dort liegen für
fast alle Link-Communities die jeweiligen Logos, damit sie in der
Linkleiste grafisch eingebunden werden können.
\end{ospdescription}

Die Datei \cmd{plugin\_findmore.tpl} können Sie nach Belieben anpassen,
um beispielsweise überflüssige Services zu entfernen oder auch neue
hinzuzufügen. Eine geänderte Template-Datei sollten Sie dabei möglichst
in das Verzeichnis Ihres gewählten Templates kopieren, damit Sie bei
einem Update des Plugins Ihre Anpassungen nicht verlieren. 

Über die Konfiguration des Plugins können Sie komfortabel einstellen, welche
Links zu welchen Services Sie darstellen möchten, falls das Bearbeiten der
Template-Option für Sie zu umständlich ist.

Weiterhin bietet das Plugin folgende Konfigurationsoptionen:

\begin{ospdescription}
\ospitem{\menu{Relative path to Findmore images}}
In diesem Eingabefeld müssen Sie den vollen HTTP-Pfad eintragen, aus dem
das Plugin die Logo-Grafiken für den jeweiligen Linkservice über die
Template-Datei \cmd{plugin\_findmore.tpl} bezieht. Standardmäßig sollte
dieser Pfad bereits korrekt auf Ihr Plugin-Verzeichnis zeigen.

\ospitem{\menu{Display DiggCount badge}}
Der Link-Dienst \cmd{Digg} bietet ein kleines JavaScript an, mit dem Ihre
Besucher direkt sehen können, wie oft die Links in Ihrem Blog-Artikel von
Teilnehmern der Digg-Community positiv bewertet wurden. Diese kleine
Anzeige mit einer Zahl für den jeweils bewerteten Link nennt sich
\index{DiggCount badge}%
\emph{DiggCount badge}.

Das Plugin analysiert bei aktivierter Option \emph{DiggCount badge}
sämtliche Links zu Beiträgen auf \cmd{digg.com}, die Sie in Ihrem Artikel
platziert haben. Sollten Sie die \emph{Diggs} zu Ihrem eigenen Artikel
anzeigen wollen, müssen Sie manuell Ihren eigenen Blog-Artikel im
Artikeltext verlinken, damit das Plugin diesen in die Ausgabe einbeziehen
kann. Für jeden Link, der in Ihrem Blog-Artikel zu \cmd{digg.com} zeigt,
stellt das Plugin eine eigenständige Zählergrafik dar.

Wenn Sie die Option aktivieren, werden die Digg-Grafiken und das
JavaScript in einem eigenständigen HTML-Container mit der CSS-Klasse
\cmd{.serendipity\_diggcount} angezeigt.

\ospitem{\menu{DiggCount placement}}
Wenn Sie  \emph{DiggCount badge} aktiviert haben, bestimmen Sie mit
der Option \menu{DiggCount placement}, wo dieser Zähler angezeigt werden
soll. \menu{Before entry} bindet den Zähler direkt am Anfang Ihres
Blog-Artikels ein, \menu{After entry} am Ende des Artikels und \menu{After
findmore links} nach der Linkleiste des Plugins.
\end{ospdescription}

Template-Profis haben möglicherweise bereits bemerkt, dass die Linkleiste
der \cmd{plugin\_findmore.tpl}-Template-Datei recht simpel gestrickt ist
und lediglich die URL und den Titel eines Artikels enthalten muss. Diese
Informationen können Sie daher auch ganz einfach in die Template-Datei
\cmd{entries.tpl} einfügen und benötigen dieses Plugin höchstens noch
für die Einbindung der \emph{DiggCount badge}.

Der Vorteil der Einbindung in die \cmd{entries.tpl}-Datei besteht in
einer höheren Ausführungsgeschwindigkeit der Templates, da nicht noch
eine eigenständige Datei analysiert werden muss. Der Einfachkeit halber
können Sie den Inhalt der \cmd{plugin\_findmore.tpl}-Datei per Kopieren \& Einfügen 
in die \cmd{entries.tpl}-Datei übernehmen und den
HTML-Container \cmd{<div class="{}serendipity\_findmore"{}>} beliebig
innerhalb der Smarty-Foreach-Schleife platzieren, in der ein Eintrag
dargestellt wird. Sie müssen danach nur noch die Variable
\cmd{\$entrydata.url} mit \cmd{\$entry.rdf\_ident} ersetzen,
\cmd{\$entrydata.title} mit \cmd{\$entry.title} und anstelle von
\cmd{\$entry.""path} einen gültigen HTTP-Pfad zu den Linkservice-Bildern
einsetzen.

\index{Plugins!Suchmaschinen-Sitemap Generator}%
\index{Plugins!serendipity\_event\_google\_sitemap}%
\subsection{Suchmaschinen-Sitemap Generator\newline
serendipity\_event\_google\_sitemap}

\label{googlesitemap}%
\index{Sitemap}%
\index{Google Sitemap}%
\index{robots.txt}%
\index{Suchmaschinenindizierung}%
\index{SEO}%
Wenn Sie den Inhalt Ihres Blogs über eine Suchmaschine auffinden wollen,
muss die jeweilige Suchmaschine Ihr Blog \emph{indizieren}. Bei diesem
Vorgang ruft ein Suchroboter Ihr Blog auf, als wäre er ein normaler
Besucher. Dann analysiert er Ihre Webseite, sammelt sämtliche enthaltenen
Links und folgt diesen dann. Diesen Vorgang vergleicht man oft mit
\emph{crawling} oder \emph{spidering}, da ein Suchroboter mit diesem
Mechanismus wie ein Insekt über die vollständige Webseite \emph{kriecht}.

Dieser Vorgang kann mitunter sehr zeitaufwändig sein, da durch die
Baumstruktur einer Webseite möglicherweise besonders viele Seiten
aufgerufen werden müssen. Da der Suchroboter die Struktur einer Seite
nicht wie ein Mensch erfassen kann, muss er stur sämtliche verfügbaren
Unterseiten aufrufen und erkennt möglicherweise nicht, dass einige Seiten
denselben Inhalt besitzen.

Gerade bei Weblogs gibt es zahlreiche Möglichkeiten, Blog-Artikel
anzusehen: die globale Artikelübersicht, eine Übersicht pro Woche, pro
Monat, pro Jahr, pro Kategorie, pro Autor und viele weitere. So entstehen
für einige wenige Blog-Artikel bereits mehrere hundert Seitenaufrufe der
Suchroboter.

Dies ist nicht unbedingt ein grundlegender Nachteil: Da Blog-Artikel so
verschieden dargestellt werden, interpretiert eine Suchmaschine wie
Google dies oft als eigenständige Seite und gewichtet daher die
vorkommenden Wörter stärker, als wenn Sie nur eine einzelne
Artikelübersichtsseite besäßen.

Der Nachteil entsteht erst dann, wenn der Suchroboter sehr oft Ihre
Webseiten besucht und dadurch viel Traffic erzeugt -- oder wenn er
nicht oft genug die Seiten besucht und daher nicht der
Aktualität Ihrer Beiträge entsprechen kann.

Für diese Fälle wurde von den Suchmaschinenbetreibern ein eigener
Standard ins Leben gerufen. Dieser setzt am Prinzip einer \emph{Sitemap}
an. Eine Sitemap stellt sozusagen die Struktur Ihrer Webseite mit allen
Unterseiten dar, wie eine Verzeichnisübersicht Ihrer Festplatte im
vollständig ausgeklappten Zustand. Zusätzlich interpretieren Suchroboter
auch noch die Datei \cmd{robots.txt} im Stammverzeichnis Ihrer Webseite.
In dieser Datei können bereits Seiten von der Indizierung explizit
ausgeschlossen und einige andere Optionen eingestellt werden.
Weitere Informationen hierzu finden Sie auf
\cmd{http://de.selfhtml.org/diverses/robots.htm}.

Eine Sitemap-Datei muss dabei im XML-Format\footnote{Die vollständige
Spezifikation des Formates können Sie auf \cmd{http://www.""sitemaps.""org/}
nachschlagen.} abgespeichert werden und alle gültigen URLs enthalten.
Jede URL kann mehrere Eigenschaften enthalten: das Datum der letzten
Änderung, eine Aktualisierungspriorität (Gewichtung) und eine Angabe,
wie häufig sich das Dokument schätzungsweise ändert.

Damit Sie diese Sitemap-Datei nicht manuell erstellen müssen, wurde das
Plugin \emph{Suchmaschinen-Sitemap} entwickelt. Dieses erstellt die
notwendige XML-Datei anhand Ihrer Datenbank automatisch.

Sobald das Plugin installiert ist, wird es sich bei der Veröffentlichung jedes
neuen Artikels um die Aktualisierung der Sitemap-Datei kümmern. Dabei
setzt es automatisch die korrekten Werte für die letzte Änderung an einem
Artikel sowie die Gewichtung und Aktualisierungsfrequenz. Es enthält die
URLs für:

\begin{osplist}
\item Startseite des Blogs, Gewichtung 0.6

\item Archivübersicht des Blogs zzgl. Folgeseiten, Gewichtung 0.5

\item Artikel-Detailseiten sowie eventueller Alternativ-Permalinks,
Gewichtung 0.7--0.8

\item Kategorie-Übersichtsseiten, Gewichtung 0.4

\item Autor-Übersichtsseiten, Gewichtung 0.2

\item Archivübersicht nach Monat (Gewichtung 0.3), Monatsübersicht
(Gewichtung 0.1), Archivübersicht nach Monat pro Kategorie (Gewichtung
0.1)

\item RSS-Feed pro Kategorie, Gewichtung 0.0\footnote{RSS-Feeds sollen
nicht als Suchergebnisse bei den Suchmaschinen angezeigt, sondern
nur als zusätzliche Alternativdarstellung eingebunden werden. Daher
erhalten diese eine Gewichtung von 0.0.}


\item Globaler RSS-Feed, Gewichtung 0.0

\item etwaige statische Seiten, Gewichtung 0.7
\end{osplist}

Die XML-Datei \cmd{sitemap.xml} speichert das Plugin danach im
Stammverzeichnis des Blogs, wo es von den Suchmaschinen gefunden werden
kann. Damit die Datei erfolgreich geschrieben werden kann, müssen
entweder Schreibrechte zu dieser Datei bestehen, oder das
Stammverzeichnis muss für den PHP-Anwender beschreibbar sein
(Verzeichnisrechte 0777, siehe Kapitel \ref{Zugriffsrechte} ab Seite
\pageref{Zugriffsrechte}).

Das Sitemap-Format wird neben Google auch durch die Suchmaschinen-Roboter
von MSN, Yahoo und Ask unterstützt.

In den Konfigurationsoptionen des Plugins können Sie einige Einstellungen
vornehmen:

\begin{ospdescription}
\ospitem{\menu{Updates melden}}
Wenn Sie die Option \menu{Updates melden} aktivieren, kann das
Sitemap-Plugin eine Liste von Suchmaschinenbetreibern kontaktieren, um
diesen mitzuteilen, dass sich Ihre Sitemap geändert hat. Daraufhin kann
der jeweilige Suchroboter Ihre Seite neu indizieren.

Das Plugin kann nur dann Updates melden (\emph{pingen}), wenn Ihr Server
nicht durch eine Firewall blockiert wird und ausgehende HTTP-Verbindungen
zu anderen Webservern erlaubt.

\ospitem{\menu{URL-Liste für Pings}}
Wenn Sie die Option \menu{Updates melden} aktiviert haben, können Sie in
diesem Feld eine Liste der URLs von Suchmaschinenbetreibern eintragen, an
die das Plugin sich bei Aktualisierungen automatisch wenden soll.
Voreingestellt sind im Plugin die URLs von Google und Ask.

Welche URL Sie beim jeweiligen Suchmaschinenbetreiber benutzen können,
erfahren Sie auf dessen Webseite. Mehrere Betreiber-URLs können Sie mit
dem Semikolon \cmd{;} voneinander trennen.

\ospitem{\menu{Die sitemap.xml mit gzip packen}}
Da Ihre \cmd{sitemap.xml}-Datei bei vielen Blog-Einträgen recht groß
werden kann, ermöglicht das Sitemap-Plugin, diese Datei mit
ZIP"=Kompression zu speichern. Diese Kompression funktioniert nur, wenn
Ihre PHP-Version auf dem Webserver das ZIP-Modul eingebunden hat.
Ist diese Option aktiviert, wird die Sitemap-Datei als
\cmd{sitemap.xml.""gz} gespeichert.

Wenn Sie Probleme bei der Erstellung einer Sitemap haben, empfiehlt es
sich, diese Option zu deaktivieren. Dann können Sie mit einem beliebigen
Editor die Datei \cmd{sitemap.xml} öffnen, um nach etwaigen
Fehlermeldungen zu suchen.

\ospitem{\menu{URL-Typen}}
In dieser Liste können Sie festlegen, welche URLs in die Sitemap eingefügt
werden sollen: \menu{Feeds, Kategorien, Autoren, Permalinks, Archiv, Statische
Seiten, Tag-Seiten}. Standardmäßig sind alle URL-Typen ausgewählt.

Feeds werden jedoch nur mit einer Gewichtung von 0 in die Sitemap aufgenommen, da die
Inhalte eines RSS-Feeds derzeit nirgends als Suchergebnisse herangezogen werden
und nur als alternative Informationsquelle zu Aktualisierungen dienen.

\end{ospdescription}

Je nach Suchmaschinenbetreiber müssen Sie Ihr Blog möglicherweise erst
für die Benutzung von Sitemaps freischalten. Bei Google geschieht dies
etwa über die URL \cmd{http://www.google.com/webmasters/tools/}.

Einige Suchmaschinen werten zudem die Datei \cmd{robots.txt} aus und suchen
dort nach der Angabe Ihrer Sitemap. Dazu müssen Sie die Zeile
\cmd{Site\-map: http://www.example.com/serendipity/sitemap.xml} in 
\cmd{robots.""txt} aufnehmen.

\index{Plugins!Kategorie als Startseite}%
\index{Plugins!serendipity\_event\_startcat}%
\index{Startseiten}%
\index{Frontend!Startseite}%
\subsection{Kategorie als Startseite\newline serendipity\_event\_startcat}

Die Einstiegsseite des Frontends Ihres Blogs zeigt üblicherweise die
aktuellsten Artikel aller verfügbaren Kategorien an, sofern diese nicht
durch Leserechte zugriffsbeschränkt sind.

\index{CMS}%
Während dies bei üblich geführten Blogs genau das ist, was Ihre
Leser erwarten, kann es zu Verwirrungen kommen, wenn Sie Serendipity eher als
Content-Management-Software einsetzen.

In solchen Fällen ist es oft üblicher, auf der Startseite nur
Artikel einer bestimmten Kategorie anzuzeigen. Wenn Ihre Besucher andere
Artikel/Inhalte sehen wollen, müssen sie vorher aktiv die gewünschte
Kategorie auswählen.

Genau dieses Verhalten einer besonderen \emph{Startkategorie} können Sie
mit dem Plugin \emph{Kategorie als Startseite} erreichen. Das Plugin
macht letztlich etwas ganz Einfaches: Es beschränkt die Ansicht der
Startseite auf eine konfigurierte Kategorie. Dies entspricht dann
der Ansicht, die ein Besucher erhält, wenn er im Frontend die
konfigurierte Kategorie ausgewählt hätte.

Abseits von dieser Startkategorie bietet das Plugin jedoch auch noch
weitere Möglichkeiten, die Sie über seine Konfigurationsoptionen 
festlegen können:

\begin{ospdescription}
\ospitem{\menu{Ursprungskategorie}}
In diesem Auswahlfeld können Sie festlegen, welche Kategorie Ihres Blogs
für die Artikelübersicht herangezogen wird.

\ospitem{\menu{Versteckte Kategorie}}
Anstatt in der Artikelübersicht nur die Artikel einer gewissen Kategorie
anzuzeigen, können Sie die Logik auch umdrehen und gewisse Kategorien von
der Artikelübersicht \emph{ausschließen}. Darin enthaltene Artikel kann ein
Besucher erst dann lesen, wenn er explizit die Kategorie-Übersicht der
ausgeschlossenen Kategorie aufruft. Im Vergleich zum Fixieren einer
Kategorie hat dies den Vorteil, dass Serendipity nicht stets eine
Kategorie vorgibt.

\ospitem{\menu{Mehrere Ursprungskategorien}}
Anstatt nur eine einzelne Kategorie als Startkategorie festzulegen,
können Sie auch mehrere Kategorie-IDs mit einem \cmd{;} getrennt
voneinander eintragen. Die Kategorie-IDs können Sie der
Kategorieverwaltung (siehe Seite \pageref{Kategorie-ID ermitteln}) entnehmen.

\ospitem{\menu{Mehrere versteckte Kategorien}}
Analog zum Fixieren mehrerer Kategorien für die Startseite können Sie
auch mehr als eine Kategorie auf der Startseite ausblenden. Tragen Sie
auch hier die IDs mit einem \cmd{;} voneinander getrennt ein.

\ospitem{\menu{Gewählte Kategorie besucherseitig merken}}
Abgesehen vom Anzeigen/Verstecken von Kategorien bietet dieses Plugin
auch eine unabhängige Funktionalität, mit der ein Besucher die zuletzt
gewählte(n) Kategorie(n) dauerhaft speichern kann. Beim nächsten Besuch
des Blogs wird für ihn dann automatisch die zuletzt besuchte
Kategorieansicht wiederhergestellt.

Diese Funktionalität kann für Ihre Besucher möglicherweise verwirrend
sein. Wenn man ein Blog neu im Browser öffnet, erwartet man nicht
unbedingt, dass die zuletzt angesehene Kategorie reaktiviert ist, sondern
rechnet damit, dass man die Startseite des Blogs sieht, um neue Artikel
auch von anderen Kategorien lesen zu können. Stellen Sie also sicher,
dass dieses Feature im Kontext Ihres Blogs wirklich Sinn macht, und
weisen Sie Ihre Besucher möglichst gezielt mittels eines HTML-Klotzes
oder Ähnlichem auf das Feature hin.

\end{ospdescription}

Sobald das Plugin eine Einschränkung der Kategorie vornimmt, hat dies
auch Auswirkung auf den Standard-RSS-Feed. Dieser enthält dieselben
Artikel wie die Artikelübersicht, versteckt also gegebenenfalls auch
Artikel der nicht gewählten Kategorien. Um einen RSS-Feed aller gewählten
Kategorien anzuzeigen, müssen Sie diesen über
\cmd{http://www.example.com/se\-rendipity/rss.php?serendipity[category]=all}
aufrufen. Damit Ihre Besucher darüber auch Bescheid wissen, müssen Sie
gegebenenfalls gesondert darauf hinweisen (in einem HTML-Klotz oder durch
Anpassung des \emph{Blog abonnieren}-Plugins).

Die Wahl einer Standardkategorie hat auch Auswirkungen auf die
Anzeige des Kalender-Plugins in der Seitenleiste und auch möglicherweise
auf das Kategorien-Seitenleisten-Plugin. Abhängig von ihrer Konfiguration
beziehen beide Plugins die gewählte Kategorie mit ein und zeigen nicht
wie gewohnt die Daten aller Kategorien.

\index{Plugins!Eigenschaften/Templates von Kategorien}%
\index{Plugins!serendipity\_event\_categorytemplates}%
\index{Individuelle Templates pro Kategorie}%
\index{Multi-User-Blogs}%
\subsection{Eigenschaften/Templates von Kategorien\newline serendipity\_event\_categorytemplates}

Mithilfe des Plugins \emph{Eigenschaften/Templates von Kategorien} können
Sie jeder Kategorie des Blogs gewisse Eigenschaften und
Konfigurationsoptionen zuweisen sowie individuelle Templates auswählen.

Diese Eigenschaften werden aktiv, wenn ein Besucher im Frontend die
Artikelübersicht einer Kategorie aufruft. Auch wenn er die Detailansicht
eines Blog-Artikels öffnet, der einer einzelnen Kategorie zugewiesen ist,
werden die Eigenschaften aktiv. Wenn einem Artikel mehrere Kategorien
zugewiesen sind, von denen aber nur eine Kategorie besondere Eigenschaften
besitzt, wird diese automatisch für die Einzel-Detailansicht angewendet.

Am häufigsten wird das Plugin dazu eingesetzt, abhängig von der
gewählten Kategorie unterschiedliche Templates für das Blog einzusetzen.
So kann man mehrere Kategorien des Blogs grafisch klar voneinander
unterscheiden. Durch diese Trennung kann man auch thematische Unter-Blogs
einrichten, die für den Besucher voneinander unabhängig erscheinen, aber
allesamt dieselbe Datenbank besitzen. Gerade für den Blog-Betreiber ist
es weitaus komfortabler, mit einem einzigen Backend mehrere voneinander
getrennt erscheinende Frontends zu verwalten.

\index{Template-Optionen!pro Kategorie setzen}%
Falls ein gewünschtes Template den Einsatz von
Template-Optionen unterstützt (siehe Seite \pageref{templateoptionen}),
können diese Optionen für das Template individuell für jede Kategorie gesetzt
werden, in der das Template zum Einsatz kommt. Sie müssen daher das Template
nicht in mehrere Unterverzeichnisse kopieren, um ein eigenes Template pro
Kategorie zuzuweisen, sondern können die Template-Optionen direkt von der
Oberfläche aus mit den Eigenschaften einer Kategorie aufrufen.

Mit zusätzlicher Hilfe der individuellen Lese- und Schreibrechte zu
Kategorien kann man so sogar recht flexibel Mehr-Autoren-Blogs
einrichten, die allesamt mit derselben Verwaltungsoberfläche
administriert und bearbeitet werden können.

Das Plugin bietet folgende grundsätzliche Konfigurationsoptionen:

\begin{ospdescription}
\ospitem{\menu{Password protection}}
Über diese Option können Sie pro
Kategorie entscheiden, ob diese mit einem Passwort-Zugriffsschutz
versehen werden soll.

Wenn ein Besucher später die Übersichtsseite einer geschützten Kategorie
aufrufen will, muss er zuerst ein Passwort eintragen. Erst nachdem der
Besucher dies erledigt hat, sieht er die Einträge einer derart
geschützten Kategorie auch auf der globalen Übersichtsseite.

Die Aktivierung dieser Option verlangsamt die Datenbankabfragen für
Übersichtsseiten etwas, daher sollten Sie sie nur aktivieren, wenn Sie
passwortgeschützte Kategorien dringend benötigen.

\index{Sortierung!Reihenfolge@\textasciitilde{}sreihenfolge von Artikeln ändern}%
\label{categorytemplates-sort}%
\ospitem{\menu{Standard: Sortierung}}
Standardmäßig sortiert Serendipity die Artikelansichten stets
chronologisch. Die aktuellsten Artikel erscheinen zuerst, die ältesten
Artikel am Ende. Ein Besucher sieht so die aktuellsten Artikel immer
direkt auf den ersten Blick.

Bei einigen Blogs wünschen sich die Besitzer jedoch, dass ihr Blog in der
richtigen Reihenfolge, von den ältesten zu den neuesten Artikeln gelesen wird. Gerade
bei fiktiven Blogs, die eine Geschichte erzählen, macht dies Sinn.

Über das Eingabefeld \menu{Standard: Sortierung} können Sie die
Artikelsortierung festlegen, die für die generelle Artikelübersicht gilt.
Beachten Sie, dass Sie auch eine Einstellung der Sortierung pro Kategorie
vornehmen können, indem Sie die jeweiligen Eigenschaften einer Kategorie
(über den Menüpunkt \menu{Einträge\sm Kategorien}) bearbeiten.

In dem Eingabefeld müssen Sie eine SQL-Syntax eingeben. Als
Sortierungskriterium kann man sämtliche Datenbank-Spaltennamen der
Tabelle \cmd{serendipity\_entries} heranziehen. Die eigentliche
Reihenfolge gibt man über den Befehl \cmd{ASC} (ascending: aufsteigend)
oder \cmd{DESC} (descending: absteigend) an. In den meisten Fällen müssen
Sie daher an dieser Stelle nur \cmd{timestamp DESC} eingeben (für die
übliche Sortierungsreihenfolge mit aktuellsten Artikeln am Anfang) oder
alternativ \cmd{timestamp ASC} (älteste Artikel am Anfang). Weitere
sinnvolle Möglichkeiten wären eine Sortierung nach Titel (\cmd{title
DESC}) oder nach der Anzahl der Kommentare zu einem Artikel (\cmd{comments DESC}).
\end{ospdescription}

Abgesehen von diesen beiden zentralen Optionen bietet das Plugin seine
Kernfunktionalität im Menüpunkt \menu{Einträge\sm Kategorien} an.
Bearbeiten Sie dort eine Kategorie, und Sie werden zusätzliche Felder
dort sehen:

\begin{ospdescription}
\ospitem{\menu{Artikel von Unterkategorien verstecken}}
Standardmäßig zeigt Serendipity bei der Artikelübersicht einer gewählten
Kategorie im Frontend auch alle Einträge an, die in den möglichen
Unterkategorien der gewählten Kategorie vorhanden sind. Gesetzt den Fall,
Sie haben eine Hauptkategorie "`Fernsehen"' eingerichtet und darin
die Unterkategorien "`Drama"', "`Action"', "`Comedy"' und "`Lustspiele"'.
Wenn Sie im Frontend nun auf die Kategorie "`Fernsehen"' klicken, sehen
Sie auch alle Beiträge in den Unterkategorien. Erst wenn Sie auf die
letzte Unterkategorie wie "`Action"' klicken, sehen Sie keine Einträge
der anderen Kategorien mehr.

In den meisten Fällen ist diese Variante bei der Artikeldarstellung für
Besucher recht angenehm, und Sie müssen Artikel nicht zwangsläufig
mehreren Kategorien zuweisen.

Wenn Ihre Kategoriestruktur jedoch nicht hierarchisch aufgebaut ist,
könnte die Standardübersicht unpassend sein. Daher bietet das Plugin die
Möglichkeit (Option \menu{Artikel von Unterkategorien verstecken}), keine 
Artikel von Unterkategorien mehr anzuzeigen.

Die Einstellung sollte nur auf Kategorien angewendet werden, die
Unterkategorien besitzen. Bei fehlenden Unterkategorien hat diese
Einstellung natürlich keine Wirkung.

\ospitem{\menu{Wählen Sie das Template für das Blog}}
Bei dieser Option stehen zwei Eingabemöglichkeiten zur Verfügung.
Entweder Sie füllen das Eingabefeld aus und tragen dort einen
Template"=Namen ein, oder Sie wählen aus dem Ausklappfeld den
entsprechenden Template-Namen. Bei einer Auswahl im Ausklappfeld wird
Ihre Eingabe im Textfeld ignoriert.

In dem Ausklappfeld stehen Ihnen sämtliche Templates zur Verfügung, die
in Ihrem Blog im Unterverzeichnis \cmd{templates} eingerichtet wurden.

In das Eingabefeld tragen Sie nicht den Namen des Templates (wie
beispielsweise "`Serendipity 3.0"') ein, sondern den
Verzeichnisnamen (\cmd{carl\_contest}). Diese Eingabemöglichkeit
bietet die Flexibilität, dass Sie in einem Haupt-Template-Verzeichnis auch
Unterverzeichnisse mit eigenständigen Templates erstellen können, um so
Ihre Verzeichnisstruktur aufgeräumter zu strukturieren. In einem solchen
Fall können Sie auf Unterverzeichnisse mittels
\cmd{mein\_template/unter\_tem\-plate1} zugreifen. Tragen Sie nur
Verzeichnisnamen ab der Verzeichnisebene \cmd{templates} ein.

Das ausgewählte Template wird im Frontend anstelle des Standard-Templates
angezeigt, sobald der Besucher die Artikelübersicht (oder einen
detaillierten Artikel) der Kategorie aufruft. Mit dieser
Gestaltungsmöglichkeit können Sie Kategorien gezielt formatieren und
eine Art "`Themen-Blog"' einrichten, bei dem Ihre Besucher das Gefühl
haben, jeweils eigenständige Blogs aufzurufen. Für Sie hat dies den
Vorteil, dass Sie das komplette Blog weiterhin über eine einzelne
Administrationsoberfläche verwalten können.

Sollte das gewählte Template Ihnen zusätzliche Template-Optionen anbieten,
wird ein Button zum Festlegen dieser Optionen unterhalb der Template-Auswahl
eingebunden. Ein Klick darauf führt zu den Optionen des Templates, die Sie
von der normalen \menu{Styles verwalten}-Funktionalität her bereits kennen
(siehe Seite \pageref{Styles verwalten}).

Beachten Sie dabei, dass die so festgelegten Template-Optionen nur dann
gelten, wenn Sie die jeweilige zugehörige Kategorie aufrufen -- die
Template-Optionen für die Übersichtsseite legen Sie wie gewohnt getrennt davon fest.

Wenn Sie ein Template mit Template-Optionen einsetzen und diese für jede
Kategorie unterschiedlich konfigurieren möchten (beispielsweise über ein
individuelles Kopfbild für jede Kategorie), können Sie dies festlegen, ohne
für jede Kategorie ein eigenes Template anlegen/kopieren zu müssen.

\ospitem{\menu{Zukünftige Einträge zeigen}}
In der globalen Konfiguration von Serendipity können Sie einstellen, ob
Einträge mit einem zukünftigen Datum im Frontend bereits vor Erreichen
dieses Datums angezeigt werden sollen (siehe Seite \pageref{Zeitgesteuerte
Veroeffentlichung}).

Diese Einstellung können Sie auch pro Kategorie festlegen. Die Option
\cmd{Standard} entspricht dabei der Einstellung, die Sie global
vorgenommen haben. \cmd{Nein} legt fest, dass zukünftige Einträge nicht
gezeigt werden, bei \cmd{Ja} werden sie angezeigt.

Die Einstellungen pro Kategorie sind nur dann gültig, wenn Sie im
Frontend gezielt die Kategorie-Übersicht aufrufen.

\ospitem{\menu{Anzahl der Artikel für die Startseite der Kategorie}}
Standardmäßig richtet sich die Anzahl der dargestellten Artikel in einer
Kategorie nach der Einstellung in der globalen Serendipity"=Konfiguration.
Sie können jedoch auch fallweise pro Kategorie eine andere Artikelanzahl
einbinden. Wenn Ihre Artikel in bestimmten Kategorien länger sind als
gewöhnlich, könnten Sie die Anzahl der Artikel zur besseren Übersicht
daher gezielt reduzieren.

Tragen Sie in das vorgesehene Eingabefeld die gewünschte Anzahl ein.

\ospitem{\menu{Sortierung}}
In den Konfigurationsoptionen des Plugins können Sie bereits die globale
Sortierungsreihenfolge der Artikelübersichten einstellen. Pro Kategorie
können Sie auch eine individuelle Sortierungsreihenfolge vorgeben. Welche
Möglichkeiten Sie zur Eingabe nutzen können, wird bei den
Konfigurationseinstellungen dieses Plugins auf Seite
\pageref{categorytemplates-sort} beschrieben.

Die Konfigurationsoption \menu{Globally set entry's category} sorgt dafür,
dass beim Aufruf der Detailansicht eines Artikels, der einer
einzelnen Kategorie zugeordnet ist, diese Kategorie als \emph{aktuelle
Kategorie} für die gesamte Blog-Darstellung verwendet wird. Diese Option ist vor
allem dann hilfreich, wenn Sie Seitenleisten-Plugins so konfiguriert
haben, dass sie ihre Ausgabe von der aktuellen Kategorie abhängig machen sollen.
Da Detailseiten eines Artikels standardmäßig niemals eine Kategorie setzen, wären
in so einem Fall bei deaktivierter Option die Seitenleisten ebenfalls ohne
feste Kategorieabhängigkeit. Erst durch Aktivierung der Option sorgt das Plugin
dafür, die globale Kategorievariable (\cmd{\$serendipity['GET']['category']}) zu
füllen.

\end{ospdescription}

\subsubsection{Datenbanktabelle}

\index{Datenbank-Tabellen!serendipity\_categorytemplates}%
Das Plugin speichert die Zuordnungen individueller Templates pro Kategorie in
einer eigenen Datenbanktabelle \cmd{serendipity\_categorytemplates}:

\begin{ospdescription}
\ospitem{\cmd{categoryid}}enthält die Kategorie-ID, bei der ein eigenes Template
verwendet werden soll. 

\ospitem{\cmd{template}} enthält den Verzeichnisnamen des Templates, der für diese
Kategorie eingesetzt werden soll.
\ospitem{\cmd{fetchlimit}} gibt an, wie viele Einträge für Artikel dieser Kategorie
auf der Übersichtsseite angezeigt werden sollen.
\ospitem{\cmd{futureentries}} gibt an, ob bei Darstellung der jeweiligen Kategorie
Einträge gezeigt werden sollen, deren Datum in der Zukunft liegt.
\ospitem{\cmd{lang}} legt die Sprache für die Darstellung dieser Kategorie fest
(wird derzeit noch nicht ausgewertet).
\ospitem{\cmd{pass}} legt ein Passwort fest, um die Übersichtsseite dieser Kategorie
aufrufen zu können.
\ospitem{\cmd{sort\_order}} legt die Sortierungsreihenfolge der Artikel für die
Übersichtsseite der jeweiligen Kategorie fest.
\end{ospdescription}

\index{Plugins!Gaestebuch@Gästebuch}%
\index{Plugins!serendipity\_event\_guestbook}%
\index{Gaestebuch@Gästebuch}%
\subsection{Gästebuch\newline serendipity\_event\_guestbook}

Mit dem \emph{Gästebuch}-Plugin können Sie in Ihrem Blog einen Bereich
einbinden, in dem Besucher sich in ein Gästebuch eintragen können. Die
Kommentarfunktionen Serendipitys beziehen sich immer auf die jeweiligen
Artikel, daher sind generelle Kommentare Ihrer Besucher besser in einem
Gästebuch aufgehoben.

Es gibt zahlreiche PHP-Scripts zur Einbindung von Gästebüchern und auch
zahlreiche kostenlose Webangebote, bei denen Sie Gästebücher eröffnen
können. Das Gästebuch-Plugin ist möglichst simpel gehalten und
hauptsächlich für eine nahtlose Einbindung in Serendipity vorgesehen.

Das Gästebuch können Sie im Frontend über einen frei von Ihnen vergebenen
Permalink aufrufen. Diesen Link binden Sie am besten entweder in einen
HTML-Klotz in der Seitenleiste ein oder fügen ihn fest in eine
Navigation Ihres Templates ein (siehe Seite \pageref{templatefiles-index} und
\pageref{bpdesc}).

Ein Besucher sieht im Gästebuch die Einträge der vorherigen Gäste und kann
dort über ein Formular seinen eigenen Eintrag hinterlassen. Wenn Sie im
Blog eingeloggt sind, können Sie als Administrator zudem bestehende
Einträge im Gästebuch direkt löschen.

Für das Gästebuch-Plugin stehende folgende Konfigurationsoptionen zur
Verfügung:

\begin{ospdescription}
\ospitem{\menu{Permalink}}
Globaler Permalink, um die Ausgabe des Plugins im Frontend sehen zu
können. Details siehe Seite
\pageref{Standardpluginkonfiguration-Permalink}.

\ospitem{\menu{Seitentitel}}
Globale Variable, die einen alternativen Permalink zur Ausgabe des
Plugins im Frontend bereitstellt. Details siehe Seite
\pageref{Standardpluginkonfiguration-Pagetitle}.

\ospitem{\menu{Überschrift}}
Tragen Sie in diesem Feld die \menu{Überschrift} ein, die Sie später im
Gästebuch sehen möchten.

\ospitem{\menu{Einführungstext}}
Um Ihren Besuchern eine Einführung in Ihr Gästebuch zu geben und sie zu
einem Eintrag zu motivieren, können Sie in diesem Feld einen beliebigen
\menu{Einführungstext} eingeben. Dieser darf auch beliebiges HTML
enthalten und wird später oberhalb der Gästebucheinträge angezeigt.

\ospitem{\menu{Gästebuch-Formular}}
Mit dieser Option legen Sie fest, ob das Formular für neue Einträge
oberhalb oder unterhalb der vorhandenen Gästebucheinträge eingebunden
werden soll.

\ospitem{\menu{Einträge pro Seite}}
Tragen Sie im Feld \menu{Einträge pro Seite} eine Zahl ein, die festlegt,
wie viele Gästebucheinträge auf einer einzelnen Seite angezeigt werden
sollen. Weitere Einträge können dann durch eine Blätterfunktion
aufgerufen werden.

\ospitem{\menu{Anzahl der Zeichen pro Zeile}}
Da Gästebucheinträge möglicherweise auch überlange Wörter enthalten,
können Sie mit dieser Option festlegen, nach wie vielen Zeichen ein
automatischer Zeilenumbruch erfolgen soll.

\ospitem{\menu{Als Artikel formatieren}}
Wenn Sie diese Option aktivieren, werden etwaige Textformatierungs-Plugins
(Smilies, BBCode etc.) ausgeführt. Damit erscheint ein Gästebucheintrag
dann mit denselben Formatierungsmöglichkeiten wie ein normaler
Blog-Kommentar.

\ospitem{\menu{Send e-mail to admin}}
Wenn Sie bei jedem neuen Gästebucheintrag einen E-Mail-Hinweis erhalten
wollen, können Sie diese Option aktivieren.

\ospitem{\menu{E-Mail-Adresse des Admin}}
Bei aktivierter Option \menu{Send e-mail to admin} müssen Sie in dem
Eingabefeld hier die gewünschte E-Mail-Adresse eintragen.

\ospitem{\menu{E-Mail-Adresse des Users, Homepage des Users}}
Das Gästebuchformular kann von einem Besucher mehrere Eingabefelder
optional abfragen. Standardmäßig muss für einen Gästebucheintrag nur ein
Text und ein Name angegeben werden. Über die Aktivierung der Optionen
\menu{E-Mail-Adresse des Users} und \menu{Homepage des Users} können Sie
zusätzlich auch weitere Felder abfragen.

\ospitem{\menu{Captcha-Schutz aktivieren}}
Um Spam im Gästebuch zu verhindern, kann für das Gästebuch ebenfalls der
Captcha-Schutz (siehe Seite \pageref{spamblock}) aktiviert werden.

\ospitem{\menu{Datumsformat}}
Tragen Sie im Feld \menu{Datumsformat} ein, wie das Datum der
Gästebuch\-einträge formatiert werden soll. Zur Verfügung stehen die
Platzhalter, die in der
PHP-Dokumentation\footnote{\cmd{http://de.php.net/strftime}} beschrieben
werden.

\ospitem{\menu{Gästebuch-Hilfe}}
Am Ende der Konfigurationsoptionen befindet sich ein kleiner
Informationstext mit einem Link zu der README-Datei des Plugins. In
dieser Datei ist eine kleine Anleitung zum Plugin enthalten, die einige
technische Informationen enthält.

\end{ospdescription}

Nachdem Sie das Plugin installiert haben, müssen Sie noch einen Link zum
Gästebuch-Plugin (der von Ihnen festgelegte \menu{Permalink}) in Ihrem Blog
hinzufügen. Den Link können Sie am besten über einen HTML-Klotz in der
Seitenleiste einfügen oder auch durch den Einbau in eine mögliche
Navigationsleiste Ihres Templates (siehe Kapitel \ref{templatefiles},
Seite \pageref{templatefiles-index}, oder auch Kapitel \ref{bpdesc} auf Seite
\pageref{bpdesc}).

Weiterhin verfügt das Plugin über ein mitgeliefertes Seitenleisten-Plugin.
Damit können Sie die letzten Gästebucheinträge in der Seitenleiste
darstellen. Die Konfigurationsoptionen sind dabei an das Plugin \emph{Letzte
Kommentare} (siehe Seite \pageref{Plugin-Kommentare}) angelehnt.

Die Ausgabe des Plugins erfolgt vollständig via Smarty-Templates. Die
Datei \cmd{plugin\_guestbook\_form.tpl} enthält den Code zur Darstellung des Formulares
\index{Template-Dateien!plugin\_guestbook\_form.tpl}%
für Eintragungen. Die Datei
\index{Template-Dateien!plugin\_guestbook\_entries.tpl}%
\cmd{plugin\_guestbook\_entries.tpl} wird zur Darstellung der einzelnen Gästebucheinträge verwendet.

Die dort gültigen Variablen sind:

\begin{ospdescription}
\index{Template-Variablen!\$staticpage\_headline}%
\ospitem{\cmd{\$staticpage\_headline: String}} enthält die Überschrift
des Gästebuchs.

\index{Template-Variablen!\$staticpage\_pagetitle}%
\ospitem{\cmd{\$staticpage\_pagetitle: String}} enthält den Kurztitel des
Gästebuchs.

\index{Template-Variablen!\$staticpage\_formorder}%
\ospitem{\cmd{\$staticpage\_formorder: String}} gibt an, ob das
Eintragsformular oben (\cmd{top}) oder unten (\cmd{bottom}) angezeigt
werden soll.

\index{Template-Variablen!\$admin\_delete}%
\ospitem{\cmd{\$admin\_delete: Bool}} ist auf \cmd{true} gesetzt, wenn
ein Administrator einen Gästebucheintrag löschen möchte.

\index{Template-Variablen!\$admin\_dodelete}%
\ospitem{\cmd{\$admin\_dodelete: Bool}} ist auf \cmd{true} gesetzt, wenn
ein Administrator eine Seite gelöscht hat.

\index{Template-Variablen!\$admin\_page}%
\ospitem{\cmd{\$admin\_page: Int}} enthält die Nummer der Seite, auf der
ein Administrator eine Aktion ausführt.

\index{Template-Variablen!\$admin\_url}%
\ospitem{\cmd{\$admin\_url: String}} enthält die Ziel-URL des Gästebuchs.

\index{Template-Variablen!\$admin\_target}%
\ospitem{\cmd{\$admin\_target: String}} enthält die Ziel-URL zum Löschen
eines Gästebucheintrags.

\index{Template-Variablen!\$base\_url}%
\ospitem{\cmd{\$base\_url: String}} enthält die URL des Blogs.

\index{Template-Variablen!\$is\_guestbook\_url}%
\ospitem{\cmd{\$is\_guestbook\_url: String}} enthält den Permalink zum
Gästebuch-Plugin.

\index{Template-Variablen!\$delete\_sure}%
\ospitem{\cmd{\$delete\_sure: String}} enthält einen Abfragetext, der 
benutzt werden kann, wenn ein Administrator einen speziellen
Gästebucheintrag löschen möchte.

\index{Template-Variablen!\$rip\_entry}%
\ospitem{\cmd{\$rip\_entry: String}} enthält einen Ausgabetext, wenn ein
spezieller Gästebucheintrag gelöscht wurde.

\index{Template-Variablen!\$is\_show\_mail}%
\index{Template-Variablen!\$is\_show\_url}%
\ospitem{\cmd{\$is\_show\_mail, \$is\_show\_url: Bool}} sind auf
\cmd{true} gesetzt, wenn im Eingabeformular die zusätzlichen
Eingabefelder für die E-Mail-Adresse oder die Homepage eines Benutzers
abgefragt werden sollen.

\index{Template-Variablen!\$plugin\_guestbook\_preface}%
\ospitem{\cmd{\$plugin\_guestbook\_preface: String}} enthält den
Einleitungstext des Gästebuch-Plugins.

\index{Template-Variablen!\$plugin\_guestbook\_sent}%
\ospitem{\cmd{\$plugin\_guestbook\_sent: String}} enthält den Text, der
angezeigt wird, wenn ein Benutzer einen Gästebucheintrag erstellt hat.

\index{Template-Variablen!\$plugin\_guestbook\_action}%
\ospitem{\cmd{\$plugin\_guestbook\_action: String}} enthält die URL zum
Abschicken eines Gästebucheintrags.

\index{Template-Variablen!\$plugin\_guestbook\_sname}%
\ospitem{\cmd{\$plugin\_guestbook\_sname: String}} enthält den
Seitentitel der Gästebuch-URL.

\index{Template-Variablen!\$plugin\_guestbook\_name}%
\index{Template-Variablen!\$plugin\_guestbook\_email}%
\index{Template-Variablen!\$plugin\_guestbook\_url}%
\index{Template-Variablen!\$plugin\_guestbook\_comment}%
\ospitem{\cmd{\$plugin\_guestbook\_name, \$plugin\_guestbook\_email,}}
\ospadditem{\cmd{\$plugin\_guestbook\_url, \$plugin\_guestbook\_comment: String}} enthält
die Benutzereingaben bei der Übermittlung eines Gästebuchkommentars.

\index{Template-Variablen!\$plugin\_guestbook\_emailprotect}%
\ospitem{\cmd{\$plugin\_guestbook\_emailprotect: String}} enthält den
Text, der den Besucher über den Schutz der E-Mail-Adresse informiert.

\index{Template-Variablen!\$plugin\_guestbook\_messagestack}%
\index{Template-Variablen!\$is\_guestbook\_message}%
\index{Template-Variablen!\$error\_occured}%
\index{Template-Variablen!\$guestbook\_messages}%
\ospitem{\cmd{\$plugin\_guestbook\_messagestack: Array,}}
\ospadditem{\cmd{\$is\_guestbook\_message: Bool,}}
\ospadditem{\cmd{\$error\_occured: String,
\$guestbook\_messages}} enthält etwaige Fehlermeldungen.

\index{Template-Variablen!\$plugin\_guestbook\_entry}%
\ospitem{\cmd{\$plugin\_guestbook\_entry: Array (timestamp)}} enthält
Daten, die das Plugin zur Prüfung eines Gästebuch"=Kommentars
durch das Antispam-Plugin benötigt.

\index{Template-Variablen!\$guestbook\_paging}%
\ospitem{\cmd{\$guestbook\_paging: String}} enthält HTML-Code für die
Seiten-Blätterfunktion der Einträge.

\index{Template-Variablen!\$guestbook\_entry\_paging}%
\ospitem{\cmd{\$guestbook\_entry\_paging: Bool}} ist auf \cmd{true}
gesetzt, wenn die Blätterungsfunktion aktiviert ist.

\index{Template-Variablen!\$guestbook\_entries}%
\ospitem{\cmd{\$guestbook\_entries: Array (email, name, homepage, body,
%)
}}
\ospadditem{\cmd{imgshorttime, timestamp, page, imgdelete)}} enthält das Array mit den
vorhandenen Gästebucheinträgen. \cmd{email, name, homepage, body}
enthalten dabei die Stammdaten eines Gästebuchkommentars. \cmd{page}
enthält die URL zum Löschen des jeweiligen Beitrags, \cmd{imgshorttime}
enthält eine URL zur Grafik einer Uhr, \cmd{imgdelete} die URL zur Grafik
eines Löschen-Icons. \cmd{timestamp} enthält das gemäß der
Plugin-Konfiguration formatierte Datum eines Beitrags.

\end{ospdescription}

\index{Plugins!Kontaktformular}%
\index{Plugins!serendipity\_event\_contactform}%
\index{Kontaktformular}%
\subsection{Kontaktformular\newline serendipity\_event\_contactform}

Das Plugin \emph{Kontaktformular} dient dazu, in Ihrem Blog den Besuchern
eine einfache Möglichkeit zu bieten, mit Ihnen in Kontakt zu treten. Dies
ist besonders dann hilfreich, wenn Sie im Blog keine E-Mail-Adresse
veröffentlichen möchten und bei der Kontaktaufnahme im Voraus bestimmte
Daten abfragen möchten.

Ähnlich wie das Gästebuch-Plugin können Sie nach der Installation des
Plugins eine eigenständige URL aufrufen, unter der das Kontaktformular
eingebunden wird.

Das Plugin kann detailliert konfiguriert werden, um festzulegen, welche
Angaben eines Besuchers Sie abfragen wollen. Dabei stehen Ihnen
folgende Optionen zur Verfügung:

\begin{ospdescription}

\ospitem{\menu{Permalink}}
Globaler Permalink, um die Ausgabe des Plugins im Frontend sehen zu
können. Details siehe Seite
\pageref{Standardpluginkonfiguration-Permalink}.

\ospitem{\menu{URL shorthand name}}
Globale Variable, die einen alternativen Permalink zur Ausgabe des
Plugins im Frontend bereitstellt. Details siehe Seite
\pageref{Standardpluginkonfiguration-Pagetitle}.

\ospitem{\menu{E-Mail-Adresse für Kontaktmails}}
Hier tragen Sie die E-Mail-Adresse ein, bei der Kontaktanfragen eingehen
sollen. Sie können mehrere Instanzen des Kontaktformular-Plugins benutzen,
um unterschiedliche Kontaktarten für unterschiedliche Adressen/Formulare
aufzusetzen. Abhängig vom Mailserver\footnote{Der Mailserver muss mehrere
Adressen im TO:-Header der E-Mail aufschlüsseln können.} auf Ihrem Server können
Sie mehrere E-Mail-Adressen mit Komma getrennt angeben. Alternativ können
Sie eine Mailingliste einrichten, um Kontaktmails an mehrere Adressen zu
verteilen.

\ospitem{\menu{Einführungstext}}
Der Einführungstext wird oberhalb des Kontaktformulars angezeigt. Hier
können Sie beliebigen HTML-Code eintragen.

\ospitem{\menu{Dargestellter Text nach Übermittlung der Nachricht}}
Hier können Sie HTML-Code eintragen, der dem Benutzer nach Abschicken des
Kontaktformulars angezeigt wird.

\ospitem{\menu{Als Artikel formatieren}}
Legt fest, ob das Kontaktformular im Layout normaler Blog-Einträge
angezeigt werden soll, Details siehe Seite
\pageref{Standardpluginkonfiguration-Articleformat}.

\ospitem{\menu{Use the dynamic tpl}}
Legt fest, welche Daten von einem
Besucher beim Abschicken eines Kontaktformulars abgefragt werden sollen.

\menu{Standard} legt als Pflichtfelder den Namen, die E-Mail-Adresse, die
Home\-page und einen Anfragetext fest.

\menu{Small Business} fragt die Pflichtfelder Vorname, Nachname,
E-Mail-Adresse und den Anfragetext ab. Im Vergleich zu \menu{Standard}
fehlt also die Homepage, aber dafür wird der Name in Vor- und Nachname
aufgeteilt.

\menu{Detailed Form} fragt zusätzlich zu den Feldern von \emph{Small
Business} auch noch eine postalische Adresse ab.

Als letzte Variante dient die Option \menu{Custom}. Wenn Sie diese Option
auswählen und auf den Button \menu{Speichern} klicken, wird unterhalb des
Auswahlfeldes ein detaillierter Erklärungstext und ein Eingabefeld
eingeblendet. Dort können Sie individuell festlegen, welche Kontaktfelder
im Formular eingebunden werden sollen.

\ospitem{\menu{Form field string}}
Die Syntax zur Eingabe der gewünschten Formularfelder sieht auf den
ersten Blick sehr komplex aus, da sie in einem einzigen Text\-eingabefeld
vorgenommen werden muss und nicht menügesteuert erfolgt. Dank
dieser Eingabezeile haben Sie dafür eine sehr große Flexibilität in der
Konfiguration der Felder.

Grundsätzlich müssen Sie für jedes Feld, das Sie im Kontaktformular
darstellen wollen, einen Block bestehend aus vier Attributen eingeben.
Mehrere Eingabefelder müssen Sie dabei mit dem Doppelpunkt (\cmd{:})
voneinander trennen. Die Attribute sind jeweils mit dem Semikolon
(\cmd{;}) voneinander separiert.

Dazu ein kleines Beispiel. Wenn Sie nur ein Feld \cmd{Nachricht} und
\cmd{Name} abfragen wollen, müssen Sie Folgendes im Eingabefeld
eintragen:

\begin{ospcode}
Name;text:Nachricht;textarea
\end{ospcode}

Es werden also zwei Elemente definiert, die jeweils nur zwei Attribute
besitzen. Die vollständige Liste der Attribute kann an erster Stelle den
Text \cmd{require} enthalten, um ein Feld zu einem Pflichtfeld zu machen.
In obigem Beispiel wären beide Felder optional, könnten also vom Besucher
leer gelassen werden. Um den Namen als Pflichtfeld zu definieren, wäre
folgende Eingabe nötig:

\begin{ospcode}
require;Name;text:Nachricht;textarea
\end{ospcode}

Als zweites Attribut\footnote{Wenn Sie das Sonderattribut \emph{require}
nicht angegeben haben, verschiebt sich die Attribut-Reihenfolge um eins
nach vorne.} folgt der Name des Eingabefeldes (in unseren Beispielen
\cmd{Name} und \cmd{Nachricht}).

Das dritte Attribut legt fest, wie das Eingabefeld dargestellt wird. Es
stehen folgende Eingabetypen zur Verfügung:

\begin{ospdescription}
\ospitem{\cmd{text}} Einzeilige Text-Eingabebox

\ospitem{\cmd{checkbox}} Ankreuzbox

\ospitem{\cmd{radio}} Auswahlbox

\ospitem{\cmd{hidden}} Verstecktes Feld

\ospitem{\cmd{password}} Passwort-Feld

\ospitem{\cmd{textarea}} Mehrzeiliges Eingabefeld

\ospitem{\cmd{select}} Ausklappfeld
\end{ospdescription}

Als viertes und letztes Attribut können Sie angeben, welcher Standardwert
in einem Formularfeld vorgegeben wird. Mit so einem Standardwert können
Sie Ihren Benutzern verdeutlichen, welche Eingaben Sie erwarten:

\begin{ospcode}
require;Homepage;text;Ihre private Homepage-URL
\end{ospcode}

Auch dieses letzte Attribut ist optional und kann weggelassen werden. Bei
den Typen \cmd{checkbox} und \cmd{radio} kann als letztes Attribut
\cmd{checked} angegeben werden, da eine Ankreuzbox nur entweder 
angekreuzt oder nicht angekreuzt sein kann. Bei dem Typ \cmd{select} kann
stattdessen das Attribut \cmd{selected} eingetragen werden.

Bei den beiden Typen \cmd{radio} und \cmd{select} gilt für das letzte
Attribut eine leicht unterschiedliche Syntax. Für derartige
Mehrfach"=Auswahlfelder müssen Sie festlegen, welche Inhalte diese
besitzen sollen. Diese werden mit einem weiteren Sonderzeichen, dem
Pipe-Symbol (\cmd{|}) voneinander getrennt:
\cmd{;Feld1,Wert1|Feld2,Wert2|Feld3,Wert3}. \cmd{FeldX} entspricht dabei
der Angabe, die der Besucher in einer Auswahlbox sieht, während
\cmd{WertX} dem entspricht, was als Wert später im Kontaktformular
übermittelt wird. Ihre Eingaben für \cmd{FeldX} und \cmd{WertX} können also
auch identisch lauten.

Um \cmd{radio}- und \cmd{select}-Felder zu verdeutlichen, konstruieren wir
ein weiteres Beispiel. Der Besucher soll zum einen mittels Auswahlbox
mitteilen, ob er ein Raucher ist. Dafür stehen ihm die
Antwortmöglichkeiten \emph{Militanter Nichtraucher}, \emph{Raucher} und
\emph{Nicht von einem Schornstein zu unterscheiden} zur Verfügung.
Vorausgewählt soll die erste Option sein. In der Kontaktmail soll zur
besseren Übersichtlichkeit nur \emph{nichtraucher}, \emph{raucher}
oder \emph{potenziellerKunde} erscheinen.

Zum anderen soll der Besucher mittels Ausklappfeld festlegen, was sein
Lieblingsessen ist. Hierfür soll er die Möglichkeiten \emph{Pizza},
\emph{Pommes}, \emph{Blumen} und \emph{Ich esse nichts das einen Schatten
wirft} wählen können. Hier soll die letzte Option vorausgewählt sein, und
diese Angabe soll ein Pflichtfeld sein. In der Kontaktmail sollen nur
die Werte \emph{pizza}, \emph{pommes}, \emph{blumen} und \emph{nichts}
erscheinen.

Dazu dient folgende Konfiguration (alles in einer Zeile einzugeben):

\begin{ospcode}
Raucher;radio;Militanter Nichtraucher,nichtraucher,checked|Raucher,
raucher|Nicht von einem Schornstein zu unterscheiden,potenziellerKu
nde:require;Lieblingsessen;select;Pizza,pizza|Pommes,pommes|Blumen,
blumen|Ich esse nichts das einen Schatten wirft,nichts,selected
\end{ospcode}

Bei Eingabe dieser Konfigurationsmöglichkeiten müssen Sie stets
darauf achten, dass Sie die richtigen Trennungszeichen verwenden, da es
ansonsten zu unvorhergesehenen Auswirkungen kommen könnte. Ganz besonders gilt,
dass Sie ein Komma (\cmd{,}) nicht innerhalb eines Auswahlfeld-Werts
einsetzen dürfen, da dies als Trennzeichen verwendet wird.

Alle Einträge, die über das Kontaktformular-Plugin von Besuchern ausgefüllt
wurden, können durch das Serendipity-Antispam-Plugin überprüft werden. Die
Antispam-Methoden greifen dafür auf die Felder \cmd{name}, \cmd{url},
\cmd{comment} und \cmd{email} zu. Wenn Sie das Antispam-Plugin also
sinnvoll integrieren wollen, sollten Sie darauf achten, bei einer
dnyamischen Konfiguration der Felder die Bezeichner für Namen, URLs etc.
mit exakt den genannten Bezeichnern zu verwenden.
\end{ospdescription}

Das Layout des Kontaktformulars kann durch die Smarty-Templatedateien
\index{Template-Dateien!plugin\_contactform.tpl}%
\cmd{plugin\_contactform.tpl} (für normale Kontaktformulare) und
\index{Template-Dateien!plugin\_dynamicform.tpl}%
\cmd{plugin\_""dynamicform.tpl} angepasst werden. Dabei sind folgende Variablen vorhanden:

\begin{ospdescription}
\index{Template-Variablen!\$is\_contactform\_error}%
\index{Template-Variablen!\$plugin\_contactform\_error}%
\index{Template-Variablen!\$comments\_messagestack}%
\ospitem{\cmd{\{\$is\_contactform\_error\}}: Bool,}
\ospadditem{\cmd{\{\$plugin\_contactform\_error\}}: String,}
\ospadditem{\cmd{\{\$comments\_messagestack\}}: String} enthält etwaige
Fehlermeldungen beim Absenden des Kontaktformulars.

\index{Template-Variablen!\$is\_contactform\_sent}%
\ospitem{\cmd{\{\$is\_contactform\_sent\}}: Bool} gibt an, ob das
Kontaktformular erfolgreich verschickt wurde.

\index{Template-Variablen!\$plugin\_contactform\_articleformat}%
\ospitem{\cmd{\{\$plugin\_contactform\_articleformat\}}: Bool} gibt an,
ob das Kontaktformular im Layout eines Blog-Artikels formatiert werden
soll.

\index{Template-Variablen!\$plugin\_contactform\_name}%
\ospitem{\cmd{\{\$plugin\_contactform\_name\}}: String} enthält den Namen
des Kontaktformulars.

\index{Template-Variablen!\$plugin\_contactform\_preface}%
\ospitem{\cmd{\{\$plugin\_contactform\_preface\}}: String} enthält den
Einleitungstext des Formulars.

\index{Template-Variablen!\$plugin\_contactform\_sent}%
\index{Template-Variablen!\$plugin\_contactform\_message}%
\ospitem{\cmd{\{\$plugin\_contactform\_sent\}}: String,}
\ospadditem{\cmd{\{\$plugin\_contactform\_message\}}: String} enthält den Text bei
erfolgreichem Versand des Kontaktformulars.

\index{Template-Variablen!\$commentform\_action}%
\ospitem{\cmd{\{\$commentform\_action\}}: String} enthält das URL-Ziel
des Formulars.

\index{Template-Variablen!\$commentform\_sname}%
\ospitem{\cmd{\{\$commentform\_sname\}}: String} enthält den URL-Namen
der gewählten Kontaktformular-Seite.

\index{Template-Variablen!\$commentform\_name}%
\index{Template-Variablen!\$commentform\_url}%
\index{Template-Variablen!\$commentform\_email}%
\index{Template-Variablen!\$commentform\_comment}%
\ospitem{\cmd{\{\$commentform\_name\}}: String,}
\ospadditem{\cmd{\{\$commentform\_url\}}: String,} 
\ospadditem{\cmd{\{\$commentform\_email\}}: String,}
\ospadditem{\cmd{\{\$commentform\_comment\}}: String} enthält die
Formulareingaben des Benutzers.

\index{Template-Variablen!\$commentform\_dynamicfields}%
\ospitem{\cmd{\{\$commentform\_dynamicfields\}}: Array} enthält eine
Liste der konfigurierten dynamischen Eingabefelder des Kontaktformulars.
\end{ospdescription}

\subsubsection{Datenbanktabelle}

\index{Datenbank-Tabellen!serendipity\_guestbook}%
Gästebucheinträge werden in der Datenbanktabelle
\cmd{serendipity\_guest\-book} gespeichert:

\begin{ospdescription}
\ospitem{\cmd{id}} enthält die fortlaufende ID eines Gästebucheintrags.
\ospitem{\cmd{ip}} enthält die IP des Besuchers.
\ospitem{\cmd{name}} enthält den Namen des Besuchers.
\ospitem{\cmd{homepage}} enthält die Homepage des Besuchers.
\ospitem{\cmd{email}} enthält die E-Mail-Adresse des Besuchers.
\ospitem{\cmd{body}} enthält den Gästebucheintrag des Besuchers.
\ospitem{\cmd{timestamp}} enthält die Uhrzeit, zu der der Gästebucheintrag
erstellt wurde.
\end{ospdescription}

\index{Foren}%
\index{Boards}%
\index{phpBB}%
\index{Plugins!Diskussionsforum/phpBB-Kommentare}%
\index{Plugins!serendipity\_event\_forum}%
\subsection{Diskussionsforum/phpBB-Kommentare\newline serendipity\_event\_forum}

Diskussionen in Blogs finden üblicherweise thematisch isoliert in den
jeweiligen Blog-Artikeln statt. Im Gegensatz zu einem Diskussionsforum
mit offenen Themenbereichen dient ein Blog üblicherweise der
Einzelberichterstattung. Anstatt einer Diskussion gleichberechtigter
Teilnehmer stellt ein Blog-Artikel meist die Meinung des jeweiligen
Redakteurs dar, zu der sich Besucher dann äußern können.

Wenn ein Besucher eines Blogs ein Thema ansprechen und zur Diskussion
bringen möchte, wäre dies in einem Blog-Artikel fehl am Platz. Daher
stellt das Plugin \emph{Diskussionsforum} eine Plattform innerhalb des
Blogs bereit, wo sich Besucher unabhängig von den Blog-Artikeln
austauschen können.

Generell können Sie etwas Derartiges auch durch die Installation einer
separaten Foren-Software wie phpBB, FUDForum oder anderer auf Ihrem
Webserver anbieten und in Ihrem Blog einfach einen Link auf eine solche
separate Anwendung setzen.

Wenn Sie aber nur ein kleines Forum betreiben und dafür
keine zweite Anwendung installieren und warten möchten, bietet sich jedoch das
Foren-Plugin an. Dieses Plugin integriert sich in Serendipity und
kann auch die Benutzerdatenbank Serendipitys weiterverwenden, um den
Zugang gegebenenfalls nur auf registrierte Benutzer zu beschränken.

Das Forum lässt sich nach der Installation über 
\cmd{http://www.example.""com/""serendipity/index.php?serendipity[subpage]=forum}
aufrufen. Im Gegensatz zu anderen Plugins bietet es keinen eigenständigen
Permalink (siehe Seite \pageref{Standardpluginkonfiguration-Permalink})
an, Sie können höchstens den Wert \emph{forum} in der URL-Variable frei
bestimmen.

Im Frontend des Forums können Besucher neue Themen erstellen und auf
bestehende Themen antworten. Die Bedienung erfolgt dabei wie in jeder
Foren-Software: Erst wählt der Besucher in der Themenübersicht einen
Bereich aus und kann dort die enthaltenen Beiträge ansehen. Über den
Button \menu{New Thread} kann der Besucher einen neuen Beitrag beginnen
und dort eine Überschrift und seinen Beitrag erstellen. Abhängig von der
Konfiguration des Foren-Plugins können Besucher oder Administratoren auch
Dateianhänge zu einem neuen Thema in das Forum einstellen.

Zu jedem Beitrag kann ein Besucher (sofern er einen Redakteurs-Login zum
Blog besitzt) die E-Mail-Benachrichtigung zu neuen Themen aktivieren.
Administratoren können zudem direkt im Frontend Beiträge überarbeiten,
löschen oder auch ganze Themenzweige sperren.

Das Backend des Plugins zur Einrichtung neuer Unterforen kann ein
Redakteur über das Serendipity-Backend erreichen. Dort befindet sich der
Menüpunkt \menu{Einträge\sm Diskussions-Forum/phpBB-Kommentare}. In
diesem Bereich werden alle bestehenden Foren aufgelistet, das neue
Unterforum kann über den Button \menu{Neues Forum hinzufügen}
eingerichtet werden. Bestehende Unterforen können durch einen Klick auf
den jeweiligen Namen bearbeitet werden.

Unabhängig von diesem eigenständigen Forum bietet das Plugin ein weiteres
Feature an, um Ihr Blog mit einer phpBB-Foreninstallation zu verbinden.
Mit Hilfe dieses Features können Sie die Kommentare zu Blog-Artikeln in
einem unabhängigen Forum verwalten und somit von Serendipity loslösen.
Dies macht besonders dann Sinn, wenn Sie über die von Serendipity
angebotenen Kommentarmöglichkeiten hinaus oft besonders lange
Diskussionen zu Artikeln führen möchten. Auch wenn Sie bereits ein
phpBB-Forum mit bestehenden Diskussionen betreiben, können Sie dank des
Plugins Serendipity als eine Art News-System einsetzen und sämtliche
Diskussionen wie früher über phpBB führen.

Die Konfiguration des Plugins bietet folgende Optionen:

\begin{ospdescription}

\ospitem{\menu{Seitentitel}}
Der \menu{Seitentitel} des Forums wird im Inhaltsbereich dargestellt und
kann individuell festgelegt werden.

\ospitem{\menu{Kopfzeile/Beschreibung}}
Unterhalb des Seitentitels können Sie eine \menu{Kopfzeile/Beschreibung}
definieren.

\ospitem{\menu{Statische URL}}
Hier können Sie ein einfaches Wort eintragen, das für die URL verwendet
wird, über die Sie das Forum aufrufen können. Standardmäßig ist hier
\emph{forum} eingetragen, und die URL für das Forum lautet somit
\cmd{http://www.example.com/serendipity/index.php?seren-\osplinebreak{}dipity[subpage]=forum}.

Das Forum müssen Sie selbständig über einen HTML-Klotz oder das
Bearbeiten Ihres Templates in das Blog einfügen, damit Ihre Besucher
dorthin finden können. Achten Sie also darauf, den Link dorthin immer
übereinstimmend mit der Konfiguration anzulegen. Das hier eingetragene
Wort darf keine Sonder- und Leerzeichen enthalten.

\ospitem{\menu{Enable phpBB mirroring}}
Anstatt Kommentare zu Blog-Artikeln durch Serendipity zu verwalten,
möchten manche Blog-Betreiber lieber ein spezialisiertes Forensystem zur
Diskussionsführung benutzen. Solche Forensysteme haben oft einfacher
strukturierte Kommentarmöglichkeiten und sind zugänglicher für Benutzer,
die sich mit Foren bereits auskennen, Blogs eher als redaktionelles
System ansehen und ihre Diskussionen im "`liebgewonnenen"' System führen
wollen.

Wenn Sie die Option \menu{Enable phpBB mirroring} aktivieren, wird das Plugin
sämtliche Kommentare, die im Blog angezeigt werden, aus einer bestehenden 
phpBB 2.x- oder 3.x-Installation (je nach gewähltem Wert dieser Option) beziehen. Wenn
Sie neue Kommentare im Blog eintragen, werden diese automatisch in die
phpBB-Forendatenbank eingefügt. Für Ihre Besucher erscheinen alle Kommentare
also sowohl im Forum als auch im Blog, werden aber nur an der zentralen Stelle im
Forum tatsächlich verwaltet. Auch wenn Sie im Blog einen neuen Artikel erstellen, 
wird das Plugin Ihren Artikel automatisch im Forum einstellen, damit er dort 
diskutiert werden kann.

Damit das Plugin diesen Abgleich durchführen kann, muss es auf die
Datenbank von phpBB zugreifen können. Dazu dienen die 
Konfigurationsfelder \cmd{database username, password, server, name} und
\cmd{table prefix}. Tragen Sie hier Daten einer bestehenden
phpBB-Konfiguration ein. Sollten Sie phpBB noch nicht auf Ihrem Webserver
installiert haben, müssen Sie dies nachholen.\footnote{Die
Installationsanweisungen finden Sie unter
\cmd{http://www.phpbb.com/}.}

Ein phpBB-Forum kann Kommentare immer erst in einem Themenbereich (dem
\menu{forum}) anlegen. Diese Themenbereiche legen Sie in der
phpBB-Installation an, jedes Forum erhält eine eigene ID. Das
offizielle Serendipity-Forum wird beispielsweise mit phpBB betrieben, und
der deutsche Bereich hat die ID \cmd{10}
(\cmd{http://board.s9y.org/view\-forum.php?f=10}). Diese ID des Zielforums
müssen Sie in der Konfiguration des Plugins im Feld \menu{(optional)
phpBB target forum ID} eintragen.

Durch die Abgrenzung des Forums ist zudem gewährleistet, dass Sie in
Ihrem phpBB-Forum auch andere, vom Blog unabhängige Bereiche anlegen
können.

Wenn Sie einen Artikel im Blog erstellen, wird dieser mit der User-ID
eingetragen, die Sie im Feld \menu{(optional) phpBB target poster ID}
konfiguriert haben. Diese User-ID muss einer im Forum bestehenden ID
entsprechen, am besten legen Sie also im Forum einen eigenständigen
Benutzer an, der den Namen Ihres Blogs trägt. So können die Forennutzer
einfach herausfinden, welche Artikel "`das Blog"' erstellt hat.

Sämtliche Kommentare, die vom Blog aus erstellt werden, trägt das Plugin
als anonyme Benutzer mit dem im Blog eingetragenen Benutzernamen direkt
in die Datenbank ein. So kann zwar ein Kommentar nicht eindeutig einem
bestehenden Forennutzer zugeordnet werden, aber durch die Beibehaltung
der Benutzernamen bleibt dies eindeutig. Wenn ein Benutzer direkt über
das Forum anstatt über das Blog kommentiert, kann die korrekte
Benutzerzuordnung selbstverständlich beibehalten werden.

\ospitem{\menu{Absoluter Server-Pfad zum uploads-Verzeichnis}}
Hier tragen Sie den absoluten Server-Pfad zu dem Verzeichnis ein, in dem
über das Forum hochgeladene Dateien gespeichert werden.

\ospitem{\menu{Pfad zu dem Plugin}}
Das Foren-Plugin bringt einige Grafikdateien mit, beispielsweise für
die Buttons zur Erstellung neuer Beiträge. Damit diese Grafiken angezeigt
werden können, muss das Plugin den vollständigen HTTP-Pfad hinter der
Domainangabe kennen.

Standardmäßig ist hier der korrekte Pfad voreingetragen, er sollte daher
nur geändert werden, wenn Sie Ihre Plugin-Verzeichnisse umbenannt haben.

\ospitem{\menu{Datumsformat}}
Das \menu{Datumsformat} bestimmt, mit welcher Formatierung das Datum zu
Diskussionsbeiträgen dargestellt wird. Standardmäßig ist hier die
englische Syntax eingetragen, die deutsche Datumsformatierung wäre
\cmd{d.m.Y}.\footnote{Die zur Verfügung stehenden Variablen sind auf
\cmd{http://de.php.net/date} aufgeführt.}

\ospitem{\menu{Zeitformatierung}}
Analog zum Datumsformat tragen Sie hier das Format ein, mit dem eine
Uhrzeit zu Diskussionsbeiträgen angezeigt werden soll.

\ospitem{\menu{Einträge pro Seite}}
Die \menu{Einträge pro Seite} bestimmen, wie viele Diskussionsbeiträge in
Übersichtsseiten angezeigt werden. Weitere Seiten sind blätterbar.

\ospitem{\menu{Hintergrundfarbe der Titelzeilen, 1. und 2. Hintergrundfarbe,}}
\ospadditem{\menu{Farbe für Schriftzüge}}
Über diese Konfigurationsfelder können Sie mehrere Farbeinstellungen
vornehmen, die das Plugin zur Darstellung des Forums benutzt. Die Farben
müssen dabei im HTML-typischen RGB-Format (Hex \#RR""GGBB) eingetragen
werden.

\osppagebreak

\ospitem{\menu{Spamblock-Plugin benutzen}}
Um Spam zu verhindern, können alle Diskussionsbeiträge durch das
Anti-Spam-Plugin behandelt werden. Dies führt zum Beispiel auch dazu,
dass Captchas (siehe Seite \pageref{Captcha}) für jeden Beitrag
erforderlich sind.

\ospitem{\menu{Sollen die Textformatierungs-Plugins benutzt werden}}
Wenn Sie diese Option aktivieren, können die Diskussionsbeiträge von
Benutzern genauso wie Kommentare zu Blog-Artikeln mit Ihren installierten
Textformatierungs-Plugins (siehe Seite \pageref{Textformatierungs-Plugins})
bearbeitet werden.

\ospitem{\menu{Textformatierungs-Plugins für unregistrierten User deaktivieren}}
Das Foren-Plugin kann eingeloggte Redakteure von anonymen Besuchern
unterscheiden. Um unregistrierten Besuchern zu verbieten, z.\,B.\ Links in
Diskussionsbeiträge einzufügen, können Sie gezielt diesen Besuchern das
Benutzen der Textformatierungs-Plugins verbieten. Dazu müssen Sie die
Option \menu{Textformatierungs-Plugins für unregistrierten User
deaktivieren} auf \emph{Ja} stellen.

\ospitem{\menu{Datei-Upload für registrierte User, Datei-Upload für Gäste}}
Bei der Erstellung eines Diskussionsbeitrags können Sie es registrierten
Benutzern und auch Gästen erlauben, Dateien hochzuladen. Diese Dateien
werden dem jeweiligen Beitrag angehängt und können von Besuchern des
Forums heruntergeladen werden. Sinnvoll ist dies, um Ihre Besucher
beispielsweise Screenshots oder Fotos anhängen zu lassen.

Beachten Sie hierbei, dass die Dateien auf Ihrem eigenen Webserver
gespeichert werden; möglicherweise kann dies von Ihren Besuchern
missbraucht werden und Ihren Speicherplatz aufbrauchen. Je nach
Einsatzzweck Ihres Forums kann es also empfehlenswert sein, Gästen keine
Upload-Möglichkeiten zu erlauben.

\ospitem{\menu{Anzahl gleichzeitiger Datei-Uploads, Max. Anzahl Dateien in
einem Posting}}
Standardmäßig darf ein Forenteilnehmer nur drei Dateien pro
Diskussionsbeitrag einstellen. Über das Feld \menu{Max. Anzahl Dateien in
einem Posting} können Sie aber auch mehrere Uploads zulassen.

Jede Datei muss dabei vom Besucher einzeln hochgeladen werden, damit Ihr
Webserver nicht überlastet wird. Über die Option \menu{Anzahl
gleichzeitiger Datei-Uploads} können Sie jedoch festlegen, dass auch mehr
als nur eine Datei gleichzeitig hochgeladen werden kann.

\ospitem{\menu{Max. Anzahl Datei-Uploads pro User}}
Sie können generell beschränken, wie viele Dateien ein Benutzer maximal
hochladen darf. Nachdem ein Benutzer das Limit erreicht hat, darf er
keine weiteren Dateien mehr einstellen.

Diese Option wirkt ausschließlich für registrierte Benutzer. Da ein Gast
für das Plugin immer als ein neuer Benutzer gilt, können Uploads für
Gäste nicht in ihrer Anzahl beschränkt werden. Im Zweifelsfall sollten
Sie daher die Option \menu{Datei-Upload für Gäste} nicht aktivieren.

\ospitem{\menu{Benachrichtigungs-E-Mail: E-Mail-Adresse, Name}}
Wenn Ihre Forenteilnehmer die E-Mail-Benachrichtigung aktiviert haben,
werden sie bei Antworten zu ihren abonnierten Themen via E-Mail
benachrichtigt. Tragen Sie in die beiden Konfigurationsfelder ein, von
welcher E-Mail-Adresse diese Benachrichtigungen stammen sollen und wie
der Absendername lauten soll.

Viele Webserver erlauben den E-Mail-Versand nur von den Adressen, für die
sie freigeschaltet sind, daher können Sie möglicherweise nicht
jede beliebige E-Mail-Adresse an dieser Stelle eintragen.

\ospitem{\menu{Admin benachrichtigen}}
Wenn Sie die Option \menu{Admin benachrichtigen} aktivieren, erhalten
alle Administratoren des Blogs eine E-Mail, sobald neue Forenbeiträge von
Teilnehmern erstellt wurden.
\end{ospdescription}

Das Foren-Plugin benutzt zur Darstellung der Inhalte weitestgehend
Smar\-ty-Template-Dateien. Diese befinden sich im Unterverzeichnis
\cmd{plugins/""serendipity\_event\_forum/templates}. Die Datei
\index{Template-Dateien!boardlist.tpl}%
\cmd{boardlist.tpl} stellt die Forenübersichten dar,
\index{Template-Dateien!threadlist.tpl}%
\cmd{threadlist.tpl} die Themenübersichten und 
\index{Template-Dateien!postlist.tpl}%
\cmd{postlist.tpl} die jeweiligen Beiträge. Die Datei
\index{Template-Dateien!newthread.tpl}%
\cmd{newthread.tpl} stellt das Formular zum Erzeugen eines neuen Beitrags dar,
\index{Template-Dateien!editform.tpl}%
\cmd{editform.tpl} das Formular zum Bearbeiten eines bestehenden Beitrags und
\index{Template-Dateien!replyform.tpl}%
\cmd{replyform.tpl} zum Antworten auf einen Beitrag.
\index{Template-Dateien!deleteform.tpl}%
\cmd{deleteform.tpl} dient der Ausgabe zum Löschen von Beiträgen durch Administratoren.

Einige HTML-Codes zur Darstellung von Buttons und Übersichten werden
leider auch in der Plugin-Datei \cmd{serendipity\_event\_forum.php}
vorgenommen. Daher würde eine Dokumentation der notwendigen Variablen den
Rahmen dieses Buches sprengen. Schauen Sie sich daher bitte zur
Bearbeitung die jeweils bestehenden Dateien an. Der
Administrationsbereich ist vollständig innerhalb des PHP-Codes des
Plugins enthalten und kann derzeit nicht durch Smarty-Template-Dateien angepasst
werden. Das Plugin unterscheidet Forenbenutzer nicht anhand ihrer
Benutzergruppen, sondern behandelt alle registrierten Benutzer
ausschließlich anhand ihres Benutzerranges (Userlevel).

Derzeit verfügt das Plugin über keinen aktiven Entwickler, es wäre für
die Zukunft jedoch schön, den PHP-Code des Plugins etwas zu entschlacken,
um neue Features leichter einbauen zu können. Sollten Sie sich angespornt
fühlen, dem Plugin etwas Gutes zu tun, melden Sie sich bitte im
Serendipity-Forum.

\subsubsection{Datenbanktabellen}

\index{Datenbank-Tabellen!serendipity\_dma\_forum\_boards}%
In der Datenbanktabelle \cmd{serendipity\_dma\_forum\_boards} werden die
jeweiligen Unterforen gespeichert:

\begin{ospdescription}
\ospitem{\cmd{boardid}} enthält die ID des jeweiligen Unterforums.
\ospitem{\cmd{name}} enthält den Namen des Unterforums.
\ospitem{\cmd{description}} enthält die Beschreibung des Unterforums.
\ospitem{\cmd{sortorder}} enthält einen numerischen Wert zur Sortierung der
Unterforen untereinander.
\ospitem{\cmd{threads}} enthält die Anzahl der in diesem Unterforum vorhandenen
Themen (\emph{Threads}).
\ospitem{\cmd{posts}} enthält die Anzahl der in diesem Unterforum geschriebenen
Beiträge (\emph{Posts}).
\ospitem{\cmd{views}} enthält die Anzahl der Lesezugriffe zu diesem Unterforum.
\ospitem{\cmd{flag}} gibt an, ob ein Unterforum deaktiviert wurde.
\ospitem{\cmd{lastauthorid}} enthält die ID des Redakteurs, der zuletzt einen
Beitrag verfasst hat.
\ospitem{\cmd{lastauthorname}} enthält den Namen des Redakteurs, der zuletzt einen
Beitrag verfasst hat.
\ospitem{\cmd{lastthreadid}} enthält die ID des aktuellsten Themas.
\ospitem{\cmd{lastpostid}} enthält die ID des aktuellsten Beitrags.
\ospitem{\cmd{lastposttime}} enthält die Uhrzeit des aktuellsten Beitrags.
\end{ospdescription}

\index{Datenbank-Tabellen!serendipity\_dma\_forum\_threads}%
Die Tabelle \cmd{serendipity\_dma\_forum\_threads} speichert die jeweiligen\osplinebreak{}
Themen im Forum:
\begin{ospdescription}
\ospitem{\cmd{boardid}} enthält die ID des Unterforums, in dem sich das Thema befindet.
\ospitem{\cmd{threadid}} enthält eine fortlaufende ID dieses Themas.
\ospitem{\cmd{title}} enthält den Titel des Themas.
\ospitem{\cmd{replies}} enthält die Anzahl an Antworten zu dem Thema.
\ospitem{\cmd{views}} enthält die Anzahl an Lesezugriffen zu diesem Thema.
\ospitem{\cmd{flag}} gibt an, ob dieser Thread aktiv ist.
\ospitem{\cmd{notifymails}} enthält eine Liste aller E-Mail-Adressen, die bei
Eintreffen eines neuen Beitrags benachrichtigt werden sollen.
\ospitem{\cmd{announce}} gibt an, ob das Thema eine Ankündigung ist.
\ospitem{\cmd{lastauthorid}} enthält die ID des Redakteurs, der zuletzt einen
Beitrag zu diesem Thema geschrieben hat.
\ospitem{\cmd{lastauthorname}} enthält den Namen des Redakteurs, der zuletzt einen
Beitrag zu diesem Thema geschrieben hat.
\ospitem{\cmd{lastpostid}} enthält die ID des letzten Beitrags zu dem Thema.
\end{ospdescription}

\index{Datenbank-Tabellen!serendipity\_dma\_forum\_posts}%
Die Artikel werden in der Tabelle \cmd{serendipity\_dma\_forum\_posts}
gespeichert: 
\begin{ospdescription}
\ospitem{\cmd{threadid}} enthält die ID des zugeordneten Themas.
\ospitem{\cmd{postid}} enthält die fortlaufende ID des Beitrags.
\ospitem{\cmd{postdate}} enthält das Erstellungsdatum des Beitrags.
\ospitem{\cmd{title}} enthält den Titel des Beitrags.
\ospitem{\cmd{message}} enthält den Inhalt des Beitrags.
\ospitem{\cmd{flag}} gibt an, ob dieser Beitrag aktiv ist.
\ospitem{\cmd{authorid}} enthält die ID des erstellenden Redakteurs.
\ospitem{\cmd{authorname}} enthält den Namen des erstellenden Redakteurs.
\ospitem{\cmd{editcount}} enthält die Anzahl an Bearbeitungen dieser Nachricht.
\end{ospdescription}

\index{Datenbank-Tabellen!serendipity\_dma\_forum\_users}%
Zusätzliche Foren-Benutzer werden in der Tabelle
\cmd{serendipity\_dma\_fo\-rum\_users} gespeichert:

\begin{ospdescription}
\ospitem{\cmd{authorid}} enthält die ID eines Benutzers.
\ospitem{\cmd{posts}} enthält die Anzahl an Beiträgen des Benutzers.
\ospitem{\cmd{visits}} enthält die Anzahl an Besuchen des Benutzers.
\ospitem{\cmd{lastvisit}} enthält das Datum des letzten Besuchs.
\ospitem{\cmd{lastpost}} enthält die ID des letzten Beitrags dieses Benutzers.
\ospitem{\cmd{uploadids}} enthält die IDs der von dem Benutzer hochgeladenen
Dateien.
\end{ospdescription}

\index{Datenbank-Tabellen!serendipity\_dma\_forum\_uploads}%
Benutzer können, abhängig von der Konfiguration des Plugins, selbständig Dateien
hochladen. Diese werden in der Datenbanktabelle
\cmd{serendipity\_""dma\_forum\_uploads} gespeichert:

\begin{ospdescription}
\ospitem{\cmd{postid}} enthält die ID des Beitrags, in dem eine Datei eingebunden wurde.
\ospitem{\cmd{authorid}} enthält die ID des hochladenden Redakteurs.
\ospitem{\cmd{uploadid}} enthält eine fortlaufende ID für die hochgeladene Datei.
\ospitem{\cmd{uploaddate}} enthält das Datum, an dem die Datei hochgeladen wurde.
\ospitem{\cmd{filesize}} enthält die Dateigröße.
\ospitem{\cmd{sysfilename}} enthält den Dateinamen.
\ospitem{\cmd{realfilename}} enthält den vollständigen Pfad zur Datei.
\ospitem{\cmd{dlcount}} enthält die Anzahl an Downloads dieser Datei.
\end{ospdescription}

\index{Plugins!Downloadmanager}%
\index{Plugins!serendipity\_event\_downloadmanager}%
\subsection{Downloadmanager\newline serendipity\_event\_downloadmanager}

Mittels der Serendipity-Mediendatenbank haben Sie als Blog-Redakteur die
Möglichkeit, Dateien in Blog-Artikel einzubinden, damit Ihre Besucher
diese herunterladen können.

Wenn Sie jedoch viele Dateien übersichtlich zum Download anbieten wollen,
ist diese Methode mit zu viel manueller Arbeit verbunden. Aus diesem
Grund wurde das \emph{Downloadmanager}-Plugin entwickelt.

Mit diesem Plugin können Sie komfortabel einen Download-Katalog anlegen.
Auf beliebige Unterrubriken verteilt können Sie hier Ihre Dateien
sortieren und dem Besucher anbieten.

Sobald das Plugin installiert wurde, können Sie über den Menüpunkt
\menu{Einträge\sm Downloadmanager} Kategorien einrichten. Um eine neue
Kategorie einzurichten, tragen Sie den Namen im Feld
\menu{Kategorie-Name} ein. Über das Ausklappfeld \menu{Unter-Kategorie
von} können Sie festlegen, ob die neu zu erstellende Kategorie unterhalb
einer bestehenden angelegt werden soll.

Alle vorhandenen Kategorien werden am Ende der Verwaltungsoberfläche in
einer Baumstruktur angezeigt. Dort können Sie bestehende Kategorien
umbenennen, indem Sie einen neuen Namen eintragen und auf \menu{Los!}
klicken. Kategorien können Sie löschen, indem Sie auf das zugehörige Bild
mit der Mülltonne klicken. Wenn ein Warndreieck über der Mülltonne
angezeigt wird, ist dies ein Indikator, dass beim Löschen auch vorhandene
Unterkategorien entfernt würden. Um eine Kategorie nur vorübergehend zu
verstecken, können Sie auf den danebenstehenden Kreis klicken. Rechts
neben dem Namen einer Kategorie sehen Sie zur Information die Anzahl der
darin angelegten Dateien.

Um Dateien in eine bestehende Kategorie einzustellen, müssen Sie auf das
Ordnersymbol links neben dem jeweiligen Kategorienamen klicken.

In der folgenden Oberfläche haben Sie insgesamt drei Möglichkeiten,
Dateien zuzuordnen. Dabei greift das Plugin auf Unterverzeichnisse zu,
die Sie in der Konfiguration des Plugins festlegen können. Diese
Unterverzeichnisse sollten Sie mittels FTP manuell anlegen oder
alternativ das bestehende \cmd{uploads}-Unterverzeichnis verwenden.

Die erste Zuordnungsmöglichkeit ist das Hochladen von Dateien über die
Downloadmanager-Oberfläche. Hierfür klicken Sie auf den Link
\menu{Dateien hochladen\ldots}, der sich neben dem Informationstext
\menu{Dateien in dieser Kategorie} befindet. Mittels dieser Oberfläche
können Sie Dateien von Ihrer Festplatte auswählen und optional eine
Beschreibung dieser Datei in der Eingabebox darunter eintragen. Sie
können maximal fünf Dateien auf einmal hochladen. Die maximale Dateigröße
richtet sich nach der PHP"=Konfiguration Ihres Webservers (siehe Seite
\pageref{file-uploads}).

Die zweite Zuordnungsmöglichkeit ist die Übernahme von Dateien, die Sie
mittels FTP in das sogenannte \emph{incoming-Verzeichnis} hochgeladen
haben. Die Oberfläche zeigt alle in diesem Verzeichnis vorhandenen
Dateien an, und Sie können durch einen Klick auf das Ordnersymbol mit
dem Pfeil darin auswählen, welche Dateien Sie in die
Downloadmanager-Kategorie übernehmen möchten. Die Datei wird daraufhin
aus dem incoming-Verzeichnis in das Zielverzeichnis verschoben.

Als letzte Zuordnungsmöglichkeit können Sie Dateien auswählen, die Sie bereits in
die Mediendatenbank von Serendipity hochgeladen haben. Ähnlich
wie beim incoming-Verzeichnis können Sie hier eine bestehende Datei
durch Klick auf das Ordnersymbol mit dem grünen Pfeil in die
Downloadmanager"=Kategorie übernehmen. Dabei wird die Datei aber nicht
verschoben, sondern einfach kopiert.

Nachdem Sie über diese Mechanismen Dateien zugeordnet haben, werden diese
in der Dateiübersicht am Anfang der Seite dargestellt. Neben
Informationen zum Dateinamen, den durchgeführten Downloads von Besuchern
und der Dateigröße können Sie eine Datei über das Mülltonnen-Symbol auch
wieder löschen. Die Dateibeschreibung jeder Datei können Sie ändern,
indem Sie auf den jeweiligen Dateinamen klicken. Dort können Sie auch
eine Datei einer anderen Kategorie zuordnen, um sie zu verschieben. 
Über den Link \menu{Zurück\ldots} kehren Sie zur Kategorie-Übersicht zurück.

Den Downloadmanager können Ihre Besucher über den im Plugin
konfigurierten Permalink aufrufen, standardmäßig 
\cmd{http://www.example.com/""serendipity/index.php?serendipity[subpage]=downloadman\-ager}.

In dieser Oberfläche sehen die Besucher eine Verzeichnisstruktur ähnlich
Ihrer Administrationsoberfläche. Dort können die Besucher beliebig
navigieren und eingestellte Dateien herunterladen.

Der Zugriff auf die Datei erfolgt stets über das Downloadmanager-Plugin,
die Datei wird also nicht direkt über das Verzeichnis heruntergeladen.
Dadurch können Ihre Besucher nicht einfach beliebige Dateien
herunterladen, und der Downloadmanager ist in der Lage, die Anzahl der
Down\-loads zu zählen. Gleichzeitig bedeutet dieser technische Kniff jedoch
auch, dass Ihre Besucher nur Dateien herunterladen können, die das Plugin
komplett in den Speicher laden kann. Daher ist das Plugin für Dateien
größer als das festgelegte PHP-Speicherlimit (meist 8MB) nicht geeignet.

Folgende Konfigurationsoptionen bietet das Plugin:

\begin{ospdescription}
\ospitem{\menu{Seitentitel}}
Der \menu{Seitentitel} wird als Überschrift in der
Downloadmanager"=Übersicht für die Besucher eingeblendet.

\ospitem{\menu{Kopfzeile}}
Die \menu{Kopfzeile} dient als Unter-Überschrift für die
Downloadmanager-Übersicht.

\ospitem{\menu{Statische URL}}
URL-Titel der Seite, mit dem Sie die URL
\cmd{http://www.example.com/""serendipity/index.php?serendipity[subpage]=downloadman\-ager}
aufrufen können. Details siehe Seite
\pageref{Standardpluginkonfiguration-Pagetitle}.

\ospitem{\menu{Permalink}}
Den alternativen Permalink zum Zugriff auf das Plugin können Sie in
diesem Konfigurationsfeld eintragen. Details siehe Seite
\pageref{Standardpluginkonfiguration-Permalink}.

\ospitem{\menu{Pfad zu "`incoming"'}}
Das \cmd{incoming}-Verzeichnis dient der Speicherung von Dateien, die Sie
via FTP hochladen, um diese in den Downloadmanager zu importieren.
Das hier festgelegte Verzeichnis muss Schreibrechte für den Webserver
besitzen (z.\,B.\ 0777).

\ospitem{\menu{Pfad zu "`download"'-Verzeichnis}}
Im Gegensatz zum temporären \cmd{incoming}-Verzeichnis werden die Dateien
im \cmd{download}-Verzeichnis dauerhaft gespeichert und von
dort aus an die Besucher ausgeliefert.

\ospitem{\menu{HTTP-path to plugin}}
Dieses Verzeichnis legt den HTTP-Pfad fest, der zu dem
Downloadma\-nager-Plugin-Verzeichnis führt. Aus diesem Verzeichnis werden
die Icons und Grafikdateien bezogen, die das Plugin zur Darstellung
benötigt. Normalerweise müssen Sie an der Standardeinstellung des Plugins
nichts ändern.

\ospitem{\menu{Icon Breite, Icon Höhe}}
Das Plugin liefert einige Icons für bekannte Dateierweiterungen (ZIP,
PDF, Bilddateien etc.) mit, die in der Dateiübersicht für den Besucher
angezeigt werden. Diese Dateien sind standardmäßig 18 Pixel breit und 20
Pixel hoch. Wenn Sie die Grafikdateien gerne gegen andere und größere
Icons austauschen wollen, können Sie über die Optionen \menu{Icon Breite}
und \menu{Icon Höhe} die neuen Ausmaße der Grafik festlegen.

Beachten Sie: Wenn Sie die Größe ändern, ohne die Grafikdateien
auszutauschen, werden die Grafiken nur vom Browser vergrößert und
dadurch möglicherweise grob aufgelöst dargestellt.

\ospitem{\menu{Datumsformat}}
Das Feld \menu{Datumsformat} legt fest, wie die Datumsangabe von Dateien
dargestellt werden soll. Standardmäßig ist hier das englische Format
\cmd{Y/m/d, h:ia} voreingestellt. Das deutsche Format könnnen Sie mittels
\cmd{d.m.Y H:i} einstellen. Weitere verfügbare Variablen der PHP
\cmd{date()}-Funktion finden Sie unter \cmd{http://de.php.net/date}.

\ospitem{\menu{Versteckte Kategorien für registrierte User zeigen}}
Wenn Sie eine Kategorie des Downloadmanager-Plugins verstecken, werden
die darin befindlichen Dateien normalen Besuchern nicht angezeigt. Wenn
Sie die Option \menu{Versteckte Kategorien für registrierte User zeigen}
aktivieren, können diese Dateien allen Besuchern dargestellt werden, die
im Blog als Redakteure angemeldet sind.

Über diese Option können Sie daher spezielle Downloads nur für
ausgewählte Benutzer zulassen.

\ospitem{\menu{Dateinamen anzeigen}}
Ist die Option \menu{Dateinamen anzeigen} aktiviert, werden die
ursprünglichen Dateinamen der hochgeladenen Dateien angezeigt.
Bei deaktivierter Option sehen die Besucher nur die Dateibeschreibung.

\ospitem{\menu{Anzahl der Datei-Downloads}}
Haben Sie die Option \menu{Anzahl der Datei-Downloads} aktiviert, wird in
der Kategorie-Übersicht für Besucher die Anzahl der Downloads jeder
einzelnen Datei angezeigt. Bei deaktivierter Option können Besucher die
Anzahl der Downloads jedoch nach wie vor in der Detailansicht einer Datei
einsehen. Wollen Sie die Anzahl auch dort verstecken, müssen Sie die
Smarty-Template-Datei
\index{Template-Dateien!dlmanager.filedetails.tpl}%
\cmd{dlmanager.filedetails.""tpl} bearbeiten.

\ospitem{\menu{Show filesize}}
Wenn Sie die Option \menu{Show filesize} aktivieren, wird die Dateigröße
einer Datei in der Kategorie-Übersicht für Besucher eingeblendet.

\ospitem{\menu{Datei-Datum anzeigen}}
Wenn Sie die Option \menu{Show filesize} aktivieren, wird das
Erstellungsdatum einer Datei in der Kategorie-Übersicht für Besucher
eingeblendet.

\osppagebreak

\ospitem{\menu{Bezeichnung der Dateinamen, Dateigröße, Dateidatum und}}
\ospadditem{\menu{Download-Felder}}
In diesen Konfigurationsfeldern können Sie eintragen, wie die 
jeweiligen Felder in der Downloadmanager-Übersicht für Besucher
benannt werden.
\end{ospdescription}

Die Ausgabe des Plugins erfolgt in der Besucheransicht teilweise mittels
dreier Smarty-Template-Dateien. Die Datei
\index{Template-Dateien!dlmanager.catlist.tpl}%
\cmd{dlmanager.catlist.tpl} erstellt die Kategorie-Übersicht, die Datei
\index{Template-Dateien!dlmanager.filelist.tpl}%
\cmd{dlmanager.filelist.tpl} die Datei"=Übersicht, und die Datei
\index{Template-Dateien!dlmanager.filedetails.tpl}%
\cmd{dlmanager.filedetails.tpl} regelt die Ausgabe der Download-Seite einer Datei.

Leider sind alle drei Smarty-Dateien nur teilweise vom PHP-Code des
Plugins losgelöst. Ein Großteil der HTML-Darstellungen wird nach wie vor
über das Plugin ausgegeben und kann nicht mittels Smarty angepasst
werden. Aufgrund der hohen Vermischung von Smarty- und PHP-Variablen ist
eine Dokumentation der zur Verfügung stehenden Variablen an dieser Stelle
zu komplex -- bitte schauen Sie sich die bestehenden Dateien an, um die
Verwendung der Variablen nachzuvollziehen.

Derzeit verfügt das Plugin über keinen aktiven Entwickler, es wäre für
die Zukunft jedoch schön, den PHP-Code des Plugins etwas zu entschlacken,
um neue Features leichter einbauen zu können. Sollten Sie sich angespornt
fühlen, dem Plugin etwas Gutes zu tun, melden Sie sich bitte im
Serendipity-Forum.



\subsubsection{Datenbanktabellen}

\index{Datenbank-Tabellen!serendipity\_dma\_downloadmanager\_files}%
Die Datenbanktabelle \cmd{serendipity\_dma\_downloadmanager\_files} enthält
Verweise zu den im Downloadmanager eingebundenen Dateien:
\begin{ospdescription}
\ospitem{\cmd{id}} enthält eine fortlaufende, eindeutige ID einer Datei. 
\ospitem{\cmd{catid}} enthält die einer Datei zugeordnete Kategorie.
\ospitem{\cmd{timestamp}} enthält das Hochladedatum der Datei.
\ospitem{\cmd{systemfilename}} enthält den Dateinamen.
\ospitem{\cmd{realfilename}} enthält den Dateinamen mitsamt seines Pfads.
\ospitem{\cmd{description}} enthält die Beschreibung der Datei.
\ospitem{\cmd{filesize}} enthält die Dateigröße (in Bytes).
\ospitem{\cmd{dlcount}} enthält die bisherige Anzahl der Downloads dieser Datei.
\end{ospdescription}

\index{Datenbank-Tabellen!serendipity\_dma\_downloadmanager\_categories}%
In der Tabelle \cmd{serendipity\_dma\_downloadmanager\_categories} werden die
Kategorien des Downloadmanagers (in 
Nested-Set-Struktur\footnote{Siehe \cmd{http://www.dbazine.com/oracle/or-articles/tropashko4}}) gespeichert:

\begin{ospdescription}
\ospitem{\cmd{node\_id}} enthält die ID der Kategorie.
\ospitem{\cmd{root\_id}} enthält die ID einer etwaigen Oberkategorie.
\ospitem{\cmd{payload}} enthält den Namen der Kategorie.
\ospitem{\cmd{lft}} enthält die ID der vorigen Kategorie.
\ospitem{\cmd{rgt}} enthält die ID der nächsten Kategorie.
\ospitem{\cmd{hidden}} gibt an, ob die Kategorie derzeit versteckt wird.
\end{ospdescription}

\label{aggregator}%
\index{Syndication}% 
\index{Aggregation}%
\index{Plugins!Aggregator}%
\index{Plugins!serendipity\_event\_aggregator}%
\subsection{RSS Aggregator\newline serendipity\_event\_aggregator}

Als \emph{Aggregator} bezeichnet man eine Software, die verschiedene
RSS-Feeds (siehe Seite \pageref{RSS}) zusammenführen (\emph{aggregieren}) kann.
RSS-Feeds sind die fundamentale Basis für \emph{Content Syndication},
also den Vertrieb von Inhalten.

Serendipitys \emph{RSS Aggregator}-Plugin kümmert sich darum, dass die
Meldungen von beliebigen RSS-Feeds in Ihr Blog importiert werden
können.  Gewissermaßen lässt sich ein Aggregator mit den Borg
vergleichen: Er assimiliert sämtliche Datenquellen und fügt sie einem
Kollektiv hinzu.

Ein Blog, in dem unterschiedliche Feeds zusammengeführt dargestellt
werden, bezeichnet man häufig als \emph{Planet}. In den meisten Fällen
werden solche Blogs ohne eigenständige redaktionelle Inhalte geführt, da
andernfalls die Vermischung von eigenem und fremdem Inhalt für Besucher
sehr verwirrend sein könnte.

Besonders beliebt sind thematisch zusammengeführte Blogs. Wenn Sie als
Besitzer einer Gärtnerei selbst kein Blog führen, aber den Besuchern Ihrer Webseite
einen Mehrwert anbieten wollen, könnten Sie beispielsweise ein solches
aggregiertes Blog einrichten, in dem Sie die RSS-Feeds anderer
Partner-Gärtnereien oder Ihrer Lieferanten zusammenführen.

Das Plugin importiert Artikel fremder RSS-Feeds so, als seien es ganz
normale Blog-Einträge. Daher können Sie als Administrator des Blogs
später auch Änderungen an den Blog-Einträgen vornehmen und die
jeweiligen RSS-Feeds auch eigenständigen Blog-Kategorien zuordnen.

\index{Urheberrecht}%
Bei derartiger Zusammenführung ist es vor allem wichtig, dass Sie etwaige
urheberrechtliche Fragen klären. Sie dürfen fremde RSS-Feeds nicht ohne
Zustimmung des Betreibers auf Ihren Seiten einbinden.

Sobald das RSS Aggregator-Plugin installiert ist, können Sie über den
Menüpunkt \menu{Einträge\sm RSS Aggregator} die gewünschten Feeds
einstellen.

In der Oberfläche sehen sie eine Liste, in der Sie einen neu zu
importierenden RSS-Feed festlegen können. In das Feld \menu{Feed name}
tragen Sie einen beliebigen Namen ein, der Ihnen später die
Identifizierung eines Feeds erleichert. Rechts daneben tragen Sie die URL
des jeweiligen RSS-Feeds ein, inklusive aller potenziellen URL-Parameter.
In dem Eingabefeld darunter können Sie zudem die URL der Homepage
angeben. In dem Mehrfachauswahlfeld rechts daneben legen Sie fest,
welcher Blog-Kategorie ein RSS-Feed zugeordnet werden soll. Jeder Beitrag
des RSS-Feeds wird später im Frontend innerhalb der gewählten Kategorie
dargestellt.

Ein besonderes Feld stellt die große Eingabebox \menu{Filter-Ausdruck}
dar. Dort können Sie einen regulären Ausdruck eintragen, der beim
Importieren jedes Artikels des fremden RSS-Feeds ausgewertet wird. Nur
wenn ein hier eingetragener Suchausdruck in einem Artikel vorhanden ist,
wird der Artikel ins Blog importiert, ansonsten wird er verworfen. Der Filter
wird dabei auf die Felder \emph{Titel} und \emph{Inhalt} angewendet. Dies
ist hilfreich, wenn Sie beispielsweise von der Gärtnerei \emph{Rosenrot},
die für ihre hervorragenden Blumenmesse-Berichte bekannt ist, nur die
Artikel importieren wollen, die das Schlüsselwort \emph{Messe} enthalten.

\index{Reguläre Ausdrücke}%
Da es sich bei dem Filter um einen regulären Ausdruck handelt, müssen Sie
etwaige Sonderzeichen \emph{escapen}, also einen Backslash
(\textbackslash) voranstellen.\footnote{Unter
\cmd{http://de3.php.net/manual/de/reference.pcre.pattern.syntax.php} sind solche Sonderzeichen  
aufgeführt.} Erweiterte Suchmuster wie
\cmd{Messe(bericht|report|review)(s|e)?} können ebenfalls verwendet
werden, damit Begriffe wie \emph{Messeberichte} oder
\emph{Messereviews} ebenfalls akzeptiert werden. Mehrere Filterbegriffe
können Sie durch das Tilde-Zeichen (\cmd{~}) voneinander trennen, 
die Suchwörter werden dann ODER-kombiniert. Wenn Sie also
\cmd{Messe~Rosen~Stock} eintragen, wird jeder Artikel importiert, der
die Wörter \emph{Messe}, \emph{Rosen} oder \emph{Stock} irgendwo
im Inhalt oder Betreff der RSS-Nachricht enthält.

Ein leerer Filter-Ausdruck importiert alle Einträge des RSS-Feeds.
Beachten Sie dabei, dass der RSS-Aggregator nur das importieren kann, was
der RSS-Feed anbietet. Der vollständige Artikeltext ist meist nicht in
einem RSS-Feed enthalten und kann daher auch vom Plugin nicht
ausgewertet/""eingelesen werden!

Wenn Sie alle Felder eines neuen Datensatzes ausgefüllt haben, können Sie
auf den Button \menu{Los!} klicken, um den RSS-Feed zu speichern. Danach
können Sie weitere Datensätze anlegen. Um einen bestehenden Datensatz zu
löschen, müssen Sie lediglich den Feed-Namen leeren und auf \menu{Los!}
klicken.

\index{Cronjob}%
Unterhalb jedes Datensatzes stellt das Plugin dar, wann der RSS-Feed
zuletzt importiert wurde. Dieser Importvorgang muss in einem festen
Intervall ausgeführt werden und wird gestartet, indem Sie die URL
\cmd{http://www.""example.com/serendipity/index.php?/plugin/aggregator}
aufrufen. Dies können Sie entweder manuell über Cronjobs Ihres Servers
lösen oder mittels des Serendipity Cronjob-Plugins (siehe Seite
\pageref{Cronjobsched}). Die URL können Sie auch manuell im Browser
aufrufen, um den Importvorgang einmalig auszuführen. Ohne die Ausführung
dieses Vorgangs können RSS-Feeds nicht regelmäßig importiert werden!

\index{OPML}%
Anstatt jeden Datensatz eines zu importierenden RSS-Feeds mühsam von
Hand einzupflegen, können Sie auch den Import einer \emph{OPML-Datei} von
der RSS-Aggregator-Oberfläche auslösen. Eine OPML-Datei kann von vielen
RSS-Readern erstellt werden und enthält eine Liste abonnierter RSS-Feeds
inklusive ihrer Homepage-Adresse und etwaiger Kategorisierung. Um diese
OPML-Datei zu importieren, müssen Sie die Datei auf einen Server
hochladen (beispielsweise Ihren eigenen) und die URL dieser Datei im Feld
\menu{OPML-Datei importieren} eintragen. Das Ankreuzfeld \menu{Kategorien
importieren} bestimmt, ob etwaige im RSS-Feed vorhandene
Kategorisierungen übernommen werden sollen. Nicht vorhandene Kategorien,
die in der OPML-Datei angegeben sind, legt das Plugin automatisch im Blog
an. Über das Ankreuzfeld \menu{Jeden Feed in seine eigene Kategorie
einfügen} können Sie dafür sorgen, dass jeder von der OMPL-Datei
importierte Feed seine eigene, gleichbenannte Kategorie erhält. Dies
hilft, um später die Übersicht über die importierten RSS-Feeds zu behalten.

Im Gegenzug zum Import ermöglicht der RSS-Aggregator es auch, die
von Ihnen angelegten RSS-Feeds komfortabel in einer OPML-Datei zu
speichern (Export). Diese können Sie dann in einen RSS-Reader importieren. Ein
Klick auf \menu{Export OPML!} löst diesen Exportvorgang aus, die
resultierende Datei können Sie aus Ihrem Browser heraus speichern.

Sobald Sie erstmalig den RSS-Aggregatorvorgang gestartet haben,
werden alle Artikel im RSS-Feed eingelesen und in Ihr Blog
importiert. Bei jedem späteren Vorgang werden nur noch neue Artikel
importiert.

Standardmäßig wird jeder importierte Artikel in Ihrem Blog so
eingetragen, als wäre er von Ihnen redaktionell erstellt.
Aus urheberrechtlichen Gründen ist das jedoch nicht unproblematisch,
daher sollten Sie darauf achten, den Originalautor und die URL des
RSS-Feeds mit in die Darstellung des Blog-Eintrages einzubeziehen. Für
diesen Zweck stellt das Plugin einige Smarty-Template-Variablen zur
Verfügung, die Sie nach Belieben in die Datei \cmd{entries.tpl} Ihres
gewählten Templates einsetzen können (siehe auch Seite
\pageref{entries.tpl}).
Die zur Verfügung stehenden Smarty-Variablen sind:

\begin{ospdescription}
\index{Template-Variablen!\$entry.properties.ep\_aggregator\_feedname}%
\ospitem{\cmd{\{\$entry.properties.ep\_aggregator\_feedname\}}} enthält
den hinterlegten Namen des RSS-Feeds, aus dem der jeweilige Artikel
stammt.

\index{Template-Variablen!\$entry.properties.ep\_aggregator\_feedurl}%
\ospitem{\cmd{\{\$entry.properties.ep\_aggregator\_feedurl\}}} enthält
die hinterlegte URL des Quell-RSS-Feeds.

\index{Template-Variablen!\$entry.properties.ep\_aggregator\_htmlurl}%
\ospitem{\cmd{\{\$entry.properties.ep\_aggregator\_htmlurl\}}} enthält
die hinterlegte URL des Quell-Blogs.

\index{Template-Variablen!\$entry.properties.ep\_aggregator\_articleurl}%
\ospitem{\cmd{\{\$entry.properties.ep\_aggregator\_articleurl\}}} enthält
die hinterlegte URL des Artikels aus dem RSS-Feed.

\index{Template-Variablen!\$entry.properties.ep\_aggregator\_author}%
\ospitem{\cmd{\{\$entry.properties.ep\_aggregator\_author\}}} enthält den
Originalautornamen des Artikels.
\end{ospdescription}

Empfehlenswert ist daher, wenn Sie in der Template-Datei \cmd{entries.tpl}
ober- oder unterhalb der Ausgabe von \cmd{\{\$entry.body\}} Folgendes
einfügen:

\input{snippets/aggregator.tex}

Ein weiteres Beispiel, wie eine Änderung der \cmd{entries.tpl} aussehen
kann, wird in der Datei \cmd{theme-patch.diff} des Aggregator-Plugins
demonstriert.

Folgende Konfigurationsoptionen bietet das Plugin:

\begin{ospdescription}
\index{Onyx}%
\index{MagpieRSS}%
\ospitem{\menu{RSS Parser wählen}}
Das RSS-Aggregator-Plugin benötigt zum Importieren der RSS-Feeds eine
Softwarebibliothek. Sie können auswählen, ob dafür die bei Serendipity
mitgelieferte Bibliothek \cmd{Onyx} verwendet werden soll oder die vom
Plugin bevorzugte Bibliothek \cmd{MagpieRSS}.

Onyx wird heutzutage nicht mehr weiterentwickelt, ist aber stabil und bei
Serendipity mit allen notwendigen Funktionen zur Zeichensatzkonvertierung
aufgewertet. Onyx ist zudem zur BSD-Lizenz kompatibel.

MagpieRSS unterstützt im Gegensatz zu Onyx nicht nur RSS-Formate,
sondern auch das neuere Atom-Feedformat. MagpieRSS ist GPL"=lizenziert.

Wenn Sie den Aggregator in einem nichtkommerziellen Projekt einsetzen,
ist der Einsatz von MagpieRSS zu bevorzugen.

\ospitem{\menu{Artikel entfernen}}
Um die Artikeldatenbank des Blogs nicht unnötig immer größer werden zu
lassen, kann das Aggregator-Plugin automatisch alle Artikel löschen, die
älter als das hier festgelegte Limit (in Tagen) sind. Die Eingabe der Zahl
0 deaktiviert das automatische Entfernen.

\index{Prüfsummen}%
\ospitem{\menu{Prüfsummen entfernen}}
Um zu erkennen, ob das Plugin bestimmte Artikel bereits importiert hat,
verwaltet es intern eine Prüfsummenliste. Da diese Prüfsummen ebenfalls
recht groß werden können, sollte man sie automatisch nach einer gewissen
Zeit löschen (standardmäßig 90 Tage).

Sie sollten unbedingt darauf achten, dass Sie die Prüfsummen länger
aufbewahren als die Artikel selbst -- andernfalls könnte es zu doppelt
importierten Artikeln kommen, da das Plugin möglicherweise nicht mehr
zuordnen kann, ob ein Artikel bereits importiert wurde.

\ospitem{\menu{Aktualisierungen ignorieren}}
Wenn ein RSS-Artikel einmal importiert wurde, prüft Serendipity dennoch
bei jedem neuen RSS-Importvorgang, ob sich ein derartiger Artikel
möglicherweise verändert hat. Wenn der Original-Redakteur beispielsweise
Rechtschreibfehler korrigiert hat, kann das Plugin so den Artikel auf
Ihrem Blog ebenfalls korrigieren.

Wenn Sie die Option \menu{Aktualisierungen ignorieren} aktivieren, wird
das Plugin niemals bereits importierte Artikel nachträglich verändern.

\ospitem{\menu{Nicht mehr verkettete Einträge löschen}}
Wenn Sie die Option \menu{Nicht mehr verkettete Einträge löschen}
aktiviert haben und einen RSS-Feed aus dem Aggregator löschen, werden
standardmäßig alle diesem Feed zugehörigen Artikel gelöscht.

Wenn Sie jedoch die alten Einträge aus historischen Gründen sichern
wollen, sollten Sie diese Option deaktivieren.

\ospitem{\menu{Kommentare für diesen Eintrag zulassen}}
Da importierte RSS-Artikel üblicherweise nicht in einem aggregierenden
Blog kommentiert werden (sondern nur im Original-Artikel), ist es
sinnvoll, dass Kommentare zu derartigen Artikeln in Ihrem Blog nicht
zugelassen sind.

Wenn Sie dennoch Kommentare zulassen wollen, müssen Sie die Option
\menu{Kommentare für diesen Eintrag zulassen} aktivieren.

\ospitem{\menu{Debugging-Output}}
Das Aggregator-Plugin kann bei Problemen mit dem Importvorgang detaillierte
Statusmeldungen ausgeben. Um diese beim Importvorgang zu sehen, müssen
Sie die Option \menu{Debugging-Output} aktivieren.

\end{ospdescription}

\subsubsection{Datenbanktabelle}

\index{Datenbank-Tabellen!serendipity\_aggregator\_feeds}%
Die Datenbanktabelle \cmd{serendipity\_aggregator\_feeds} enthält eine Liste der
Feeds, die vom Aggregator gelesen werden sollen:

\begin{ospdescription}
\ospitem{\cmd{feedid}} enthält die fortlaufende ID eines Feeds.
\ospitem{\cmd{feedname}} enthält den im Backend eingegebenen Namen des Feeds.
\ospitem{\cmd{feedurl}} enthält die URL des Feeds.
\ospitem{\cmd{htmlurl}} enthält die zugeörige Homepage der Seite.
\ospitem{\cmd{last\_update}} enthält das Datum der letzten Aktualisierung dieses Feeds.
\ospitem{\cmd{charset}} enthält den Zeichensatz des Feeds.
\end{ospdescription}

\index{Datenbank-Tabellen!serendipity\_aggregator\_md5}%
In der Tabelle \cmd{serendipity\_aggregator\_md5} werden Hash-Werte gespeichert,
die jeden Artikel mit einer eindeutigen Prüfsumme verbinden. Durch Abgleich
dieser Datenbank kann beim Importieren der Feeds geprüft werden, ob ein Artikel
bereits in der Datenbank vorliegt.

\begin{ospdescription}
\ospitem{\cmd{entryid}} enthält die ID des Blog-Artikels, für den die Prüfsumme
erstellt wurde.
\ospitem{\cmd{md5}} enthält den 32 Zeichen langen MD5-Hashcode des Artikeltexts.
\ospitem{\cmd{timestamp}} enthält das Datum, an dem der MD5-Hash erstellt wurde.
\end{ospdescription}

\index{Datenbank-Tabellen!serendipity\_aggregator\_feedcat}%
In der Tabelle \cmd{serendipity\_feedcat} wird gespeichert, welcher
Blog"=Kategorie (\cmd{categoryid}) der jeweilige Feed (\cmd{feedid}) zugeordnet
sein soll.

\index{Moblog}%
\index{Mobiles Bloggen}%
\index{Popfetcher}%
\index{E-Mail!abrufen}%
\label{serendipity-event-popfetcher}%
\index{Plugins!POPfetcher}%
\index{Plugins!serendipity\_event\_popfetcher}%
\subsection{POPfetcher\newline serendipity\_event\_popfetcher}

Ähnlich wie das \emph{RSS Aggregator}-Plugin dient der \emph{POPfetcher}
dem Import von Artikeln in Ihr Blog.

Der \emph{POPfetcher} kann automatisch einen E-Mail-Account mittels
POP-Server abfragen und E-Mails zu dieser Adresse als Blog-Eintrag
übernehmen. So können Sie unterwegs Artikel schreiben (\emph{Moblogging})
oder auch bequem vom Handy/PDA ohne Zugriff auf das Serendipity-Backend
das Blog mit Inhalten füllen.

\index{Cronjob}%
Ähnlich wie das Aggregator-Plugin kann der POPfetcher sich systembedingt
nicht selber aufrufen. Daher müssen Sie den E-Mail-Abruf entweder manuell
ausführen oder über einen zentralen Cronjob. Auch das Serendipity
Cronjob-Plugin (siehe Seite \pageref{Cronjobsched}) unterstützt den
POPfetcher zum regelmäßigen Abruf von E-Mail-Konten.

Der POPfetcher kann einen gezielten E-Mail-Account abrufen, der dem
Plugin als \emph{Empfängeradresse} dient. Obwohl das Plugin sich so
konfigurieren lässt, dass es nur die E-Mails bestimmter Absender
akzeptiert, sollten Sie die Empfängeradresse des Plugins streng
geheim halten. Ansonsten könnte es möglicherweise fremden Personen
gelingen, Artikel in Ihr Blog zu schleusen.

E-Mails können zudem Dateianhänge enthalten, die das Plugin automatisch
in Artikeln und der Mediendatenbank einträgt.

Da der Importvorgang des POPfetchers automatisiert abläuft, lassen sich
sämtliche Einstellungen ausschließlich über die Plugin-Konfiguration
vornehmen:

\begin{ospdescription}
\ospitem{\menu{Plugin-Methode, Name für externen Aufruf}}
Der POPfetcher kann auf zwei Arten dazu angewiesen werden, Ihr Postfach
abzurufen: Zum einen die \menu{interne} Methode. Hierbei müssen Sie als
eingeloggter Redakteur auf den Menüpunkt \menu{Einträge\sm POPfetcher}
klicken, um den Abruf zu starten.

Wesentlich komfortabler ist jedoch die \menu{externe} Methode. Hierbei
rufen Sie eine URL auf, die Sie über die Option \menu{Name für externen
Aufruf} festgelegt haben. Standardmäßig wäre dies
\cmd{http://www.example.""com/serendipity/index.php?/plugin/popfetcher}.
Die URL sollten Sie aus einer möglichst nicht zu ratenden
Buchstabenfolge zusammensetzen, damit Ihre Blog-Besucher den Aufruf des
POPfetchers nicht (böswillig) ausführen können. Das wäre zwar nicht
weiter tragisch, da ein derart gestarteter Aufruf nur das von Ihnen
festgelegte Postfach abruft, aber es könnte durchaus zu
Performance-Problemen bei häufigem Aufruf kommen.

Die derart konfigurierte externe URL können Sie beispielsweise in einem
Cronjob Ihres Servers automatisiert alle X Stunden aufrufen,
beispielsweise mittels \cmd{wget 'http://www.example.com/serendi\-pi\-ty/index.php?/plugin/popfetcher'}.

Wenn Sie das Plugin über das Serendipity-Cronjob-Plugin ausführen, ist
diese Einstellung irrelevant.

\ospitem{\menu{Autor}}
Die via E-Mail geschriebenen Artikel können vom Plugin nicht automatisch
bestehenden Blog-Redakteuren zugeordnet werden. Daher müssen Sie über die
Option \menu{Autor} festlegen, welchem Blog-Redakteur die Artikel
zugewiesen werden sollen.
Das bedeutet, dass sämtliche via E-Mail eingelieferten Artikel immer
demselben Autor gehören werden, egal von welcher E-Mail-Adresse diese
stammen.

Andernfalls können Sie in dem Auswahlfeld den Wert \menu{Lookup by email}
wählen. Dann wird der Autor anhand seiner Absenderadresse zugewiesen, falls
eine übereinstimmende Redakteursadresse in der Redakteursdatenbank vorliegt. 

\ospitem{\menu{Mail Server, POP3 User, Passwort, POP3 port, APOP}}
Tragen Sie in diese Felder die Zugangsdaten zu Ihrem E-Mail-Postfach ein.
Wenn Sie einen Server mit POP3 über SSL benutzen wollen, müssen Sie den
POP3-Port 995 eintragen, und die PHP-Installation des Webservers muss das
\emph{openssl}-Modul aktiviert haben.

Wenn Ihr Mailserver APOP unterstützt, kann das Passwort bei aktivierter
\menu{APOP}-Option speziell verschlüsselt übertragen werden. Ohne
APOP-Unterstützung wird ein E-Mail-Passwort im Klartext an den Server
übertragen, was ein gewisses Sicherheitsrisiko darstellt.

\ospitem{\menu{E-Mail-Absender}}
Wenn der POPfetcher nur E-Mails von einem bestimmten Absender akzeptieren
darf, können Sie diesen Absender im Feld \menu{E-Mail Absender}
eintragen. Hier müssen Sie die vollständige E-Mail-Adresse eintragen, wie
sie im \emph{From-Header} der E-Mail erscheint. Die meisten E-Mail-Programme
geben solche Adressen in der Form \cmd{"{}Garvin Hicking"{}
<mail@example.com>} ein; die Adresse muss daher auch in exakt dieser
Notation im Eingabefeld eingetragen werden.

\ospitem{\menu{Kategorie}}
Die via E-Mail abgeholten Einträge können Sie einer festen Blog-Kategorie
zuordnen. Dazu tragen Sie im Feld \menu{Kategorie} die Kategorie-ID ein
(siehe Seite \pageref{Kategorie-ID ermitteln}).

Sie können auch pro E-Mail eine eigene Kategorie festlegen, indem Sie im
Betreff der E-Mail den Namen (nicht die ID!) der gewünschten Kategorie in
eckigen Klammern voranstellen. Mehrere Kategorienamen können Sie mittels
Semikolon (\cmd{;}) voneinander trennen, um den Eintrag jeder
aufgeführten Kategorie zuzuordnen.

Eine E-Mail mit dem Betreff \cmd{[Sport] FC Köln in Regionalliga
abgestiegen} würde einen Blog-Artikel mit dem Betreff \emph{FC Köln in
Regionalliga abgestiegen} in der Kategorie \emph{Sport} veröffentlichen.

\ospitem{\menu{Upload-Verzeichnis}}
Dateianhänge einer E-Mail können vom POPfetcher automatisch ausgegliedert
und in einem Verzeichnis auf dem Webserver gespeichert werden. So können
Sie beispielsweise Handyfotos leicht mittels E-Mail-Versand in Ihr Blog
hochladen.

Das Zielverzeichnis für diese Dateien legen Sie mit 
\menu{Upload Verzeichnis} fest. Als Stammverzeichnis dient hierbei das in
der zentralen Serendipity"=Konfiguration festgelegte Upload-Verzeichnis
(\cmd{uploads}). Wenn Sie hier ein Unterverzeichnis vorgeben
(\cmd{Urlaubsbilder/}), müssen Sie sicherstellen, dass das gewünschte
Verzeichnis bereits existiert. Das Verzeichnis können Sie über den
Menüpunkt \menu{Mediendatenbank\sm Verzeichnisse verwalten} oder mittels
FTP anlegen.

\ospitem{\menu{Blog}}
Nur wenn Sie die Option \menu{Blog} aktivieren, wird der Inhaltstext
einer E-Mail als Blog-Artikel angelegt.
Wenn Sie die Option deaktivieren, werden nur Dateianhänge der E-Mail in
der Mediendatenbank gespeichert.

Diese Option ist besonders dann sinnvoll, wenn Sie den POPfetcher nur
dazu verwenden wollen, um Bilder mittels Ihres Handys automatisch in das
Blog hochzuladen und sie erst später in einen Blog-Artikel einzufügen.

\ospitem{\menu{Use plaintext attachments as entry body}}
Einige E-Mail-Programme oder Handys verschicken die Texte einer E-Mail
als Dateianhang. Damit diese Anhänge dekodiert und als
Inhaltstext Ihrer Blog-Artikel verwendet werden können, müssen Sie die
Option \menu{Use plaintext attachments as entry body} aktivieren.

Bei deaktivierter Option wird ein derartiger Dateianhang genauso wie eine
PDF- oder Bilddatei behandelt und nur ein Link zu der Mediendatenbank
für diese Datei in den Blog-Artikel eingebunden.

\ospitem{\menu{First text attachment is entry body, the rest extended}}
Standardmäßig wird der POPfetcher alle Texte der E-Mail zusammenfassen
und als Artikeltext für den Blog-Eintrag verwenden. Somit ist sämtlicher
Text der E-Mail für den Besucher in der Blog"=Übersichtsseite lesbar.

Wenn Sie jedoch längere E-Mails in den dafür vorgesehenen
\emph{erweiterten Eintrag} (siehe Seite \pageref{erweiterter-eintrag})
aufteilen wollen, können Sie die Option \menu{First text attachment is
entry body, the rest extended} aktivieren. Diese Option sorgt dafür, dass
nur der erste Text-Dateianhang als Grundtext verwendet und alles
Weitere im erweiterten Eintrag gespeichert wird.

Abgesehen von dieser Trennung durch Dateianhänge können Sie E-Mail-Texte
auch mit einem manuellen Trennzeichen aufteilen, siehe die Option
\menu{Spezieller Text, der Text und erweiterten Eintrag einer E-Mail
aufteilt}

\ospitem{\menu{Werbung entfernen}}
Der Versand von E-Mails über das Handy führt oft dazu, dass
Mobilfunkbetreiber wie O$_2$, E-Plus und die Telekom Werbung in die E-Mail
einfügen. Solche Werbung ist in Blog-Artikeln unerwünscht.

Die Option \menu{Werbung entfernen} kann automatisch die Werbung aus
Mails von T-Mobile und O$_2$ entfernen. Da die Art der Werbeeinbindung jedoch in
Zukunft variieren könnte, ist diese Option möglicherweise nicht immer
einsatzfähig.

\ospitem{\menu{Text nach speziellen Buchstaben abschneiden}}
Etwas wirksamer im Umgang mit zu entfernender Werbung ist die Option
\menu{Text nach speziellen Buchstaben abschneiden}. Tragen Sie hier eine
beliebige Zeichenkette ein, die Sie auch später in Ihren E-Mails
verwenden, und der POPfetcher wird alle Texte nach der konfigurierten
Zeichenkette löschen.

Wenn Sie hier beispielsweise den Text \emph{overandout} eintragen und
Ihre Handy-E-Mail später ebenfalls mit \emph{overandout} beenden, kann
sämtliche Werbung, die der Mobilfunkbetreiber dahinter einfügt, einfach
ignoriert werden.

Sie sollten hier nur Text eintragen, der sonst in Ihrer E-Mail nicht
vorkommt, um Textverlust zu vermeiden.

\ospitem{\menu{Entferne alle HTML-Tags aus den Mails}}
Grundsätzlich können Sie auch HTML-E-Mails an den POPfetcher verschicken,
der diese Formatierung auch ins Blog übernimmt. Da dies jedoch auch zu
potenziellen Sicherheitslöchern durch JavaScript führen kann, sollten Sie
die HTML-Tags mit dieser Option entfernen, wenn Sie die Inhalte einer
E-Mail nicht völlig kontrollieren können.

\ospitem{\menu{Spezieller Text, der Text und erweiterten Eintrag einer E-Mail
aufteilt}}
Wenn Sie eine längere E-Mail in Artikeltext und erweiterten Eintrag
aufteilen wollen, können Sie ein beliebiges Trennzeichen formulieren.
Sobald dieses im Text Ihrer E-Mail auftaucht, wird sämtlicher Folgetext in
den \emph{erweiterten Eintrag} des Blog-Artikels übernommen.

Achten Sie darauf, dass das hier festgelegte Wort einmalig in der E-Mail
vorkommen sollte. Wenn Sie hier beispielsweise \emph{xxx-TRENNER-xxx}
festlegen, könnten Sie eine E-Mail wie diese schreiben:

\begin{ospcode}
Liebe Blog-Leser,

hier meldet sich eure Uschi vom Hauskatzenzüchterverein. Gerade 
bin ich auf der Showbühne und schaue begeistert dem Auftritt der 
Pussy Cat Dolls zu. Meinen ausführlichen Messebericht findet ihr, 
wenn ihr auf "Weiterlesen" klickt!

xxx-TRENNER-xxx

Die schönste Katze der diesjährigen Züchtung, wenn nicht die 
schönste Katze seit Bestehen unserer Hausmesse, war diesmal der 
Kater "Giesbert" aus NRW \ldots
\end{ospcode}

\ospitem{\menu{Define a string which indicates the text to capture}}
Wenn Ihre E-Mails besonders viel Werbung oder HTML-Dateianhänge enthalten,
könnte der POPfetcher möglicherweise überfordert damit sein, alle Inhalte
korrekt zu erkennen.

Als letzten Ausweg können Sie daher eine besondere Zeichenkette im
Eingabefeld \menu{Define a string which indicates the text to capture}
festlegen. In Ihrer E-Mail können Sie dann diese Zeichenkette \emph{vor}
und \emph{hinter} den zu bloggenden Text schreiben. Alles dazwischen
wird vom POPfetcher als Text für den Blog-Artikel verwendet.

Auch hier sollten Sie sicherstellen, dass die Zeichenkette in Ihrer
E-Mail einmalig ist.

\ospitem{\menu{Publizieren}}
Mit der Option \menu{Publizieren} legen Sie fest, ob ein via POPfetcher
eingestellter Artikel direkt veröffentlicht oder nur als Entwurf
gespeichert wird.

Da aufgrund der vielen unterschiedlichen E-Mail-Formate nie
sichergestellt werden kann, ob die spätere E-Mail exakt Ihren
Vorstellungen entspricht, kann es unter Umständen besser sein, einen
Artikel vor der Veröffentlichung im Blog durch einen Redakteur prüfen zu
lassen.

Zwar verlieren Sie so die Möglichkeit, spontan unterwegs eine E-Mail
online ins Blog zu stellen, aber Sie gewinnen so die absolute Kontrolle über
die Inhalte Ihres Blogs.

\ospitem{\menu{Kommentare und Trackbacks dieses Eintrags werden moderiert,}}
\ospadditem{\menu{Kommentare für diesen Eintrag zulassen}}
Mit diesen beiden Optionen legen Sie fest, ob ein via POPfetcher
veröffentlichter Artikel von Besuchern kommentiert werden darf und ob
diese Kommentare standardmäßig moderiert werden sollen (siehe Kapitel
\ref{personal-commentnotifications} ab Seite
\pageref{personal-commentnotifications}).

\ospitem{\menu{Mail löschen}}
Wenn der POPfetcher eine E-Mail abgeholt hat, wird sie standardmäßig vom
Server gelöscht, damit sie beim nächsten Importvorgang nicht erneut
gelesen wird.

Zu Testzwecken ist es jedoch praktisch, unterschiedliche
Plugin"=Einstellungen mit derselben E-Mail auszuprobieren, um die optimalen
Einstellungen zu finden. Während dieser Testphase sollten Sie E-Mails
nicht vom Server löschen.

\ospitem{\menu{Timeout}}
Mit der Option \menu{Timeout} legen Sie eine Zeitspanne in Sekunden fest,
nach deren Ablauf der POPfetcher eine fehlgeschlagene Verbindung zum
Mailserver abbrechen soll.

\end{ospdescription}

Das Plugin ist speziell auf die Verarbeitung von E-Mails der Provider O$_2$,
T-Mobile, Sprint PCS, Cingular und Verizon optimiert. Dateianhänge mit
den Endungen \cmd{pif, vbs, scr, bat, com, exe} werden vom POPfetcher
ignoriert, da es sich dabei meist um E-Mail-Viren handelt. Diese Dateiliste ist
in der Variable \cmd{\$list\_virus} in der Datei
\cmd{serendipity\_event\_popfet\-cher.php} manuell erweiterbar.

Als Bilder erkennt das Plugin die Dateiendungen \cmd{gif, jpg, png, jpeg}
(Variable \cmd{\$list\_imageext}) an, als Content-Type von Dateianhängen
wird \cmd{jpg, jpeg, gif, png, x-png, jpeg} (Variable
\cmd{\$list\_imagetype}) akzeptiert. Dateien mit der Endung \cmd{smil}
(Variable \cmd{\$list\_ignore}) ignoriert das Plugin.

Um gegen neue Arten von E-Mail-Werbung oder problematische E-Mail-Formate
vorzugehen, können Entwickler über die Variable \cmd{\$debug\_file} testweise
eine E-Mail-Dumpdatei einlesen und deren Import implementieren. Sie können gerne
im Serendipity-Forum nachfragen, wenn Sie Probleme mit dem Format Ihrer
E-Mails haben.

\index{Plugins!TinyMCE}%
\index{Plugins!serendipity\_event\_tinymce}%
\subsection{Uses TinyMCE as WYSIWYG editor\newline serendipity\_event\_tinymce}
\index{TinyMCE}%
\index{WYSIWYG-Editoren!alternative}%
\index{HTMLArea}%

Serendipity wird standardmäßig mit dem WYSIWYG-Editor \emph{HTMLArea}
ausgeliefert. Dieser Editor läuft relativ problemlos mit aktuellen
Browsern (Internet Explorer, Firefox, Safari, Konqueror), wird aber seit
einiger Zeit nicht mehr aktiv weiterentwickelt.

An der Qualität verschiedener WYSIWYG-Editoren scheiden sich
die Geister -- grundsätzlich ist es ein beinahe unmögliches Ziel,
vollständige WYSIWYG-Fähigkeiten browserübergreifend zu verwirklichen.
Gerade zwischen Internet Explorer und Firefox
unterscheiden sich die technischen Implementationen fast grundlegend, so
dass ein überall gleich arbeitender WYSIWYG-Editor wohl noch lange ein
Zukunftstraum bleiben wird.

Dennoch arbeiten viele Entwickler unbeirrt an diesem hehren Ziel und
bringen häufige Updates ihrer Editoren heraus, die stetig stabiler
werden. Das Kernproblem bei WYSIWYG-Editoren ist, dass diese häufig
ungültigen HTML-Code produzieren, Sonderzeichen schlucken oder beim
Verschieben von Bildern Abstürze hervorrufen. Davon bleibt auch der interne
Serendipity-Editor leider nicht verschont.

Serendipity geht daher grundsätzlich den Weg, dass alternative
WYSIWYG-Editoren eingebunden werden können. Dazu zählen
TinyMCE\footnote{\cmd{http://tinymce.moxiecode.com/}},
FCKEditor\footnote{\cmd{http://www.fckeditor.net/}} und
Xinha\footnote{\cmd{http://xinha.webfactional.com}}. Für alle drei
Editoren sind externe Plugins verfügbar.

Das schwierigste Unterfangen bei der Verwendung externer
WYSIWYG"=Edi\-tor-Plugins bei Serendipity ist, dass einigen die Unterstützung
der Mediendatenbank fehlt oder die Integration in weitere Plugins (wie
den HTML-Klotz oder Statische Seiten) nicht vorhanden ist. TinyMCE ist
hier am weitesten fortgeschritten und wird daher an dieser Stelle exemplarisch
beschrieben. Die Verwendung der anderen WYSIWYG-Editor-Plugins ist jedoch
im Grundsatz gleich.

Um einen externen WYSIWYG-Editor wie TinyMCE verwenden zu können, müssen
Sie drei Dinge durchführen: Erstens müssen Sie in Ihren persönlichen
Einstellungen die Verwendung des WYSIWYG-Editors aktivieren und zweitens
das Serendipity-Plugin installieren. Als Letztes müssen Sie den jeweiligen 
WYSIWYG-Editor manuell herunterladen und in das Plugin"=Verzeichnis kopieren. 
Die WYSIWYG-Editoren selbst sind \emph{nicht} Bestandteil des Serendipity-Plugins, 
da sie sich zum einen zu häufig ändern und zum anderen aufgrund ihrer Dateigröße den
Rahmen eines Serendipity-Plugins sprengen würden.

Sobald Sie das TinyMCE-Plugin heruntergeladen haben, ist dieses im
Verzeichnis \cmd{/plugins/serendipity\_event\_tinymce/} vorhanden.
Besuchen Sie nun die TinyMCE-Downloadseite.\footnote{\cmd{http://tinymce.moxiecode.com/download.php}} Laden Sie dort die
aktuelle Version von TinyMCE herunter. Entpacken Sie danach die ZIP-Datei
und laden Sie das entstandene Verzeichnis \cmd{tinymce} in Ihr
Plugin-Verzeichnis auf dem Serendipity-Server.

Danach sollten Sie eine Datei wie
\cmd{/plugins/serendipity\_event\_tiny\-mce/tinymce/jscripts/tiny\_mce/tiny\_mce.js}
besitzen. Lassen Sie\osplinebreak{} sich von der leider tief verschachtelten
Verzeichnisstruktur nicht irritieren.

Abgesehen von dem Basispaket benötigen Sie noch den TinyMCE compressor
PHP. Dieser befindet sich ebenfalls auf der TinyMCE-Downloadseite. Auch
diesen müssen Sie herunterladen und entpacken. Die beiden Dateien
\cmd{tiny\_mce\_gzip.js} und \cmd{tiny\_mce\_gzip.php} laden Sie nun auf
Ihren Serendipity-Server in das Verzeichnis
\cmd{/plugins/serendipity\_event\_ti\-nymce/tinymce/jscripts/tiny\_mce}
hoch.

Je nachdem, welche TinyMCE-Sprachversion Sie benutzen wollen, müssen Sie
eventuell noch weitere Dateien herunterladen. Optional können Sie das
TinyMCE-Tool namens \emph{iManager} installieren, das eine eigenständige
Mediendatenbank (inklusive Bildbearbeitung) ermöglicht. Die hierfür
notwendigen Schritte werden in der Konfigurationsoberfläche des
Serendipity-TinyMCE-Plugins aufgeführt.

Nachdem nun alle notwendigen Dateien erfolgreich hochgeladen wurden,
können Sie TinyMCE das erste Mal benutzen. Rufen Sie dazu die bekannte
Oberfläche zum Erstellen eines Eintrages auf.

Das TinyMCE-Plugin ist seinerseits stark modular aufgebaut. Alle
Bestandteile des Editors können nach Belieben zusammengewürfelt werden.
Viele der Einstellungsmöglichkeiten werden Ihnen über die
Konfigurationsoptionen des Plugins angeboten:

\begin{ospdescription}
\ospitem{\menu{iManager Tool benutzen}}
Wenn Sie den iManager benutzen wollen, müssen Sie diesen nach der
eigenständigen Installation über den Menüpunkt \menu{iManager Tool
benutzen} aktivieren.

\ospitem{\menu{Zusätzliche TinyMCE Plugins, Knopfleiste 1, 2 und 3}}
In dieser Eingabebox können Sie die TinyMCE-Plugins eintragen, die Sie
verwenden wollen. Auch die Reihenfolge der Buttons im TinyMCE-Plugin
richtet sich nach dieser Eingabe.

Wenn Sie beispielsweise mit dem TinyMCE-Plugin keine Änderung der
Textrichtung vornehmen wollen, können Sie das Plugin
\menu{directionality} einfach aus der Liste entfernen. Eine vollständige
Liste, welches Plugin welcher Funktionalität dient, finden Sie auf der
Homepage von TinyMCE.

Das Pipe-Sonderzeichen (\cmd{|}) können Sie in der Definition der
Knopfleisten dazu benutzen, um einen Zeilenumbruch zu erreichen.

\ospitem{\menu{Relative URLs erzeugen}}
TinyMCE versucht standardmäßig alle von Ihnen eingegebenen Hyperlinks in
relative URLs umzuwandeln. Aus 
\cmd{http://www.example.""com/serendipity/index.php} wird so
\cmd{/serendipity/""index.php}. Grundsätzlich hat dies den Vorteil, dass
relative URLs beim Umzug Ihres Blogs auf einen anderen Server nicht
geändert werden müssen.

Bei der Benutzung der Mediendatenbank von Serendipity sind solche
relativen URLs jedoch eher problematisch. Daher ist es eher zu empfehlen,
die Option \menu{Relative URLs erzeugen} zu deaktivieren, um potenziellen
Problemen bei der Einbindung von Podcasts, RSS-Feeds und Ähnlichem zu
entgehen.

\ospitem{\menu{HTML verifizieren/korrigieren}}
TinyMCE kann ungültigen HTML-Code Ihrer Artikel automatisch korrigieren.
Theoretisch ist dies eine tolle Funktionalität, praktisch scheitert
die Korrektur jedoch oft an dem, was TinyMCE als gültig und ungültig
erkennt. HTML-Tags, die TinyMCE nicht anerkennt, werden so kurzerhand
entfernt.

Gerade bei der Einbindung von YouTube-Links oder OBJECT/EMBED-HTML-Tags
kann dies dazu führen, dass gültiger HTML-Code von TinyMCE einfach
stillschweigend entfernt wird. Noch problematischer wird das Vorgehen
dadurch, dass abhängig von Ihrem Browser (Microsoft Internet Explorer
oder Firefox) unterschiedliche HTML-Tags entfernt werden.

Auch hier empfehlen wir daher, die Option \menu{HTML verifizieren/""korrigieren}
zu deaktivieren, wenn Sie stellenweise selbst HTML-Code eingeben.

\ospitem{\menu{Code säubern}}
Im Gegensatz zur Option \menu{HTML verifizieren}, die sich nur um das
Entfernen ungültiger HTML-Tags kümmert, kann die Option \menu{Code
säubern} TinyMCE dazu anweisen, eventuell ungültige HTML-Konstrukte zu
beheben. Darunter fallen beispielsweise falsche Sonderzeichen, fehlende
schließende Tags oder anderweitige ungültige Verschachtelung.

Dieser Säuberung kann man normalerweise getrost vertrauen, da sie
tatsächlich der Gültigkeit Ihrer Artikel dienlich ist. Lediglich wenn Sie
selber absolute Kontrolle über den HTML-Code haben wollen, sollten Sie
diese Option deaktivieren. Dann jedoch wäre es generell eher zu
empfehlen, vollständig auf WYSIWYG zu verzichten, um die größtmögliche
Flexibilität zu erlangen.

\ospitem{\menu{Mozilla Rechtschreibhilfe}}
Seit einigen Versionen ermöglicht der Mozilla Firefox Browser die
Rechtschreibprüfung Ihrer Eingaben in beliebigen Textfeldern.
Da TinyMCE über eine eigene (optionale) Rechtschreibprüfung verfügt,
deaktiviert TinyMCE standardmäßig die Prüfung der Mozilla
Rechtschreibhilfe. Wenn Sie diese jedoch gerne verwenden möchten, können
Sie die Option \menu{Mozilla Rechtschreibhilfe} aktivieren.

\ospitem{\menu{Relativer HTTP Pfad des Plugins}}
Damit das Serendipity-Plugin den Quellcode des TinyMCE-Editors korrekt
einbinden kann, benötigt es den relativen Pfad zum TinyMCE-Verzeichnis ab
dem Serendipity-Stammverzeichnis.

Bei normalen Installationen können Sie hier stets den Standardwert
\cmd{plugins/serendipity\_event\_tinymce/} beibehalten. Nur wenn Sie
symbolische Links oder Ähnliches verwenden, ist eine Anpassung dieser
Konfigurationsoption angebracht.

\end{ospdescription}

\label{xmlrpc}%
\index{Plugins!Einträge via XML-RPC erstellen}%
\index{Plugins!serendipity\_event\_xmlrpc}%
\subsection{Einträge via XML-RPC erstellen\newline serendipity\_event\_xmlrpc}

Inzwischen haben Sie bereits gelernt, Artikel in Serendipity über das
Backend, eine E-Mail und das POPfetcher-Plugin und auch über den Import
von RSS-Feeds zu erstellen.

\index{XML-RPC!API}%
Wem das noch nicht genug ist, der kann sich einer weiteren beliebten Methode
bedienen: der XML-RPC API.

Was dank Akronymen erstmal kryptisch klingt, ist recht simpel: Über eine
technische Spezifikation kann eine beliebige Software auf Ihrem Computer
(dem Client) mit Serendipity (dem Server) interagieren.

So können Sie einen Artikel mit der Software (dem sogenannten \emph{Blog
Client}) erstellen und dann an das Serendipity-Blog übermitteln. Durch
derartige Software müssen Sie keinen Internet-Browser mehr benutzen.

Die Vorteile sind: Sie können Artikel auch offline erstellen und
formatieren, können diese lokal (wie ein Office-Dokument) speichern und
oft mit leistungsfähigeren WYSIWYG-Editoren, als es im Browser möglich ist,
ein komplexeres Layout umsetzen. Blog-Editoren sind häufig optisch sehr
simpel gehalten und sind somit für manche Zielgruppen zugänglicher als
die Bedienung der browserbasierten Oberfläche Serendipitys.

\index{Blogdesk}%
\index{LiveWrite}%
\index{BlogJet}%
\index{Ecto}%
\index{w.bloggar}%
Abhängig von Ihrem Betriebssystem gibt es mehrere Editoren:
Blogdesk\footnote{\cmd{http://www.blogdesk.org/}},
BlogJet\footnote{\cmd{http://www.codingrobots.com/blogjet/}},
Ecto\footnote{\cmd{http://ecto.kung-foo.tv}} oder auch
w.bloggar\footnote{\cmd{http://wbloggar.com}}.

Als technische Spezifikation (die API) unterstützen viele der erwähnten
Clients unterschiedliche Methoden. Auch wenn Serendipity nicht in jeder
Software aufgeführt wird, können Sie es fast immer mit der manuellen 
Konfiguration der jeweiligen Software ans Laufen kriegen.

Das Serendipity-Plugin unterstützt sowohl die MoveableType-API
(MT/me\-taWeblog) als auch die ältere Blogger API. Bei der manuellen
Konfiguration zum Betrieb Ihres gewählten Blog-Clients müssen Sie
meist folgende Werte angeben: Servername (z.\,B.\
\cmd{www.example.com}), Port (meistens 80) und letztlich die URL oder
auch etwas wie \emph{Page} oder \emph{API-Endpoint}. Dort tragen Sie
den HTTP-Pfad zu der Serendipity-Datei \cmd{serendipity\_xmlrpc.php}
ein -- also z.\,B.\ \cmd{/serendipity/serendipity\_xmlrpc.php}. Diese
PHP"=Datei dient der Kommunikation Ihres Blog-Client mit dem
Serendipity-Plugin.

Oft können Blog-Clients auch automatisch anhand Ihrer Blog-URL erkennen,
welche Zugangsparameter notwendig sind. Damit Sie sich im jeweiligen
Blog-Client in Ihr Blog einloggen können, müssen Sie zudem Ihren
Benutzernamen und das Passwort eingeben, mit dem Sie sich auch im
Serendi\-pi\-ty-Backend einloggen.

Im Blog-Client können Sie nun Einträge veröffentlichen, Kategorien
verwalten und auch Bilder anhängen. Leider können wir aufgrund der 
Vielfalt an Blog-Clients hier keine gezielteren Beschreibungen geben. Aber
dies ist meist auch nicht notwendig, da die Hilfen zu den Blog-Clients
oft sehr ausführlich sind und man Ihnen in deren Support-Foren gerne
weiterhilft.

\index{Fehler!XML-RPC}%
Bei etwaigen Problemen in der Kommunikation zwischen Client und Server
können Sie über die Datei
\cmd{plugins/serendipity\_event\_xmlrpc/seren\-dipity\_xmlrpc.inc.php} die
Variable \cmd{\$debug\_xmlrpc} auf den Wert \cmd{2} setzen, um ein
Debugging-Protokoll zu schreiben. In dieser Protokolldatei können Sie
gegebenenfalls bereits selbständig Fehlermeldungen entdecken. Ansonsten hilft man
Ihnen gerne im Serendipity-Forum.

Zuletzt seien jedoch auch die Nachteile von Blog-Clients erwähnt. Der
größte Nachteil liegt darin, dass die universelle Schnittstelle darauf
verzichten muss, erweiterte Optionen von Blogs anzubieten. Viele
Serendipity-Plugins (beispielsweise das Tagging-Plugin oder die Freien
Eigenschaften von Einträgen) können Zusatzfelder für einen Eintrag
verwalten, die Sie aber über einen Blog-Client nicht eintragen können.
Sie verlieren also einen Großteil an Flexibilität und müssen so
möglicherweise nach wie vor das Serendipity-Backend aufsuchen.

Ein weiterer Nachteil ist die große Vielfalt an APIs und der
Interpretations\-spielraum der zahlreichen Blog-Clients, die
unterschiedliche Funktionsaufrufe teilweise ganz unterschiedlich
ansprechen.

Sie sollten sich daher bereits im Voraus überlegen, ob möglicherweise
der Blog-Client nur für spezielle Redakteure eingesetzt werden soll.
Natürlich hindert Sie nichts daran, den Blog-Client und das
Serendipity-Backend fallweise einzusetzen. Ausführliche Artikel können
Sie beispielsweise im Blog-Client vorschreiben und dann später erweiterte
Optionen über das Serendi\-pity-Backend vornehmen.

\label{podcast}%
\index{Plugins!Podcast}%
\index{Plugins!Easy Podcast}%
\index{Plugins!serendipity\_event\_podcast}%
\index{Podcast}%
\subsection{Easy Podcast\newline serendipity\_event\_podcast}

Mit zunehmender Bandbreite der Internetanschlüsse sind neben
bebilderten Blog-Artikeln auch ganz andere multimediale Präsentationen
möglich.
Sehr populär sind dank der Verbreitung des Apple iPod die sogenannten
\emph{Podcasts} geworden. Dieses Kunstwort bezeichnet die Ausstrahlung
(\emph{cast}) von Audioaufnahmen zu den i\emph{Pods}. Blogger können so
ihre eigenen Hörspiele oder einfach nur Sprachaufzeichnungen als
gewöhnliche MP3-Datei aufnehmen und in ihr Blog stellen. Von dort kann sie
automatisch durch die iTunes-Software (und mittlerweile auch durch viele
andere RSS-Reader) heruntergeladen und auf den mobilen MP3-Player übertragen werden.

Die Idee ist einfach: Ähnlich wie ein Blog-Leser regelmäßig Ihre
Blog-Artikel durch RSS-Anwendungen beziehen kann, um diese Artikel zu
lesen, soll er unterwegs Ihre Neuigkeiten auch über seinen MP3-Player
hören können.

Innerhalb kurzer Zeit hat sich dank der gelangweilten Berufspendler so ein
großer Absatzmarkt für persönliche Hörspiel-Blogs gebildet. Da iTunes und
iPods leicht bedienbar sind, ist diese Verbreitungsweise auch für
kommerzielle Betreiber recht interessant geworden. Sogar Tageszeitungen
und TV-Magazine geben mittlerweile regelmäßig Podcasts heraus, und große
Portale wie \cmd{http://www.podcast.de} führen Übersichten über
Audio-Blogs.

Durch den Erfolg von YouTube ist auch Video-Blogging populärer geworden,
wenngleich aufgrund der geringen Verbreitung von portablen Videoplayern
deren Durchbruch im Blog-Sektor noch auf sich warten lässt.

Technisch gesehen ist der Vorgang des Podcastings relativ simpel: Sie
müssen lediglich eine MP3-Audiodatei erstellen, diese in den RSS-Feed
einbinden, und schon können Ihre Leser die Dateien automatisch beziehen.
Das Serendipity-Plugin \menu{Easy Podcast} macht diesen Vorgang für Sie
recht einfach, da es die Einbindung in den RSS-Feed selbständig
übernimmt.

Sobald Sie das Plugin installiert haben, können Sie eine MP3-Audiodatei
einfach in die Serendipity-Mediendatenbank hochladen und in einen
Blog-Artikel einbinden. Wenn Sie einen derartigen Blog-Artikel nun
speichern, erkennt das Plugin automatisch angehängte MP3-Dateien, bindet
einen Audioplayer in die Darstellung ein und fügt die MP3-Datei als
Podcast in den RSS-Feed ein (sogenannte \emph{Enclosure}).

\index{QuickTime}%
\index{Video}%
\index{Flash}%
\index{Audio}%
Ihre Besucher können nun über Ihr Blog die MP3-Datei anhören. Abgesehen
von Audiodateien unterstützt das Plugin auch noch weitere Formate, die
jeweils abhängig vom Dateityp mit unterschiedlichen Browser-Applets
eingebunden werden können: QuickTime (\cmd{3gp, mov, mp3, mqv, qt}),\osplinebreak{}
Windows Media Player (\cmd{avi, mpg, mpeg, wmv}), Flash (\cmd{swf}), Audio
(\cmd{mp3, ogg, m3u, pls, m4b}).

Grundsätzlich funktioniert das Podcast-Plugin dabei so, dass es Ihren
Blog-Artikel nach Links zu allen unterstützten Dateiformaten durchgeht
und abhängig von der Konfiguration des Plugins den benötigten Player
einbindet. Zu jedem unterstützten Dateiformat wird zudem auch das
notwendige Enclosure-Element in dem RSS-Feed hinzugefügt.

Das Podcast-Plugin bietet mehrere Konfigurationsoptionen an:

\osppagebreak

\begin{ospdescription}
\ospitem{\menu{Player anzeigen}}
Nur wenn Sie die Option \menu{Player anzeigen} aktivieren, wird das
Plugin automatisch Hyperlinks zu unterstützten Dateitypen so abändern,
dass der entsprechende Audio-/Video-Player anstelle des Links eingebunden
wird.

\ospitem{\menu{Player Größe anpassen, Breite, Höhe}}
Wenn Sie diese Option aktivieren, versucht das Plugin die Bildgröße einer
Videodatei herauszufinden. Die Breite und Höhe des eingebetteten Players
wird dann an diese automatisch ermittelte Bildgröße angepasst.
Ohne diese Größenanpassung wird der Player stets in der festgelegten Höhe
und Breite (standardmäßig 200 x 200 Pixel) angezeigt.

Um die Bildgröße eines Videos herauszufinden, muss die
\cmd{getid3}-Bibliothek installiert sein.\footnote{Diese können Sie von 
\cmd{http://www.getid3.org} herunterladen und in ein Unterverzeichnis
namens \cmd{getid3} in das Serendipity-Verzeichnis \cmd{bundled-libs}
entpacken.} Dieser Automatismus kann möglicherweise die Geschwindigkeit
des Plugins spürbar verlangsamen, daher ist eine feste Player-Größe
unter Umständen die bessere Wahl.

\ospitem{\menu{Ausrichtung}}
Über das Ausklappfeld \menu{Ausrichtung} legen Sie fest, wie der Player
mit der Video- oder Audiodatei ausgerichtet werden soll (\menu{links,
rechts, zentriert, ohne Ausrichtung}).

\ospitem{\menu{Nur die erste Mediendatei an den Feed Eintrag hängen}}
Laut Spezifikation unterstützt ein RSS-Feed nur eine einzelne Mediendatei pro
Artikel. Daher können Sie diese Option aktivieren, um auch beim Anhängen mehrerer
Mediendateien nur die erste davon in den Feed einzubinden.

\ospitem{\menu{Erweiterte Artikel-Attribute}}
Hier tragen Sie eine Liste der \emph{freien Artikeleigenschaften} ein,
falls Sie das Plugin \emph{Erweiterte Eigenschaften für Artikel}
verwenden, um zusätzliche Podcasts oder Videocasts einzubinden (siehe
unten).

\ospitem{\menu{Einbettung der Medien aus erweiterten Artikel Attributen}}
In dem Ausklappfeld \menu{Einbettung der Medien aus erweiterten Artikel
Attributen} können Sie festlegen, ob ein Player mit der entsprechenden
Datei oberhalb oder unterhalb des (erweiterten) Artikels angezeigt werden
soll.

Wenn Sie die  Platzierung über die Template-Datei \cmd{entries.tpl}
(siehe unten) vornehmen möchten, können Sie die Option \menu{Nicht
in den Artikel einfügen} beibehalten.

\ospitem{\menu{Quicktime, WindowsMediaPlayer, Flash, Audio Erweiterungen}}
In diesen Feldern können Sie eintragen, welche Dateiendungen für welchen
Player benutzt werden sollen.

Der HTML OBJECT/EMBED-Code für die jeweiligen Player befindet sich in der
Datei \cmd{serendipity\_event\_podcast.php} in den Konstanten
\cmd{PLUGIN\_PODCAST\_QUICKTIMEPLAYER}, \cmd{PLUGIN\_PODCAST\_WM\-PLAYER},
\cmd{PLUGIN\_PODCAST\_FLASHPLAYER} und \cmd{PLUGIN\_PODCAST\_MP\-3PLAYER}.

Wenn Sie einen eigenen HTML-Player (z.\,B.\ für FLV-Dateien) einbinden
wollen, können Sie diese Konstanten in der PHP-Datei anpassen.

\ospitem{\menu{Caching}}
Wenn Sie die Option \menu{Caching} aktivieren, wird das Plugin zur
automatischen Player-Erstellung die jeweiligen Audio-/Videodateien nur
einmalig überprüfen und deren Metadaten zwischenspeichern.

Bei deaktiviertem Caching wird die Geschwindigkeit möglicherweise stark
eingeschränkt, da die großen Videodateien jedesmal erneut geprüft werden.
\end{ospdescription}

Abgesehen von der automatischen Player-Einbindung bietet das Plugin
eine Integration mit dem Plugin \emph{Erweiterte Eigenschaften für
Artikel} an. Mit Hilfe der \emph{Freien Eigenschaften} können Sie einem
Artikel ein Feld namens \cmd{Podcast} hinzufügen, das Sie später in dem
Smarty-Template \cmd{entries.tpl} an gewünschter Stelle im Layout anzeigen
können. So wird eine Audio- oder Videodatei immer an einer festen Stelle
eingebunden, und ein Redakteur muss diese nicht innerhalb des Artikeltextes
platzieren. Konkret funktioniert dies so:

\begin{enumerate}
\item Über die Konfiguration des Plugins \emph{Erweiterte
    Eigenschaften für Artikel} fügen Sie den Feldnamen \cmd{Podcast}
    ein.
\item Wenn Sie nun einen neuen Artikel erstellen, sehen Sie in dem
    Abschnitt \menu{Erweiterte Optionen} ein neues Eingabefeld namens
    \menu{Podcast}. Dort können Sie entweder eine URL zu der
    MP3-Datei eingeben oder mittels des Buttons \menu{Mediendatenbank} eine 
	Datei aus der Mediendatenbank auswählen.
\item Nach dem Speichern eines Artikels ist nun ein Datenbankfeld mit
    der URL zu der Podcast-Datei angelegt worden. Diese Variable
    möchten Sie nun an einer festen Stelle des Artikel-Layouts
    ausgeben, beispielsweise immer am Ende des Artikels.
\item Dazu bearbeiten Sie die Datei \cmd{entries.tpl} Ihres Templates
    und fügen beispielsweise unterhalb von \cmd{\{\$entry.body\}}
    Folgendes ein:

\input{snippets/podcast.tex}

\item Dieser HTML-Code sorgt dafür, dass die von Ihnen eingetragene
    Audiodatei mittels Browser-Applets abspielbar wird. Zusätzliche
    Attribute wie \cmd{width="{}300"{}} geben die Breite der
    Zeitleiste für die Audiowiedergabe an.
\end{enumerate}

Diese Variante der Einbindung erfordert zwar mehr Anpassung, garantiert
dafür aber auch ein einheitliches Layout. So können Sie auch eigene
Videoplayer anstelle der QuickTime/WindowsMedia und anderen Player
einbinden.

%revised
\index{Bilderplugins@Bilder-Plugins}%
\index{Plugins!Bilder}%
\section{Ereignis-Plugins für Bilder}

\index{Lightbox}%
\index{Thickbox}%
\index{Graybox}%
\label{lightbox}%
\index{Plugins!Lightbox/Thickbox/Graybox}%
\index{Plugins!serendipity\_event\_lightbox}%
\index{Bildergalerie}%
\index{Vorschaubilder}%
\subsection{Lightbox/Thickbox/Graybox\newline serendipity\_event\_lightbox}

In Blog-Artikeln von Serendipity können Sie dank der Mediendatenbank
relativ einfach ein Bild einfügen (siehe Seite
\pageref{Mediendatenbank-Popup}). Ein solches Bild wird
entweder in der vollen Größe oder als kleines Vorschaubild eingebettet,
und ein Klick auf das Bild öffnet es meist in einem neuen Browserfenster.

Diese Art der Einbindung ist relativ unspektakulär. Daher wurden in
letzter Zeit zahlreiche JavaScripts entwickelt, die Bildervorschauen und
-galerien mit hübschen Überblendungseffekten einbinden lassen. Ein Klick
auf ein Bild dunkelt dann den Hintergrund ab, das Bild öffnet sich in einem
eigenständigen Bereich und passt sich in der Größe automatisch an.
Auch ein Hin- und Herblättern zwischen mehreren zusammengehörigen Bildern ist
so komfortabel möglich.

\osppagebreak

Mittlerweile gibt es viele JavaScripts, die diese Technik einsetzen:
Lightbox\footnote{\cmd{http://www.huddletogether.com/projects/lightbox2/}},
Lightbox plus\footnote{\cmd{http://serennz.sakura.ne.jp/toybox/lightbox/}},
Thickbox\footnote{\cmd{http://jquery.com/demo/thickbox/}} und
Greybox\footnote{\cmd{http://orangoo.com/labs/GreyBox/}}. Alle diese
Bibliotheken bieten unterschiedliche Features und eine unterschiedliche
Syntax. Sie sollten sich daher alle Varianten und Demos ansehen, um sich
auf die für Sie beste zu beschränken. Da dies großteils Geschmackssache
ist, kann man leider keines der Scripts pauschal empfehlen.

Welche der Bibliotheken Sie einsetzen, ist erst einmal nicht weiter
wichtig. Das Serendipity-Plugin \emph{Lightbox/Thickbox/Graybox}
unterstützt alle aufgeführten Bibliotheken und liefert alle drei
benötigten Dateien mit. Sie können sich also auch später für den Einsatz
eines anderen Scripts entscheiden. Jedoch können Sie immer nur eine der
Bibliotheken benutzen, das Plugin lässt sich nicht mehrfach installieren.

In der Plugin-Konfiguration müssen Sie daher lediglich die Bibliothek
auswählen und dann den HTTP-Pfad zu dem Plugin-Verzeichnis Ihres Blogs
eintragen. Standardmäßig entspricht dies dem Serendipity-Stammpfad zzgl.
\cmd{/plugins}. Im Beispiel des Buches wäre es also
\cmd{/serendipity/plugins/}. Den voreingestellten Pfad können Sie daher in den
meisten Fällen beibehalten.

Sobald das Plugin aktiviert ist, wird es sich automatisch um die Links zu
Ihren Bildern kümmern. Jedesmal, wenn ein Blog-Artikel dargestellt wird, sucht
das Plugin nach vorhandenen \cmd{<a href\ldots>}-Hyperlinks und fügt dort
den Code ein, den die jeweilige Bibliothek benötigt, um beim Klick auf den
Link direkt ein Bild anzuzeigen. Bei Lightbox (und dessen Varianten) wird
einem Link das Attribut \cmd{<a rel="{}lightbox"{} href\ldots>}
eingesetzt, für Thickbox ist dies \cmd{<a rel="{}thickbox"{} href\ldots>},
und Graybox benutzt die Syntax \cmd{<a rel="{}gb\_image[]"{}
href\ldots>}. Natürlich können Sie auch manuell in den HTML-Code Ihrer
Blog-Artikel die entsprechenden weiteren Möglichkeiten der
Box-Bibliotheken einsetzen -- lesen Sie dazu bitte die Dokumentation der
jeweiligen Bibliothek.

\index{Fehler!Lightbox}%
Die Darstellung von großen Bildern in einem eingebetteten Popup kann nur
funktionieren, wenn Sie in Ihrem Beitrag einen Link zu einem Bild
eingebunden haben. Wenn Sie ein Bild aus der Mediendatenbank einfügen und
davon nur das Vorschaubild ohne weitere Verlinkung auswählen, können die
Bibliotheken nicht aktiv werden, da ihnen die notwendigen HTML-Daten
fehlen.

\label{usergallery}%
\index{Plugins!Bildergalerie}%
\index{Plugins!serendipity\_event\_usergallery}%
\subsection{Bildergalerie\newline serendipity\_event\_usergallery}

Mit dem Plugin \emph{Bildergalerie} können Sie Bilder und Dateien
aus Ihrer Mediendatenbank präsentieren. Dabei kann das Plugin so 
konfiguriert werden, dass nur spezielle Unterordner
Ihrer Mediendatenbank eingesehen werden können. Die Darstellung der Galerie
kann über Templates gesteuert werden, zahlreiche Konfigurationsoptionen
ermöglichen eine individuelle Anpassung der Galerie.

\index{RSS-Feeds!mit Bildern}%
Abgesehen von der Galerie-Übersicht bietet das Plugin auch einen eigenen
RSS-Feed an, der Ihre aktuellsten Bilder (als Vorschaubild) enthält. Diesen
können Sie über

\begin{ospcode}
http://www.example.com/rss.php?version=2.0\&gal\-lery=true\&limit=\cmdvar{A}\&picdir=\cmdvar{B}
\&feed\_width=\cmdvar{C}\&head\_title=\cmdvar{D}
\end{ospcode}

Die einzelnen URL-Variablen sind:

\begin{ospdescription}
\ospitem{\cmd{version}}
Legt die RSS-Feed-Version fest (siehe auch Seite \pageref{rss-urlvariablen}).

\ospitem{\cmd{gallery}}
Wird benötigt, damit das Plugin seine Ausgaben einbinden kann.

\ospitem{\cmd{limit} (A, optional)}
Legt fest, wie viele Bilder im RSS-Feed enthalten sein sollen (standardmäßig 15).

\ospitem{\cmd{picdir} (B, optional)}
Legt den Pfad fest, aus dem die Bilder ausgelesen werden sollen. Standardmäßig
werden alle Bilder aus allen Unterverzeichnissen herangezogen.

\ospitem{\cmd{feed\_width} (C, optional)}
Gibt die gewünschte Größe der Vorschaubilder an. Standardmäßig wird die in den
Konfigurationsoptionen festgelegte Zahl verwendet. Falls die URL-Option
angegeben wird, hat diese jedoch Vorrang.

\ospitem{\cmd{hide\_title} (D, optional)} 
Wenn dieser Parameter angegeben wird, enthält der RSS-Feed keine Dateinamen oder
Titel der Bilder, sondern lediglich die Bilddatei.
\end{ospdescription}

Um also die aktuellsten zehn Bilder des Verzeichnisses \cmd{Messe} in einer Größe
von maximal 110 Pixeln Breite darzustellen, würden Sie folgende URL verwenden:

\begin{ospcode}
http://www.example.com/rss.php?version=2.0\&gallery=true\&limit=10\&picdir=
Messe\&feed\_width=110   
\end{ospcode}


Die Darstellung dieses Feeds erfolgt über die üblichen Serendipity
\cmd{feed*.""tpl}-Dateien. Mit der auf Seite \pageref{customfeeds}
vorgestellten Methodik können Sie daher auch ein ganz eigenes Feed-Template für
den Galerie-Feed anlegen, indem Sie
\cmd{http://www.example.com/rss.php?version=gallery\ldots} verwenden und eine
Template-Datei \cmd{feed\_gallery.tpl} anlegen.
\index{Template-Dateien!feed\_gallery.tpl}%
 
Folgende Konfigurationsoptionen bietet das Plugin:

\begin{ospdescription}
\ospitem{\menu{Display name}}
Legt den Titel der Galerie fest.

\ospitem{\menu{Anzahl der Spalten}}
Legt die Anzahl der Spalten für die Bildübersicht fest.

\ospitem{\menu{Subpage name for gallery view}}
Legt den \emph{URL-Titel der Seite} (siehe Seite
\pageref{Standardpluginkonfiguration-Pagetitle}) fest, der benötigt wird, um die
Galerie mittels einer speziellen URL aufrufen zu können.

\ospitem{\menu{Mache diese Seite zur Startseite für Serendipity}}
Mit Aktivierung dieser Option wird die Bildergalerie als Startseite Ihres Blogs dienen. In
diesem Fall sollten Sie dafür sorgen, dass das Galerie-Ereignis-Plugin als eines
der ersten Ereignis-Plugins positioniert wird, da andernfalls Konflikte
mit anderen Plugins bei der Darstellung der Startseite auftreten können.

\ospitem{\menu{Permalink für die Anzeige der Galerie}}
Legt den \emph{Permalink} fest, mit dem Sie die Galerie aufrufen können (siehe
auch Seite \pageref{Standardpluginkonfiguration-Permalink}).

\ospitem{\menu{Choose the gallery style}}
Mit diesem Ausklappfeld legen Sie fest, ob das Plugin zur Darstellung der
Galerie eigene Template-Dateien mit eigener Formatierung (Wert \cmd{Thumbnail
page}) oder die Standard-Mediendatenbankansicht von Serendipity (Wert
\cmd{Media library}) verwenden soll. Nur bei der Option \cmd{Thumbnail page}
sind die meisten der folgenden Konfigurationsoptionen verfügbar.

\ospitem{\menu{Pick a default directory}}
Hier können Sie ein Stammverzeichnis auswählen, das für die Galerie
herangezogen wird. Besucher können nur auf Unterverzeichnisse des 
gewählten Verzeichnisses zugreifen. 

\ospitem{\menu{Show a directory listing}}
Legt fest, ob eine Liste aller verfügbaren Verzeichnisse in der Galerie
angezeigt werden soll.

\ospitem{\menu{Bilder pro Seite}}
Legt die Anzahl der Bilder pro Seite fest. Wenn Sie hier \cmd{0} eingeben, zeigt
das Plugin alle verfügbaren Bilder auf einer einzigen Seite an. Andernfalls wird
eine Möglichkeit zum Vor- und Zurückblättern für weitere Bilder eingebunden.

\ospitem{\menu{Reihenfolge der Bilder}}
Legt fest, in welcher Sortierungsreihenfolge (nach Dateiname oder
Einstellungsdatum) die Bilder dargestellt werden.

\ospitem{\menu{Einleitungstext}}
Hier können Sie einen beliebigen (HTML)-Text eintragen, der auf jeder Seite der
Galerie für Ihre Besucher angezeigt wird.

\ospitem{\menu{Display Single Image}}
Mit dieser Option bestimmen Sie, ob beim Klick auf ein einzelnes Bild dieses als
\menu{Adaptive pop-up} (eigenes, korrekt skaliertes Fenster) oder innerhalb des
Blog-Layouts (\menu{Scaled to fit}) dargestellt wird.

\ospitem{\menu{Output images strictly}}
Falls diese Option aktiviert wird, zeigt die Galerie ausschließlich Bilder des
aktuellen Verzeichnisses an und ignoriert alle etwaigen Unterverzeichnisse.

\ospitem{\menu{Feste Bildgröße}}
Legt die Standardbreite eines Bildes bei der Darstellung der Galerie fest.
Standardmäßig wird die Voransichtsgröße der globalen Serendipity"=Konfiguration übernommen.

\ospitem{\menu{Max. image width in page}}
Legt die maximale Bildbreite fest, die ein Bild bei der Darstellungsart
\menu{Scaled to fit} einnehmen darf.

\ospitem{\menu{RSS-Feed image dimensions}}
Legt fest, wie groß ein Vorschaubild bei der Einbindung innerhalb des RSS-Feeds
sein soll. Diese Größe kann durch den URL-Parameter \cmd{feed\_width} vom Benutzer
übergangen werden.

\ospitem{\menu{Nur verlinkte Bilder im RSS-Feed}}
Falls Sie diese Option aktivieren, enthält der RSS-Feed nur die Bilder, die Sie
innerhalb Ihrer Blog-Beiträge auch tatsächlich verlinkt haben. Andernfalls wird
stur das Verzeichnis der Mediendatenbank ausgelesen, und alle darin enthaltenen 
Bilder werden eingebunden.

\ospitem{\menu{Zeige exif-Tags}}
Falls aktiviert, werden die EXIF-Metadaten einer Datei der Mediendatenbank
dargestellt.

\ospitem{\menu{Exif data}}
Wenn Sie die Darstellung der EXIF-Metadaten aktiviert haben, können Sie im
Bereich \menu{Exif data} festlegen, welche dieser EXIF-Daten tatsächlich
angezeigt werden sollen. Sie können jeden der verfügbaren Werte gezielt
aktivieren oder deaktivieren.

\ospitem{\menu{Show Media Properties}}
Bei aktivierter Option können die vom Redakteur eingetragenen Metadaten
(Copyright, Bildtitel \ldots) zu den einzelnen Mediendateien angezeigt werden.

\ospitem{\menu{Media properties list}}
Wenn Sie die Option \menu{Show Media Properties} aktivieren, können Sie in
diesem Eingabefeld festlegen, welche Metadaten Sie anzeigen wollen. Die hier
verfügbaren Feldnamen richten sich nach dem, was Sie in der globalen 
Serendipity-Konfiguration eingetragen haben (siehe Seite \pageref{Medien-Eigenschaften}).

\ospitem{\menu{Zeige einen Link zu den Einträgen/statischen Seiten, die auf}}
\ospadditem{\menu{das Bild verlinken}}
Wenn Sie diese Option aktivieren, wird in der Ansicht eines Bildes in der
Galerie eine Liste angezeigt, die alle URL-Verweise auf dieses Objekt enthält. So
können Sie sehen, von welchen Seiten aus ein Bild oder eine Datei eingebunden
wurde. Dies kann nur ausgewertet werden, wenn Sie die Bilder mittels
Serendipity-Wrapper ausgeben (siehe Seite \pageref{mdb-by-id}).
\end{ospdescription}

\index{Template-Dateien!plugin\_usergallery.tpl}%
\index{Template-Dateien!plugin\_usergallery\_imagedisplay.tpl}%
Falls die Darstellung des Plugins mittels Template-Datei erfolgt
(\menu{Choose the gallery style\sm Media Library}), können Sie in den Dateien 
\cmd{plugin\_usergal\-lery.tpl} (Übersicht)
und \cmd{plugin\_usergallery\_imagedisplay.tpl}\osplinebreak{} (Einzelseite) auf
folgende Smarty-Variablen zugreifen:

\index{Template-Variablen!\$Bildergalerie@Bildergalerie}%
\begin{ospdescription}
\ospitem{\ospsmarty{staticpage\_pagetitle} (Zeichenkette)}
Enthält den Kurztitel der Galerieseite. Dies wird z.\,B.\ dazu benutzt, bestimmte
HTML-Klassen mit einem eindeutigen Namen zu belegen, um sie individuell per
CSS-Anweisungen formatieren zu können.

\ospitem{\ospsmarty{const} (Array)}
Enthält ein Array mit zusätzlichen Sprachvariablen der Galerie.

\index{Template-Variablen!\$plugin\_usergallery\_httppath}%
\ospitem{\ospsmarty{plugin\_usergallery\_httppath} (Zeichenkette)}
Enthält den URL-Pfad zur aktuellen Seite der Galerie.

\index{Template-Variablen!\$plugin\_usergallery\_httppath\_extend}%
\ospitem{\ospsmarty{plugin\_usergalleryhttppath\_extend} (Zeichenkette)}
Enthält den URL-Pfad zur aktuellen Seite der Galerie. Diese Variable kann zum
Anhängen von weiteren URL-GET-Variablen verwendet werden, da sie mit einem
\cmd{?} oder \cmd{\&} endet (je nach konfigurierter URL-Umformungsoption des
Blogs, siehe Seite \pageref{urlformung}).

\index{Template-Variablen!\$plugin\_usergallery\_currentgal}%
\ospitem{\ospsmarty{plugin\_usergallery\_currentgal} (Zeichenkette)}
Enthält den Namen des aktuellen Pfades der Mediendatenbank.

\index{Template-Variablen!\$plugin\_usergallery\_uppath}%
\ospitem{\ospsmarty{plugin\_usergallery\_uppath} (Zeichenkette)}
Enthält den Namen des übergeordneten Pfades des aktuell dargestellten
Verzeichnisses der Mediendatenbank.

\index{Template-Variablen!\$plugin\_usergallery\_toplevel}%
\ospitem{\ospsmarty{plugin\_usergallery\_toplevel} (Zeichenkette)} 
Enthält den Wert \cmd{yes}, falls der Besucher das Stammverzeichnis der
Mediendatenbank ansieht. Falls der Besucher ein Unterverzeichnis ansieht,
enthält diese Variable den Wert \cmd{no}.

\index{Template-Variablen!\$plugin\_usergallery\_maindir\_filecount}%
\ospitem{\ospsmarty{plugin\_usergallery\_maindir\_filecount} (Zahl)} 
Enthält die Anzahl an dargestellten Dateien des aktuellen Verzeichnisses.

\index{Template-Variablen!\$plugin\_usergallery\_subdirectories}%
\ospitem{\ospsmarty{plugin\_usergallery\_subdirectories} (Array)}
Enthält ein Array mit allen Unterverzeichnissen der Mediendatenbank. Jeder
Array-Index enthält den Namen des jeweiligen Verzeichnisses, der Array-Wert
enthält in einem Unter-Array mit dem Array-Schlüssel \cmd{filecount} die
jeweilige Anzahl der Objekte in diesem Verzeichnis. Alle weiteren
Array-Schlüssel richten sich nach der Liste auf Seite \pageref{mediafolders}.

\index{Template-Variablen!\$plugin\_usergallery\_pagination}%
\ospitem{\ospsmarty{plugin\_usergallery\_pagination} (Boolean)}
Enthält den Wert \cmd{true}, wenn die Navigation zum Vor- und Zurückblättern der
Galerieansicht dargestellt werden muss.

\index{Template-Variablen!\$plugin\_usergallery\_total\_count}%
\ospitem{\ospsmarty{plugin\_usergallery\_total\_count} (Zahl)}
Enthält die Gesamtzahl an Objekten in der Mediendatenbank.

\index{Template-Variablen!\$plugin\_usergallery\_total\_pages}%
\ospitem{\ospsmarty{plugin\_usergallery\_total\_pages} (Zahl)}
Enthält die Gesamtzahl an Seiten, falls die Darstellung einer Galerie auf
mehrere Seite aufgebrochen werden muss.

\index{Template-Variablen!\$plugin\_usergallery\_current\_page}%
\ospitem{\ospsmarty{plugin\_usergallery\_current\_page} (Zahl)}
Enthält die aktuelle Seitennummer, falls die Darstellung einer Galerie auf
mehrere Seiten umbrochen werden muss.

\index{Template-Variablen!\$plugin\_usergallery\_next\_page}%
\index{Template-Variablen!\$plugin\_usergallery\_previous\_page}%
\ospitem{\ospsmarty{plugin\_usergallery\_next\_page},}
\ospadditem{\ospsmarty{plugin\_usergallery\_previous\_page} (Zahl)}
Enthält die jeweils nächste und vorherige Seitennummer.

\index{Template-Variablen!\$plugin\_usergallery\_title}%
\ospitem{\ospsmarty{plugin\_usergallery\_title} (Zeichenkette)}
Enthält den Seitentitel der Galerie.

\index{Template-Variablen!\$plugin\_usergallery\_cols}%
\ospitem{\ospsmarty{plugin\_usergallery\_cols} (Zahl)}
Enthält die gewünschte Anzahl an Spalten pro Galerieseite.

\index{Template-Variablen!\$plugin\_usergallery\_preface}%
\ospitem{\ospsmarty{plugin\_usergallery\_preface} (Zeichenkette)}
Enthält die in den Konfigurationsoptionen hinterlegte Einführung\osplinebreak{} (Text) zur
Mediendatenbank. 

\index{Template-Variablen!\$plugin\_usergallery\_fixed\_width}%
\ospitem{\ospsmarty{plugin\_usergallery\_fixed\_width} (Zahl)}
Enthält die maximale Breite eines Bildes.

\index{Template-Variablen!\$plugin\_usergallery\_image\_display}%
\ospitem{\ospsmarty{plugin\_usergallery\_image\_display} (Zeichenkette)}
Enthält den in den Konfigurationsoptionen festgelegten Wert, ob ein Bild bei
Klick als Popup oder innerhalb derselben Seite angezeigt werden soll.

\index{Template-Variablen!\$plugin\_usergallery\_gallery\_breadcrumb}%
\ospitem{\ospsmarty{plugin\_usergallery\_gallery\_breadcrumb} (Array)}
Enthält ein Array mit allen übergeordneten Pfaden des aktuellen Verzeichnisses
der Mediendatenbank, so dass diese gezielt angesprungen werden können. Pro
Array-Schlüssel enthält der Array-Wert den jeweiligen Verzeichnisnamen.

\index{Template-Variablen!\$plugin\_usergallery\_dir\_list}%
\ospitem{\ospsmarty{plugin\_usergallery\_dir\_list} (Zeichenkette)}
Enthält den in den Konfigurationsoptionen festgelegten Wert, ob eine
Verzeichnisliste eingeblendet werden soll.

\index{Template-Variablen!\$plugin\_usergallery\_display\_dir\_tree}%
\ospitem{\ospsmarty{plugin\_usergallery\_display\_dir\_tree} (Zeichenkette)}
Enthält den in den Konfigurationsoptionen festgelegten Wert, ob eine
Verzeichnisnavigation eingeblendet werden soll.

\index{Template-Variablen!\$plugin\_usergallery\_colwidth}%
\ospitem{\ospsmarty{plugin\_usergallery\_colwidth} (Zahl)}
Enthält einen gerundeten Wert, der abhängig von der konfigurierten Anzahl der
Bilder pro Zeile die Spaltenbreite bei der Darstellung festlegt.

\index{Template-Variablen!\$plugin\_usergallery\_limit\_directory}%
\ospitem{\ospsmarty{plugin\_usergallery\_limit\_directory} (Zeichenkette)}
Enthält den Namen des aktuellen Verzeichnisses, von dem sämtliche Sonderzeichen
entfernt wurden.

\index{Template-Variablen!\$plugin\_usergallery\_images}%
\ospitem{\ospsmarty{plugin\_usergallery\_images} (Array)}
Enthält ein Array mit allen Bildern der aktuellen Seite. Die Inhalte des Arrays
richten sich nach den festgelegten Array-Schlüsseln (siehe Seite \pageref{mediafile}). 

\index{Template-Variablen!\$plugin\_usergallery\_nextid}%
\index{Template-Variablen!\$plugin\_usergallery\_previousid}%
\ospitem{\ospsmarty{plugin\_usergallery\_nextid},}
\ospadditem{\ospsmarty{plugin\_usergallery\_previousid} (Zahl)}
Enthält die ID des jeweils vorherigen und nächsten Bildes.

\index{Template-Variablen!\$plugin\_usergallery\_xtra\_info}%
\ospitem{\ospsmarty{plugin\_usergallery\_xtra\_info} (Zeichenkette)}
Enthält eine HTML-Ausgabe mit den EXIF-Metadaten des Bildes.

\index{Template-Variablen!\$plugin\_usergallery\_extended\_info}%
\ospitem{\ospsmarty{plugin\_usergallery\_extended\_info} (Zeichenkette)}
Enthält die HTML-Ausgabe mit in der Mediendatenbank festgelegten
Medieneigenschaften einer Datei (z.\,B.\ Titel, Copyright etc.)

\index{Template-Variablen!\$plugin\_usergallery\_file}%
\ospitem{\ospsmarty{plugin\_usergallery\_file} (Array)}
Enthält das Array mit Bildinformationen, falls die Einzeldarstellung erfolgt. 
Die Inhalte des Arrays richten sich nach den  Array-Schlüsseln 
(siehe Seite \pageref{mediafile}). 

\end{ospdescription}

Bei der Darstellung mittels \menu{Choose the gallery style\sm Media} greift das
Plugin auf die Standard-Template-Dateien wie \cmd{media\_choose.tpl} zurück
(siehe Seite \pageref{media-choose.tpl}).

\index{Plugins!Erweiterte Optionen für Bildauswahl}%
\index{Plugins!serendipity\_event\_imageselectorplus}%
\subsection{Erweiterte Optionen für Bildauswahl\newline serendipity\_event\_imageselectorplus}

Das Plugin \emph{Erweiterte Optionen für Bildauswahl} dient mehreren Zwecken
rund um die Bildverwaltung Serendipitys.

\index{QuickBlog}%
\index{Fotoblogs}%
Zum einen ermöglicht es über eine sogenannte 
\emph{QuickBlog}-Funktion, mit einem einfachen Klick ein hochgeladenes Bild direkt
als neuen Blog-Artikel einzustellen. Dies ist besonders für
Fotoblogs sehr praktisch, um etwas Klickarbeit zu sparen.

Weiterhin bietet das Plugin eine Möglichkeit, kleine Bilderserien in einen
Blog-Eintrag einzufügen. Dies geschieht mittels einfachem XML-Code.

Das Plugin erweitert das Formular zum Hochladen eines Eintrags (falls Ihre
PHP-Version dies unterstützt) um die Möglichkeit, auch ZIP-Archive mit
Bildern/Dateien hochzuladen.

Zuletzt dient das Plugin dazu, die Optionen beim Einfügen einer Datei aus
der Mediendatenbank in einen Blog-Eintrag zu erweitern. Seit Serendipity
1.1 sind diese Optionen jedoch bereits Bestandteil der offiziellen Version und
werden somit innerhalb des Plugins nicht weiterverwendet. In Zukunft könnte das Plugin
jedoch möglicherweise wieder eigenständige Optionen einbinden.

\subsubsection{QuickBlog}

Wenn Sie auf den Menüpunkt \menu{Mediendatenbank\sm Mediendaten hinzufügen}
klicken, bindet das Plugin dort einen neuen Bereich mit der Überschrift
\menu{QuickBlog} ein. Dort finden Sie mehrere Eingabefelder vor. Sobald Sie
das Feld \menu{Titel} ausfüllen, wird die hochgeladene Mediendatei automatisch
in einen neuen Blog-Artikel eingebunden. Als Titel des Blog-Artikels wird der in
dem Feld \menu{Titel} eingegebene Inhalt verwendet.

Der so entstandene Blog-Artikel ist später wie ein ganz regulärer Artikel zu
bearbeiten. Er enthält jedoch bereits sämtlichen HTML-Code, der für die
Darstellung des Bildes notwendig ist.

Die Eingabefelder im \menu{QuickBlog}-Bereich legen einen Titel für das Bild
fest, einen zusätzlichen beschreibenden Text und die Zuordnung zur Blog"=Kategorie.

Das Feld \menu{Bildgröße} enthält eine Zahl (in Pixeln), die bestimmt, in welcher
Größe das Bild in dem Quickblog-Artikel eingestellt wird. 

Technisch gesehen wird ein via Quickblog hochgeladenes Bild mit speziellem Code
in Ihren Eintrag eingebunden. Dieser Code enthält die ID zu einem Bild der
Mediendatenbank und wird im normalen Eintragstext des Artikels hinterlegt:

\begin{ospcode}
<!--quickblog:4711-->
\end{ospcode}

Wenn ein solcher Blog-Artikel angezeigt wird, sucht das Plugin automatisch
nach dem Vorkommen derartiger Zeichenketten. Daraufhin liest es die
Mediendatenbank aus und erstellt eine formatierte Darstellung für das Bild. Die
Formatierung richtet sich nach der Template-Datei
\index{Template-Dateien!quickblog.tpl}%
\menu{quickblog.tpl} des Plugins. Der dort hinterlegte HTML-Code stellt das
Bild, einen Link zum Bild sowie etwaige EXIF-Daten ein. Diese Template-Datei 
können Sie Ihren eigenen Wünschen anpassen und in Ihr jeweiliges 
Template-Verzeichnis kopieren.

Folgende Variablen stehen dort zur Verfügung:

\begin{ospdescription}
\index{Template-Variablen!\$quickblog.image}%
\ospitem{\ospsmarty{quickblog.image}}
Enthält die URL zu dem Vorschaubild.

\index{Template-Variablen!\$quickblog.fullimage}%
\ospitem{\ospsmarty{quickblog.fullimage}}
Enthält die URL zu dem Bild in Originalgröße.
 
\index{Template-Variablen!\$quickblog.body}%
\ospitem{\ospsmarty{quickblog.body}}
Enthält den etwaigen zusätzlichen Eintragstext des Blog-Artikels.

\index{Template-Variablen!\$quickblog.exif}%
\ospitem{\ospsmarty{quickblog.exif}}
Enthält ein Array mit allen EXIF-Metadaten des Bildes. Der Array-Index richtet
sich nach dem jeweiligen EXIF-Feldnamen, z.\,B.\ \cmd{Focal\_""length} oder
\cmd{COMMENT.0}. 

\index{jhead}%
\index{EXIF}%
\index{Template-Variablen!\$quickblog.exif\_mode}%
\ospitem{\ospsmarty{quickblog.exif\_mode}}
Falls auf Ihrem Server das Programm \menu{jhead} installiert ist, kann das Plugin
dieses verwenden, um die EXIF-Daten eines Bildes zu lesen. In
diesem Fall ist die Variable \ospsmarty{quickblog.exif\_mode} auf den Wert
\cmd{jhead} gesetzt.

Ohne dieses Programm versucht das Plugin die PHP-Funktion \cmd{exif\_""read\_data}
zu verwenden. Dann ist \ospsmarty{quickblog.exif\_mode} auf \cmd{internal} gesetzt.

Wenn keine Datei gelesen werden konnte, enthält die Variable den Wert \cmd{none}. 

\end{ospdescription}

Sie können die \cmd{<!--quickblog:xxx-->}-Anweisungen praktisch auch
eigenständig in Artikel einfügen und in einen normalen Artikeltext einbetten.
Bei der Darstellung wird dann lediglich die \cmd{quickblog}-Anweisung
ausgetauscht, Ihr restlicher Text erscheint wie gewohnt.

\index{Bilderserien}%
\subsubsection{XML-Bilderserien}

Wenn Sie viele Bilder in einen Artikel einbinden wollen, kann das in mühsame
Klickorgien ausarten. Das Plugin bietet Ihnen hier einen angenehmeren, 
wenn auch technischeren Weg, dasselbe Ziel zu erreichen.

Sie können eigenen (aber einfachen!) Code in Ihren Blog-Artikel einfügen, der
an eine XML-Syntax angelegt ist. Diesen wertet das Plugin später automatisch
aus, und bindet die gewünschten Bilder ein. Die Einbindung erfolgt anhand einer 
eigenständigen Template-Datei
\index{Template-Dateien!plugin\_mediainsert.tpl}%
(\cmd{plugin\_mediainsert.tpl}), so dass Sie hier die Formatierung beliebig anpassen können.

Der XML-Code sieht dabei wie folgt aus:

\begin{ospcode}
<mediainsert>
 <gallery name='\cmdvar{Verzeichnisname}' />
 <media type='single' name='\cmdvar{bildname1}' />
 <media type='single' name='\cmdvar{bildname2}' />
</mediainsert>
\end{ospcode}

Sie können so viele \cmd{<mediainsert>}-Blöcke in Ihrem Eintrag einfügen, wie
Sie wünschen. Innerhalb dieses Blocks müssen Sie das \cmd{<gallery>}-Element
angeben. In dessen Attribut \cmd{name} tragen Sie den Namen des Verzeichnisses ein, aus
dem Sie ein Bild darstellen wollen. Als Verzeichnisname muss hier nur der
tatsächliche Verzeichnisname unterhalb Ihres \cmd{uploads}"=Serververzeichnisses
eingetragen werden. Wenn Sie also Ihre Bilder in
\cmd{/var/www/ex\-ample.com/serendipity/uploads/Urlaub/Mallorca2006} hochgeladen
haben, tragen Sie \cmd{<gallery name='Urlaub/Mallorca2006/' />} ein. Der
abschließende Schrägstrich ist erforderlich. Wenn Sie Bilder des
Stammverzeichnisses darstellen wollen, können Sie \cmd{<gallery name='/' />}
verwenden. 

Daraufhin folgt eine beliebige Anzahl von \cmd{<media>}-Elementen. Als
\cmd{type}-Attribut können Sie entweder \cmd{single} (ein einzelnes Bild),
\cmd{gallery} (das komplette Verzeichnis) oder \cmd{range} (durchnummerierte Bilderreihe)
eintragen.

Bei Bildern vom Typ \cmd{single} müssen Sie im Attribut \cmd{name} den
Dateinamen (ohne Dateiendung) eintragen. Um also
\cmd{uploads/Urlaub/Mallorca2006/""dscf\_001.jpg} darzustellen, können Sie
\cmd{<media type='single' name=""'dscf\_001' />} verwenden. Für jede Datei, die
Sie anzeigen wollen, verwenden Sie eine solche XML-Zeile. Dabei
entspricht die Reihenfolge Ihrer Eingabe der Reihenfolge, in der die Bilder
später dargestellt werden.

Bildern des Typs \cmd{range} müssen Sie die Start- und Endnummer mitgeben. Wenn
Sie die Dateien \cmd{dscf\_1.jpg} bis \cmd{dscf\_10.jpg} darstellen wollen,
benutzen Sie \cmd{<media type='single' prefix='dscf\_' start='1' stop='10'}.
Achten Sie daher auch darauf, dass Ihre Dateien keine führenden Nullen bei der
Durchnummerierung enthalten, da das Plugin andernfalls auf nicht existierende
Dateinamen verweisen könnte.


Wenn Sie ein vollständiges Verzeichnis auslesen wollen, reicht die Zeile
\cmd{<media type='gallery' />} aus. Es werden dann alle Dateien eingebunden, die
im durch \cmd{<gallery name='Urlaub/Mallorca2006/' />} festgelegten Verzeichnis
in die Mediendatenbank geladen wurden.

Der Code muss sich strikt an XML-Syntax halten. \cmd{<media type='gallery'{}>}
wäre beispielsweise ungültig, da das Anführungszeichen nicht übereinstimmt und
der abschließende Schrägstrich des XML-Elements fehlt. Wenn Sie diese Regeln
nicht beachten, kann dies dazu führen, dass das Plugin eine Fehlermeldung darstellt. 

Innerhalb der Template-Datei \cmd{plugin\_mediainsert.tpl}, die zur Darstellung
Ihrer Bilderliste verwendet wird, stehen folgende Variablen zur Verfügung:

\begin{ospdescription}
\index{Template-Variablen!\$plugin\_mediainsertmedia@plugin\_mediainsert\_media}%
\ospitem{\ospsmarty{plugin\_mediainsert\_media}}
Enthält ein Array mit allen Bilddateien. Als Array-Schlüssel stehen folgende
Werte zur Verfügung:

\begin{ospdescription}
\ospitem{\ospsmarty{plugin\_mediainsert\_media.X.name}}
Enthält den Dateinamen (ohne Datei-Endung) der Bilddatei.

\ospitem{\ospsmarty{plugin\_mediainsert\_media.X.extension}}
Enthält die Datei-Endung der Bilddatei.

\ospitem{\ospsmarty{plugin\_mediainsert\_media.X.thumbnail\_name}}
Enthält den Namen (Suffix) der Vorschaudatei.

\ospitem{\ospsmarty{plugin\_mediainsert\_media.X.realname}}
Enthält den vollständigen Dateinamen.

\ospitem{\ospsmarty{plugin\_mediainsert\_media.X.path}}
Enthält den URL-Pfad zu der Bilddatei.

\ospitem{\ospsmarty{plugin\_mediainsert\_media.X.comment1}}
Kommentar zu einem Bild, wie in der Mediendatenbank festgelegt. Hierfür wird
davon ausgegangen, dass Sie die Beschreibung im Datensatz \cmd{COMMENT1}
gespeichert haben (siehe Konfigurationsoptionen der Mediendatenbank auf
Seite \pageref{Medien-Eigenschaften}).
Falls kein Kommentar eingetragen wurde, wird der Dateiname verwendet.

\ospitem{\ospsmarty{plugin\_mediainsert\_media.X.width, .height}}
Größe des Originalbildes (Breite, Höhe).

\ospitem{\cmd{\{\$plugin\_mediainsert\_media.X.thumbwidth,}}
\ospadditem{\cmd{.thumbheight\}}}
Größe des Vorschaubildes (Breite, Höhe).
\end{ospdescription}

\end{ospdescription}

\subsubsection{ZIP-Archive}

Wenn Sie die Konfigurationsoption \menu{ZIP archives unzipping} des Plugins
aktiviert haben und Ihr Server mindestens PHP 5.1.0 einsetzt, könnnen Sie ein
ZIP-Archiv mit mehreren Bildern in die Mediendatenbank hochladen.
Die ZIP-Datei wird automatisch auf dem Server entpackt, und alle darin
enthaltenen Dateien werden so hochgeladen, als hätten Sie diese einzeln eingestellt.

Bitte beachten Sie, dass das Entpacken großer ZIP-Dateien viele Ressourcen auf
dem Server bindet und eventuell zu Timeouts oder anderen Performanceproblemen
führen könnte. In diesem Fall müssen Sie die Dateien einzeln hochladen.

\subsubsection{Konfigurationsoptionen}

Die Konfigurationsoptionen des Plugins beinhalten lediglich die Möglichkeit,
eine von der normalen Serendipity-Konfiguration abweichende Größe der
Vorschaubilder einzutragen. Bei den üblichen Vorschaubildern in Serendipity
wird die größte Seite (Höhe oder Breite) eines Bildes für die Verkleinerung
herangezogen. Mittels der beiden Konfigurationsoptionen jedoch können Sie ganz
gezielt ein Format für die Vorschaubilder festlegen, falls Sie z.\,B.\ die
Proportionen eines Bildes nur horizontal statt vertikal beschränken wollen.

%Wenn Sie die Option \menu{ZIP archives unzipping} aktivieren, erlaubt Ihnen das
%Plugin das Hochladen von ZIP-Archiven. Diese werden auf dem Server automatisch
%entpackt, und alle darin enthaltenen Dateien werden in die Mediendatenbank eingestellt.
%FM@GH: Wiederholung

Weiterhin gibt Ihnen das Plugin die Möglichkeit, festzulegen, ob die Erkennung
der XML-Bilderserien innerhalb des \emph{Eintrags} oder \emph{Erweiterten
Eintrags} zugelassen werden soll. So können Sie kontrollieren, dass Bilderserien
von Ihren Redakteuren z.\,B.\ nicht auf der normalen Übersichtsseite des Blogs
eingesetzt werden.


%revised
\section{Auswahl an Profi-Plugins}

Serendipity bietet besonders für Entwickler eine größere Zahl an
komplexen und flexiblen Plugins. Eine kleine Auswahl wird auf den
folgenden Seiten vorgestellt. Auch für Einsteiger in die Weblog-Szene
könnte es interessant sein, einmal über den Tellerand zu
blicken, um zu sehen, welche Möglichkeiten sich eröffnen, wenn Sie
sich tiefer in Serendipity einarbeiten.

\index{Plugins!Show entries via JavaScript}%
\index{Plugins!serendipity\_event\_backend}%
\index{Eintrag!auf fremden Seiten einbinden}%
\subsection{Show entries via JavaScript\newline serendipity\_event\_backend}

Dieses Plugin bietet eine JavaScript-basierte Schnittstelle an, um
Blog"=Einträge auf unabhängigen Seiten über einen Hintergrundaufruf
einzubinden.

Sobald das Plugin installiert ist, kann man eine spezielle URL aufrufen,
die abhängig von bestimmten URL-Parametern Blog-Einträge mittels JavaScript
ausgibt. Diese Art der Einbindung arbeitet ähnlich wie die Benutzung von
GoogleAds oder anderen JavaScript-\emph{Widgets}.

Anwendung findet dieses Plugin dann, wenn Sie die Inhalte Ihrer
Blog-Artikel auf Webseiten einbinden wollen, auf denen Serendipity
nicht installiert ist.
Zwar könnten Sie dies auch durch die Einbindung des RSS-Feeds
erledigen, aber dies ist oft mit Programmieraufwand verbunden. Auch das
Einbinden des Serendipity-PHP-Frameworks (falls die einbindenden
Webseiten auf demselben Server wie das Blog liegen) wäre eine 
mit zusätzlichem Aufwand verbundene Methode.

Standardmäßig können Sie nach der Installation des Plugins eine URL wie
\cmd{http://www.example.com/serendipity/index.php?/plugin/backend}
aufrufen. Diese URL gibt JavaScript-Befehle aus, die die Inhalte der
letzten Blog-Einträge enthalten. Daher ist diese URL nicht zum Aufruf im
Browser gedacht, sondern Sie sollten sie wie folgt in Ihre HTML-Seite
einbauen:

\input{snippets/backend.tex}

Wenn Sie diese HTML-Datei als \cmd{test.htm} auf einem beliebigen Server
speichern und aufrufen, sollten Sie auf dieser Seite die mittels
JavaScript eingebundenen Blog-Einträge sehen können.

Dies können Sie beispielsweise benutzen, wenn Sie Webseiten betreiben,
die nicht mit Serendipity betrieben werden (Werbeportale, Firmenseiten,
private Seiten ihrer Mitarbeiter), und auf denen Sie gerne Blog-Artikel
ausgeben möchten.

Um gezielt bestimmte Artikel auszulesen, bietet das Plugin mehrere
URL-Parameter an. Standardmäßig werden nur Links zu den Blog-Einträgen
sowie deren Titel angezeigt. Eine Ausgabe des Plugins sähe im
JavaScript-Code so aus:

\begin{ospcode}
document.write('<a
href="http://www.example.com/serendipity/archives/1-isotopp-rock0rz.html
">Blog-Huldigung</a><br/>');
\end{ospcode}

Um diese Ausgabe zu beeinflussen, können Sie die folgenden URL"=Parameter
mittels
\cmd{http://www.example.com/serendipity/index.php?/plug\-in/backend\&variable1=wert1\&variable2=wert2\ldots}
aufrufen  -- Variablen sind mit \cmd{\&} voneinander getrennt:

\begin{ospdescription}
\ospitem{\cmd{\&category=\cmdvar{X}}}
Beschränkt die Ausgabe der Artikel auf eine spezielle Kategorie.
\cmdvar{X} entspricht dabei dem Namen einer Kategorie.

\ospitem{\cmd{\&categoryid=\cmdvar{X}}}
Beschränkt die Ausgabe der Artikel auf eine (oder mehrere) spezielle
Kategorie(n). \cmdvar{X} entspricht dabei der ID einer Kategorie. Mehrere
Kategorie-IDs können durch ein Semikolon (\cmd{;}) voneinander getrennt
werden.

\ospitem{\cmd{\&authorid=\cmdvar{X}}}
Beschränkt die Ausgabe der Artikel auf einen speziellen Autor.
\cmdvar{X} enthält die ID des gewünschten Autors. Um mehrere Autoren
einzubeziehen, können Sie deren IDs durch ein Semikolon (\cmd{;})
voneinander trennen.

\ospitem{\cmd{\&num=\cmdvar{X}}}
Beschränkt die Anzahl der Artikel auf \cmdvar{X} Stück.

\ospitem{\cmd{\&order=\cmdvar{X}}}
Gibt die Reihenfolge der Artikel an. \cmdvar{X} kann entweder \cmd{asc}
(aufsteigend) oder \cmd{desc} (absteigend) enthalten.

\ospitem{\cmd{\&showdate=\cmdvar{X}}}
Wenn der Wert \cmd{showdate=1} übermittelt wird, gibt das JavaScript das
Datum eines Beitrages mit aus.

\ospitem{\cmd{\&dateformat=\cmdvar{X}}}
Bei gesetztem \cmd{showdate}-Parameter bestimmt die Variable
die Formatierung des Datums. Standardmäßig wird das
Format \cmd{Y-m-d} (Jahr-Monat-Tag) benutzt. Gültige Platzhalter finden
Sie in der PHP"=Dokumentation zum
\cmd{date()}-Befehl\footnote{\cmd{http://www.php.net/date}}.

\ospitem{\cmd{\&showtime=\cmdvar{X}}}
Wenn der Wert \cmd{showtime=1} übermittelt wird, gibt das JavaScript die
Uhrzeit eines Beitrages mit aus.

\ospitem{\cmd{\&timeformat=\cmdvar{X}}}
Bei gesetztem \cmd{showtime}-Parameter bestimmt die Variable
 die Formatierung der Uhrzeit eines Eintrags.
Standardmäßig wird das Format \cmd{g:ia} (Stunde:Minute am/pm) benutzt.
Gültige Platzhalter finden Sie in der PHP-Dokumentation zum
\cmd{date()}-Befehl. Sie können die Platzhalter zur Uhrzeit-Formatierung 
jedoch auch über die Variable \cmd{dateformat} mitbestimmen. Wenn Sie 
sowohl \cmd{dateformat} als auch \cmd{timeformat} übermitteln, 
werden in der Datumsausgabe des Plugins beide Platzhalter benutzt.

\ospitem{\cmd{\&point=\cmdvar{X}}}
Die URL-Variable kann eine beliebige Zeichenkette (ohne
HTML!) enthalten, die zur Trennung der einzelnen Artikel benutzt wird.
So können Sie beispielsweise \cmd{point=*} benutzen, um vor jedem Artikel
einen Stern auszugeben.

\ospitem{\cmd{\&details=\cmdvar{X}}}
Wenn Sie die Variable \cmd{details=1} benutzen, bindet das Plugin nicht
nur den Link des Artikels ein, sondern auch den vollständigen
Blog-Artikeltext (ohne den erweiterten Eintrag).

\end{ospdescription}

Etwaige Sonderzeichen für die Werte der Variablen (beispielsweise
Kategorienamen) müssen mit URL-Sonderzeichen ersetzt werden. Aus dem
Kategorienamen \emph{Thundercats und Mäuse} würde daher der Wert
\cmd{Thundercats+""und+M\%E4use}. Die PHP-Funktion \cmd{urlencode}
kann Variablen entsprechend kodieren, siehe
\cmd{http://de2.php.net/urlencode}.

Wenn Sie also beispielsweise fünf Artikel der ersten Kategorie, aufsteigend
sortiert, inklusive Artikeltext mit deutschem Datumsformat anzeigen
wollen, müssen Sie folgende URL einbinden:

\begin{ospcode}
http://www.example.com/serendipity/index.php?/plugin/backend\&categoryid=
1\&details=1\&num=5\&order=asc\&showdate=1\&dateformat=d.m.Y+H:i
\end{ospcode}

Wenn das JavaScript erfolgreich in Ihrer Webseite eingebunden ist, können
Sie mittels der CSS-Klassen \cmd{.blog\_body} (Artikelinhalt),
\cmd{.blog\_hr} (Artikeltrenner), \cmd{.blog\_author} (Autorname),
\cmd{.blog\_date} (Artikeldatum), \cmd{.blog""\_title} (Artikeltitel),
\cmd{.blog\_point} (Artikeltrenner) und \cmd{.blog\_link}
(Hyperlink) die Formatierung der Ausgabe individuell beeinflussen.

Wollen Sie die  Ausgabeformatierung generell ändern, können Sie die
 Datei
\cmd{plugins/serendipity\_event\_backend/serendipity\_event\_backend.""php}
bearbeiten und am Ende der Datei die JavaScript
\cmd{document.writeln}-Zeilen anpassen.

In den Konfigurationsoptionen des Plugins können Sie einstellen, über
welchen Plugin-Pfad (\cmd{index.php?/plugin/\cmdvar{backend}}) das
JavaScript aufgerufen wird. Anstelle von \cmd{backend} können Sie
auch einen beliebigen anderen Pfad konfigurieren. Dieser Pfad sollte
jedoch lediglich die Buchstaben A bis Z und Zahlen enthalten --
Sonderzeichen, Unterstriche, Schrägstriche und andere könnten Probleme
verursachen.

\index{Plugins!Textformatierung: Smarty Markup}%
\index{Plugins!serendipity\_event\_smartymarkup}%
\subsection{Textformatierung: Smarty Markup\newline serendipity\_event\_smartymarkup}
\label{smartymarkup}%
\index{PHPCode@PHP-Code!in Artikeln}%
\index{Smarty-Code!in Artikeln}%

Serendipity erlaubt aus Sicherheitsgründen nur HTML und Klartext in
Beiträgen und Seitenleisten-HTML-Klötzen.
Bei freier Verwendung von PHP-Code könnten Redakteure beliebigen Code
einschleusen, der sogar dazu führen könnte, dass die vollständige
Serendipity-Datenbank gelöscht wird.

Dennoch reizt die Flexibilität, die man mit eigenem
Programmiercode in einem Blog-Artikel erreichen könnte. Dank JavaScript
und HTML kann man zwar bereits einiges umsetzen, aber nun mal nicht das,
was man mittels PHP programmieren könnte: Einbindung von Umfragen in
einen Artikel, Einlesen von Dateien auf dem Server, uhrzeitabhängige
Einbindung unterschiedlicher Inhalte -- grundsätzlich alles, soweit Ihre
Vorstellungskraft reicht.

\index{PHPCode@PHP-Code!in Artikeln}%
Das Plugin \emph{Textformatierung: Smarty Markup}
kann diesem Problem etwas Abhilfe schaffen. Es erlaubt zwar nicht, rohen PHP-Scriptcode in
Ihre Einträge einzufügen, aber dafür können Sie damit Smarty-Funktionen benutzen.

Sobald Sie das Plugin installiert haben, können Sie beliebige
Smarty"=Syntax in Ihren Einträgen verwenden (siehe Smarty-Dokumentation ab
Seite \pageref{Smarty-Templates}). Die Templates-Variablen des eigenen Artikels
können über das Array 
\index{Template-Variablen!\$smartymarkup\_eventData}%
\ospsmarty{smartymarkup\_eventData} (z.\,B.\
\ospsmarty{smartymarkup\_eventData.id}) aufgerufen werden.

Mittels der Smarty-Syntax können Sie auch Ihren eigenen PHP-Code als
Smarty-Funktion schreiben und diesen dann in Artikeln aufrufen. Diese
zusätzliche Hürde erfordert, dass Sie als Administrator via FTP Dateien
auf dem Server anpassen können (konkret sind die eigenen
Smarty-Funktionen in der Datei \cmd{config.inc.php} Ihres Templates
einzufügen). Sobald ein Administrator PHP-Dateien anpassen kann, kann man
auch davon ausgehen, dass er verantwortungsvoll mit eigenem PHP-Code
umgehen kann.

Mit der Smarty-Syntax können Sie zusätzlich alle von Serendipity
bereitgestellten Smarty-Funktionen ansprechen.

Ein großer Vorteil des Smarty-Markups ist, dass Sie diesen auch gezielt
für statische Seiten (siehe Seite \pageref{staticpage})
freischalten können. Denn gerade in statischen Seiten könnten
Zusatzfunktionen, die nur mittels PHP umzusetzen sind, sehr hilfreich
sein.

In vielen Fällen reicht die Benutzung von Smarty-Funktionen bereits aus,
so dass Sie kein eigenes Serendipity-Plugin entwickeln müssen. Nutzen Sie
diese Flexibilität gezielt, um beispielsweise in HTML-Klötzen der
Seitenleiste eigene PHP-Funktionen aufzurufen oder Ihr eigenes
PHP-Framework in Serendipity zu integrieren.

In den Konfigurationsoptionen des Plugins können Sie gezielt einstellen,
für welche Eingabemöglichkeiten (Eintrag, erweiterter Eintrag,
Kommentare, HTML-Klotz, statische Seiten) die Smarty-Syntax zugelassen
wird. Nur in besonderen Fällen sollten Sie Smarty-Funktionen auch für
Benutzerkommentare freischalten -- auch die Smarty-Syntax birgt
Sicherheitsrisiken, die böswillige Besucher über Kommentare ausnutzen
könnten.

\index{Plugins!Textformatierung: Eintragsdaten einfügen}%
\index{Plugins!serendipity\_event\_includeentry}%
\index{Blog-Artikel!verknüpfen}%
\index{Include Entry}%
\index{Artikelpool}%
\subsection{Textformatierung: Eintragsdaten einfügen\newline serendipity\_event\_includeentry}
\label{includeentry}

Das Plugin \emph{Textformatierung: Eintragsdaten einfügen} bietet trotz
Klassifizierung als \emph{Textformatierungs-Plugin} 
zahlreiche und flexible Funktionen. Mithilfe dieses Plugins können Sie
Daten bestehender Blog-Einträge in anderen Einträgen einbinden, einen
Artikelpool (sog. \emph{Template-Blocks}) zum Anhängen an einen Eintrag
verwalten und auch Vorlagen für neue Beiträge erfassen. Alle drei
Möglichkeiten sind voneinander unabhängig einsetzbar.

Nach der Installation des Plugins finden Sie einen neuen Menüpunkt
\menu{Einträge\sm Template-Blocks} im Backend. In diesem Bereich sehen
Sie eine zweigeteilte Seite: Links können Sie Vorlagen für neue
Blog-Einträge (\emph{Templates}) verwalten, in rechten Teil können Sie den
Artikelpool (\emph{Blocks}) bearbeiten.

Um eine neue Artikelvorlage zu erstellen, müssen Sie im linken Bereich
unter \menu{Select Template} das Auswahlfeld auf \menu{Neuer Eintrag}
stellen und auf den Button \menu{Los!} klicken. Danach können Sie in der
Folgeseite einen Titel, einen Eintrag und den erweiterten Eintrag
festlegen, den Sie als Artikelvorlage speichern wollen. Diese Vorlage
können Sie beispielsweise benutzen, um immer einheitliche Blog-Artikel zu
erstellen. So können Sie für Blog-Artikel zu Filmberichten bereits ausfüllbare
HTML-Tags vorsehen, die die Links zu der Film-Homepage enthalten und eine
grobe Gliederung von Überschriften (\emph{Der Inhalt}, \emph{Die
Schauspieler}, \emph{Mein Fazit}) vorbereiten. Auch wenn Sie spezielle
HTML-Konstrukte für Ihre Blog-Artikel vorsehen, könnten Sie diese als
Vorlage speichern, um denselben HTML-Code nicht manuell für jeden neuen
Eintrag erstellen zu müssen.

Um einen neuen Blog-Artikel auf Basis einer Vorlage zu erstellen, stellen
Sie unter \menu{Einträge\sm Template-Blocks} das
Auswahlfeld unter \menu{Select Template} auf die gewünschte Vorlage
und klicken dann \menu{Use Template}. Sie gelangen auf die bekannte Oberfläche zum Erstellen eines
Blog-Eintrages; die Felder \emph{Titel, Eintrag} und \emph{Erweiterter Eintrag} 
sind korrekt vorausgefüllt.

Über die Template-Blocks-Oberfläche können Sie  Vorlagen auch
bearbeiten oder löschen, indem Sie das Auswahlfeld auf die gewünschte
Vorlage setzen und den Button \menu{Los!} oder \menu{Löschen} anklicken.

\index{Blocks}%
Ähnlich wie die Verwaltung der Vorlagen können Sie sogenannte
\emph{Blocks} erstellen (und auch nachträglich bearbeiten und löschen).
Ein Block stellt dabei einen Datensatz dar, den Sie (wie auch Vorlagen)
mit \emph{Titel, Eintrag} und \emph{Erweitertem Eintrag} ausfüllen
können. Im Gegensatz zu einer Vorlage ist ein Block jedoch ein
eigenständiger Datensatz, der in einen Blog-Artikel eingebunden werden
kann.

Blöcke können Sie dazu verwenden, häufig wiederkehrende Elemente 
nahtlos an einen Artikel anzubinden. Wiederkehrende Elemente sind
beispielsweise Werbeblöcke, Kontaktformulare, Disclaimer und andere
rechtliche Hinweise. Grundsätzlich ist hier alles denkbar, was Sie mehr
als einmal in einen Artikel einfügen wollen.

Die Einbindung solcher Blöcke erfolgt über die gewohnte Oberfläche zur
Erstellung eines neuen Blog-Artikels. Dort finden Sie im Bereich
\menu{Erweiterte Optionen} einen Abschnitt namens \menu{Attach a static
Block}. Darunter wird ein Auswahlfeld dargestellt, aus dem Sie einen
vorhandenen Block auswählen können.

Der Inhalt eines Blocks wird dabei im Frontend unterhalb des
Eintragstextes (mittels der Smarty-Variable
\cmd{\{\$entry.display\_dat\}}) eingebunden. Über die Template-Datei
\cmd{entries.tpl} können Sie die Positionierung dieser Smarty-Variable
jedoch auch frei beeinflussen. Für flexiblere Seitengestaltungen können Sie
zusätzlich den eingebundenen Block über die Variable
\index{Template-Variablen!\$entry.entryblock}%
\cmd{\{\$entry.entryblock\}}) umpositionieren.

\index{Template-Dateien!plugin\_staticblock.tpl}%
Bei der Bearbeitung eines Blocks können Sie zwei Sonderoptionen festlegen. Zum
einen bestimmt die Option \menu{Template (Smarty)}, welche Template-Datei zur
Darstellung eines Template-Blocks benutzt wird. Diese Datei legt fest, wie der
von Ihnen angelegte Template-Block innerhalb Ihres Blog-Artikels formatiert wird.
Die Standarddatei \cmd{plugin\_staticblock.tpl}
ist recht einfach gehalten und gibt lediglich den Titel und Text mit
HTML-Div-Containern aus. Pro Block können Sie eine eigene Template-Datei
bestimmen, um so unterschiedliche Formatierungen für unterschiedliche Blöcke zu
erreichen. Damit können Sie rechtliche Hinweise grafisch anders darstellen als
beispielsweise Google-Ad-Werbungen.

Die zweite Sonderoption \menu{Textformatierung auf Block anwenden} gibt
an, ob der Text des jeweiligen Blocks durch andere
Textformatierungs-Plugins (beispielsweise Smiley-Konvertierung)
ausgewertet werden soll.

Wie eingangs erwähnt, ermöglicht das Plugin auch eine eigene
Textformatierung, mit der Sie in Blog-Artikeln beliebige Inhalte von
bestehenden anderen Artikeln einbinden können. Dies können Sie auslösen,
indem Sie in einem Artikel die Zeichenkette
\cmd{[s9y-include-entry:\cmdvar{X}:\cmdvar{Y}]} an gewünschter Stelle
einfügen. Ersetzen Sie dabei \cmdvar{X} durch die ID des bestehenden
Blog-Artikels und \cmdvar{Y} mit dem gewünschten Datenbankfeld, das Sie
auslesen wollen.

Als Beispiel hierfür folgender Blog-Artikel:

\begin{ospcode}
In meinem Blog-Artikel namens "[s9y-include-entry:1:title]" schrieb ich
damals:

[s9y-include-entry:1:body]
\end{ospcode}

Der Vorteil einer derartigen Einbindung ist, dass Sie einen älteren
Blog-Artikel ändern können und sich dieser automatisch auch in dem
referenzierenden Artikel ändert. Das einzig Umständliche an dieser
Einbindungsart ist, dass Sie die ID eines Artikels von vornherein wissen
müssen (diese ist meist Bestandteil des Permalinks Ihres Eintrags).

Um auf die \emph{Erweiterten Eigenschaften} eines Artikels zuzugreifen, können
Sie die Syntax \cmd{[s9y-include-entry:1:prop=ep\_Video]} verwenden, um
beispielsweise ein angehängtes Video (siehe Podcast-Plugin, Seite
\pageref{podcast}) einzubinden. Sämtliche Feldnamen (wie \cmd{body}) entsprechen
hierbei den Datenbank"=Spaltennamen der Tabelle \cmd{serendipity\_entries} bzw.
\cmd{serendipi\-ty\_entryproperties}.

Auch Template-Blocks können Sie in einem Blog-Artikel mit einer ähnlichen
Syntax einbinden. Dies funktioniert unabhängig von dem vorher
beschriebenen Anhängen eines Template-Blocks an einen Artikel:

\begin{ospcode}
And now over to something completely different: Werbung!

[s9y-include-block:1:body]
\end{ospcode}

Dies würde den Text des ersten Template-Blocks in den Artikel einfügen.
Meist ist jedoch gewünscht, die vollständig geparste Template-Datei
(standardmäßig \cmd{plugin\_staticblock.tpl}) des Template-Blocks
auszugeben. Dies erreichen Sie mittels:

\begin{ospcode}
[s9y-include-block:1:template]
\end{ospcode}

Der besondere Feld-Bezeichner \cmd{template} löst also die Rückgabe des
geparsten Templates aus. Andernfalls stehen die Feldnamen \cmd{title,
body, extended, author, authorid, last\_modified} und \cmd{timestamp} zur\osplinebreak{}
Verfügung.

Abgesehen von diesen zahlreichen Einbindungsarten bietet das Plugin auch
noch eine Fülle von globalen Konfigurationsoptionen an:

\begin{ospdescription}

\ospitem{\menu{Show random blocks, Kategorien}}
Das Plugin ermöglicht es, zufällig einen beliebigen Block unterhalb eines
Artikels einzufügen (unabhängig von möglicherweise manuell eingefügten
Template-Blocks).

Solche zufälligen Blöcke können Sie verwenden, wenn Sie beispielsweise
einen großen Pool an Werbebannern und Ähnlichem angelegt haben.
Aktivieren Sie die Option \menu{Show random blocks}, wenn Sie diesen
Zufallsblock verwenden wollen.

Die Auswahl der Kategorien bezieht sich bei aktivierter Option darauf,
dass Zufallsblöcke nur dann gezeigt werden, wenn der Besucher sich gerade
im Frontend in einer speziellen Kategorie aufhält.

Mithilfe dieser Einschränkung könnten Sie daher die Werbeblöcke nur in
gewünschten Kategorien einblenden. Standardmäßig sind alle Kategorien
aktiviert, daher werden Zufallsblöcke überall angezeigt. Der Eintrag
\menu{[Keine Kategorie]} im Auswahlfeld entspricht dabei der
Übersichtsseite. Wenn Sie keine Zufallsblöcke in der Übersichtsseite
anzeigen wollen, heben Sie die Auswahl dieser Option einfach auf. Mehrere
Kategorien können Sie in dem Mehrfach-Auswahlfeld mit gedrückter
\taste{Strg/Apfel}-Taste und einem Mausklick aktivieren.

\ospitem{\menu{First entry, Skip entries}}
Wenn Sie die Option \menu{Show random blocks} aktiviert haben, können Sie
mit der Option \menu{First entry} festlegen, nach dem wievielten Artikel
die Anzeige eines Zufallblocks beginnen soll.

Wenn Sie hier die Zahl \cmd{2} eintragen, wird erst nach dem zweiten Artikel in
der Übersicht eine Werbung angezeigt. Mit der Option \menu{Skip entries}
legen Sie fest, nach jedem wievielten Artikel ein zufälliger Block 
eingebunden werden soll. Die Zahl \cmd{2} würde bewirken, dass nur nach 
jedem zweiten Eintrag ein Block eingebunden wird.

\ospitem{\menu{Allow multiple blocks}}
Bei aktivierter Zufallsfunktion kann es durchaus vorkommen, dass ein
zufälliger Block unter einem Artikel eingebunden wird, dem Sie
bereits manuell einen Template-Block zugewiesen haben.

Wenn Sie die Option \menu{Allow multiple blocks} aktivieren, wird ein
Zufallsblock jederzeit angehängt. Bei deaktivierter Option wird der
Zufallsblock ignoriert und nicht dargestellt.

\ospitem{\menu{Eintrag, Erweiterter Eintrag, Kommentar, HTML-Klotz}}
Über diese Felder legen Sie fest, in welchen Eingabemöglichkeiten das
Plugin die Syntax \cmd{[s9y-include-entry]} anbieten soll. Grundsätzlich
kann es ein Sicherheitsrisiko sein, wenn Sie die Syntax in Kommentaren
von Besuchern zulassen.
\end{ospdescription}

\subsubsection{Datenbanktabelle}
\index{Datenbank-Tabellen!serendipity\_staticblocks}%
Das Plugin erstellt die Datenbanktabelle \cmd{serendipity\_staticblocks}.\osplinebreak{} Darin
werden die \menu{Template-Blöcke} gespeichert:

\begin{ospdescription}
\ospitem{\cmd{id}} enthält eine fortlaufende ID, die jeden Template-Block identifiziert.
\ospitem{\cmd{title}} enthält den Betreff eines Template-Blocks bzw. einer Artikelvorlage.
\ospitem{\cmd{type}} gibt an, ob der Eintrag der Datenbank einen Template-Block
(\cmd{block}) oder eine Artikelvorlage (\cmd{template}) darstellt.
\ospitem{\cmd{body} }enthält den Eintragstext.
\ospitem{\cmd{extended}} enthält den erweiterten Eintrag.
\ospitem{\cmd{template}} enthält den Namen der Template-Datei zur Darstellung
des Blocks.
\ospitem{\cmd{apply\_markup}} legt fest, ob Textformatierungs-Plugins angewendet
werden sollen.
\ospitem{\cmd{author}} enthält den Namen des erstellenden Redakteurs.
\ospitem{\cmd{authorid}} enthält die ID des erstellenden Redakteurs.
\ospitem{\cmd{last\_modified}} enthält das Datum der letzten Änderung an der Vorlage
bzw. am Template-Block.
\ospitem{\cmd{timestamp}} enthält das Erstellungsdatum der Vorlage bzw. des
Template-Blocks.

\end{ospdescription}

\index{Plugins!Einfache Cached/Pregenerated Seiten}%
\index{Plugins!serendipity\_event\_cachesimple}%
\subsection{Einfache Cached/Pregenerated Seiten\newline
serendipity\_event\_cachesimple}
\label{cachesimple}%
\index{Cache}%
Serendipity ist aufgrund seiner hohen Flexibilität und Dynamik leider
wenig ressourcenschonend. An vielen Stellen des Systems können Plugins
eingreifen und abhängig vom eingeloggten Benutzer unterschiedliche
Inhalte anzeigen.
Das Plugin \emph{Erweiterte Eigenschaften für Artikel} (siehe Seite
\pageref{entryproperties})
kann zwar die Ausführung der Textformatierungs-Plugins
beschleunigen, gilt aber nicht für den kompletten Seitenaufruf.

Das Plugin \emph{Einfache Cached/Pregenerated Seiten} ist daher ein recht
einfaches Plugin, das in den generellen Seitenaufbau eines
Serendipity-Blogs eingreift. Ein Seitenaufruf sieht folgende
Reihenfolge\footnote{Dies ist eine verkürzte Darstellung. Die 
technischen Details finden Sie im Kapitel \ref{workflow} ab Seite
\pageref{workflow}.} vor:

\begin{osplist}
  \item Aufruf der Webseite durch den Besucher.
  \item Laden der Funktionsdateien von Serendipity (Dateien im \cmd{include}"=Verzeichnis).
  \item Herstellung einer Datenbankverbindung.
  \item Laden der globalen Serendipity-Konfiguration aus der
      Datenbank.
  \item Laden der Plugin API und installierter Ereignis-Plugins.
  \item Laden der persönlichen Konfigurationsdaten bei eingeloggten
      Benutzern.
\item Analyse der aufgerufenen URL.
\item Zusammenstellung der Artikel/Daten aus Datenbanktabellen für
    die aufgerufene URL, parallel Ausführung etwaiger Plugins bei den
    jeweiligen Schritten.
\item Aufruf des Smarty-Template-Frameworks.
\item Laden und Kompilieren des eingestellten Templates.
\item Darstellung des Templates.
\end{osplist}

Obwohl dies relativ komplex aussieht, kann Serendipity einen derartigen
Workflow typischerweise in weitaus weniger als einer Sekunde ausführen,
so dass man pro Sekunde durchaus mehrere Besucher bedienen kann.

Das Caching-Plugin setzt nun bei Schritt 7 an und versucht für eine
aufgerufene URLs alle Folgeschritte zu sparen. Dabei geht das Plugin
davon aus, dass, wenn ein Besucher eine identische URL bereits vorher
aufgerufen hat, dieselbe Seite auch für den aktuellen Besucher gilt, und
gibt denselben Inhalt aus.

Daher speichert das Plugin bei jedem Seitenaufruf die ausgegebene Seite
im Verzeichnis \cmd{templates\_c} zwischen und gibt sie später aus. Erst
nach Ablauf einer Stunde oder beim Veröffentlichen eines neuen Artikels
wird der Zwischenspeicher erneut erzeugt.
Das Plugin bietet zwei Konfigurationsoptionen: \menu{Use seperate
IE/Mozilla caches?} und \menu{Force clients to maintain fresh copy}.

Die erste Option bewirkt, dass das Plugin für Internet Explorer
und Mozilla-Browser unterschiedliche Zwischenspeicher erstellt. Das ist
dann hilfreich, wenn Sie möglicherweise in Ihrem Template oder einem
PHP-Code eine Browser-Erkennung durchführen. Da das Plugin in den
Zwischenspeicher immer das übernimmt, was der erste Besucher durch seinen
Aufruf sieht, würde im Zwischenspeicher sonst, unabhängig vom Browser dieses
Besuchers, möglicherweise eine falsche Kopie landen.

Wenn Sie die Option \menu{Force clients to maintain fresh copy}
aktivieren, übermittelt das Plugin an den Browser des Besuchers eine
Uhrzeit, zu der die aktuell zwischengespeicherte Ausgabe nicht mehr
gültig ist und ersetzt wird (der sog. HTTP-\emph{Expires}-Header).
Dies hat den Vorteil, dass ein Browser dann selbständig entscheiden kann,
ob er eine Webseite aus dem Brow\-ser-Cache anzeigt oder vollständig aus
dem Blog abruft, und kann daher die Seitendarstellungsgeschwindigkeit bei
den Besuchern noch weiter beschleunigen.

Ist das Caching-Plugin aktiviert, gibt es weitere HTTP-Header aus, die
dafür sorgen, dass es einem Browser generell erlaubt ist, die Blog-Seiten
zwischenzuspeichern. In gut besuchten Blogs könnte das dazu führen, dass
neue Kommentare einem Besucher nicht direkt angezeigt werden, da dieser
immer noch eine alte Version der Seite von seinem Browser bezieht. Daher
gibt Serendipity ohne dieses Plugin immer der Aktualität den höchsten
Stellenwert und erlaubt solches Caching standardmäßig nicht.

Obwohl das Plugin mit der Abkürzung einer Seitenerzeugung einiges an
Arbeit sparen kann, gibt es dennoch zentrale Probleme:

\begin{osplist}
  \item Eine Browser-Anfrage mit HTTP-POST-Formulardaten kann nicht
      zwischengespeichert werden. Die meisten Spammer verwenden
      jedoch diese Daten, und daher wird für fast keinen Blog-Aufruf
      durch einen Spammer das Caching-Plugin aktiv. Daher wird also
      nach wie vor viel an Ressourcen an Spammer verschwendet.
  \item Die Caching-Funktionalität wird von einem Plugin eingebunden.
      Damit ein Plugin überhaupt aktiv werden kann, muss Serendipity
      schon zahlreiche Aktionen ausführen, die bereits viele
      Ressourcen verschlingen.
  \item Durch das Caching einer vollständigen Seite verliert das Blog
      zahlreiche Features für viele dynamische Plugins.
      Beispielsweise können Artikel, die nur von eingeloggten
      Besuchern gelesen werden können, nicht mehr dargestellt werden
      -- denn für Serendipity gibt es nun nur noch einen einzigen
      Besucher, dessen Login-Status nicht mehr abgefragt werden kann.
\end{osplist}

Ein technisch sinnvolles Caching, das dennoch die Flexibilität von
Serendipity beibehält, ist wohl nach heutigem Stand kaum möglich. Sollten
Sie Interesse an der Ausarbeitung anderer Caching-Konzepte haben, werden
Sie bei den Serendipity-Entwicklern sicher auf ein offenes Ohr stoßen,
denn Mitarbeit in diesem Bereich wird stark benötigt.

\index{Plugins!Community Rating}%
\index{Plugins!serendipity\_event\_communityrating}%
\subsection{Community Rating\newline serendipity\_event\_communityrating}

\index{Bewertungen}%
\index{Meinungsberichte}%
\index{Community}%
\index{Webservices}%
Das \emph{Community Rating}-Plugin bietet die Möglichkeit, einen
Blog-Artikel zu einem Meinungsbericht aufzuwerten. Wenn Sie einen Artikel
über einen Film, ein Produkt oder über bekannte Personen schreiben, können Sie den
Artikel gezielt über ein eigenes Feld bewerten und diese Wertung an
zentraler Stelle anzeigen.

Außerdem können die eigenen Bewertungen auch anderen Blogs zur Verfügung
gestellt werden, indem auf Meinungsbeiträge anderer Blogger zum selben
Produkt hingewiesen wird.

Das Plugin agiert daher auf mehreren Ebenen und ist mitunter komplex
einzurichten. Die folgenden Anweisungen sind daher eher für fortgeschrittene
Anwender konzipiert, Anfänger sollten vorher das Kapitel \ref{Smarty-Templates}
ab Seite \pageref{Smarty-Templates} über das Smarty-Templating lesen.

In der Konfiguration des Plugins vergeben Sie eine (frei wählbare)
Namensliste von Wertungsmöglichkeiten. Dabei ist es notwendig, ein
Produkt später eindeutig zu identifizieren, um eine in der Community
einheitliche Zuordnung herzustellen. Das Plugin schlägt daher
standardmäßig die Wertungsmöglichkeiten bei der IMDb\footnote{Internet
Movie Database, \cmd{http://imdb.com/}} und von Produkten bei
Amazon\footnote{\cmd{http://www.amazon.de/}} vor. Sie können hier
grundsätzlich jeden Bewertungstyp eintragen, benötigen aber später eine
zugehörige Webseite mit einer eindeutigen ID des bewerteten Produkts. Ein
Bewertungstyp darf keine Sonderzeichen (Umlaute oder Leerzeichen) enthalten.

Sobald Sie freie Namen für gewünschte Produktanbieter gewählt
haben, können Sie einen Blog-Artikel erstellen. Im Abschnitt
\emph{Erweiterte Optionen} sehen Sie für jeden konfigurierten
Produktanbieter ein Eingabefeld \menu{ID} und ein Eingabefeld
\menu{Rating}. In das ID-Eingabefeld tragen Sie die eindeutige ID
ein, die das bewertete Produkt bei dem Anbieter identifiziert. Im Feld
\menu{Rating} bestimmern Sie ein Bewertungskriterium (Schulnoten von 1
bis 6, Punkte von 1 bis 10 oder sogar Sternchen von * bis ***). Sinnvoll ist die Vergabe von Zahlen, da diese 
mathematisch verarbeitet werden können.

\index{Template-Funktionen!\$communityratingshow@communityrating\_show}%
Sobald der Artikel gespeichert wurde, ist das Produkt in der Datenbank mit
seiner ID zu dem jeweiligen Produktanbieter mit einer Punktzahl verbunden. Sie
können mittels Anpassung der eigenen Template-Dateien (siehe Kapitel
\ref{Smarty-Templates} ab Seite \pageref{Smarty-Templates}) folglich an
gewünschter Stelle (also auch in RSS-Feed-Template-Dateien!) eine Smarty-Funktion namens
\cmd{\{community\-ra\-ting\_show\}} einbinden. Diese Funktion kann auch 
dafür sorgen, dass Punktzahlen in grafische Icons umgewandelt werden. 
Diesem Funktionsaufruf kann man folgende Parameter mitgeben:

\begin{ospdescription}
\ospitem{\cmd{type}}
Der Parameter bestimmt den Produktanbieter, den Sie anzeigen
wollen. Für jeden Produktanbieter (wie \cmd{IMDB} und \cmd{Amazon})
müssen Sie \cmd{\{communityrating\_show type="{}IMDB"{}\}} und
\cmd{\{communityrating\_""show type="{}Amazon"{}\}} einzeln einbinden.

\index{Template-Dateien!communityrating\_\ldots.tpl}%
Für jeden verwendeten \emph{type} muss es in Ihrem Template-Verzeichnis
oder dem Verzeichnis des Community-Rating-Plugins eine Datei namens
\cmd{communityrating\_\cmdvar{type}.tpl} geben, die bestimmt, wie der 
jeweilige Block eines Produktanbieters formatiert wird.

\ospitem{\cmd{data}}
Der Parameter \cmd{data} muss das Array der freien
Artikeleigenschaften (\emph{Entry-Properties}) enthalten. Diese Variable
wird von Serendipity bereitgestellt, daher können Sie einfach darauf zugreifen.
Falls Sie den Aufruf der Produktbewertung unterhalb von
\cmd{\{\$entry.body\}} in der Datei \cmd{entries.tpl} einbinden,
können Sie \cmd{\{communityrating\_show data=\$entry.properties\}}
einfügen.

\ospitem{\cmd{url}}
Mit dieser Variable können Sie die URL eines fremden Blogs übergeben, bei
dem das Community-Rating-Plugin ebenfalls zum Einsatz kommt. So können
Sie von fest definierten Blogs deren Produktbewertung einbinden. Das
Plugin kann nicht automatisch erkennen, welche fremden Meinungen Sie
einblenden möchten, daher müssen Sie für jedes fremde Blog einen eigenen
Aufruf der Smarty-Funktion benutzen:

\begin{ospcode}
\{communityrating\_show
  url="{}http://example.com/serendipity/plugin/communityrating"{}
  data=\$entry.properties
  who="{}garvin"{}
  type="{}IMDB"{}
\}
\end{ospcode}

Die URL entspricht dabei immer der Serendipity-Plugin-URL plus
\cmd{/plugin/communityrating}. Bei Serendipity-Blogs ohne URL"=Umformung
wäre dies \cmd{index.php?/plugin/communityrating}.

Der Aufruf dieser URL mit den Parametern für den gewünschten Typ und die
Produkt-ID wird dann bei dem jeweiligen Blog die XML-Daten ausliefern,
die das Plugin benötigt, um die fremde Bewertung einzubinden.

\ospitem{\cmd{who}}
Dieser Parameter wird in Zusammenhang mit dem Parameter \emph{url}
benötigt. Wenn ein fremder Produktbericht angezeigt wird, soll dieser
üblicherweise mit einem anderen Inhalt oder einem anderen Layout
angezeigt werden als der eigene Produktbericht. Daher benutzt das Plugin
in so einem Fall nicht mehr nur die Template-Datei
\cmd{communi\-tyrating\_IMDB.tpl}, sondern
\cmd{communityrating\_IMDB\_\cmdvar{who}.tpl},\osplinebreak{} in der man gezielt auf das
jeweilige fremde Blog Formatierungen vornehmen kann.

\ospitem{\cmd{path}}
Dieser Parameter enthält den Pfad, in dem die Bewertungsbilder
gespeichert werden. Die Bewertungsbilder müssen in einem Unterverzeichnis
\cmd{img} liegen und der Benennung
\cmd{star\_\cmdvar{Typ}\_\cmdvar{Zustand}.png} entsprechen. Für den
Produktanbieter \emph{IMDB} müssen die Dateien
\cmd{img/""star\_IMDB\_full.png}, \cmd{img/star\_IMDB\_half.png} und
\cmd{img/star\_""IMDB\_zero.png} existieren. Die \emph{full}-Grafikdatei
enthält ein Symbol, das einen vollen Bewertungspunkt repräsentiert.
\emph{half} gibt einen halben Bewertungspunkt aus und \emph{zero} einen
leeren.

Das Standard-Bewertungssystem ist darauf ausgelegt, dass Sie im
\emph{Rating}-Feld für jeden Artikel eine Zahl von 0 bis 10 vergeben.
Jeweils zwei volle Punkte ergeben einen Stern, ein einzelner Punkt
entspricht einem halben Stern, und fehlende Punkte werden mit leeren
Sternen dargestellt. Es werden daher immer fünf Sterne angezeigt, die
entsprechend des vergebenen Ratings gefüllt sind. Sie können innerhalb
der Template-Dateien selbständig für die grafische Formatierung von
Bildern sorgen, wenn Sie ein eigenes System benutzen möchten.

\label{communityrating-escaped}%
\ospitem{\cmd{escaped}}
Wenn Sie den Parameter \cmd{escaped=true} setzen, wird die
Smarty"=Funktion die Rückgabe der Template-Datei im UTF-8-Format mit
escapten HTML-Sonderzeichen anleiten. Setzen Sie diesen Parameter, wenn
Sie die Smarty-Funktion innerhalb eines RSS-Feeds aufrufen.

\end{ospdescription}

Somit dient die zentrale Smarty-Funktion dazu, sowohl fremde als auch
eigene Produktbewertungen einzubinden. Pro Aufruf kann immer nur eine
Bewertung zu einem Produktanbieter von einem Benutzer eingebunden werden,
daher sind mehrere Aufrufe der Smarty-Funktion üblich. Wenn fremde
Meinungen eingebunden werden, speichert das Plugin diese Daten für eine
Woche im Verzeichnis \cmd{templates\_c} zwischen, damit die fremde URL
nicht zu häufig aufgerufen wird und dort Serverlast erzeugt.

Jeder Aufruf der Funktion wertet die zugehörige Template-Datei
\cmd{communi\-tyrating\_XXX.tpl} aus. Innerhalb dieser Datei können Sie
beliebige Smar\-ty- und HTML-Syntax einsetzen. Es stehen folgende
Smarty-Variablen zur Verfügung, die sich jeweils auf das betreffende
Produkt des jeweiligen Produktanbieters beziehen:

\begin{ospdescription}
\index{Template-Variablen!\$communityrating\_images}%
\ospitem{\cmd{communityrating\_images}}
Diese Variable enthält den HTML-Code für die zusammengesetzte
Sternchen-Grafik mit fünf Sternen, die anhand des Ratings gefüllt oder leer
sind.


\index{Template-Variablen!\$communityrating\_rating}%
\ospitem{\cmd{communityrating\_rating}}
In dieser Variable ist das \emph{Rating} des Produktes gespeichert. Hier
kann Ihre individuelle Produktbewertung stehen, falls Sie statt der
Punktzahl von 0 bis 10 lieber Noten von 1 bis 6 vergeben.

\index{Template-Variablen!\$communityrating\_type}%
\ospitem{\cmd{communityrating\_type}}
Diese Variable enthält den angeforderten Produktanbieter (bspw.
\cmd{IMDB} oder \cmd{Amazon}).

\index{Template-Variablen!\$communityrating\_id}%
\ospitem{\cmd{communityrating\_id}}
Die ID des bewerteten Produkts wird in dieser Variable gespeichert.

\index{Template-Variablen!\$communityrating\_foreign\_url}%
\ospitem{\cmd{communityrating\_foreign\_url}}
Wenn ein fremder Produktbericht angezeigt wird, enthält diese Variable
die URL des fremden Blogs, wo Sie den bewerteten Artikel finden.
\end{ospdescription}

Sehen Sie sich die dem Plugin beiliegenden
\cmd{communityrating\_.*}-Dateien an, um zu sehen, wie die Ausgaben
üblicherweise formatiert werden.

\index{Plugins!Microformats}%
\index{Plugins!serendipity\_event\_microformats}%
\subsection{Microformats\newline serendipity\_event\_microformats}

\index{Mikroformate}%
\index{Community}%
\index{Structured Blogging}%
Ähnlich wie das Community-Rating-Plugin ist \emph{Microformats} eher
ein Spielzeug für fortgeschrittene Benutzer.
\emph{Microformats} sind eine moderne Möglichkeit, um Metadaten zu
bestimmten Objekten in einer HTML-Seite einzubinden. Objekte können
Produkte, Termine, Events, Geburtstage, Filme und alles andere
darstellen. Die Metadaten zu diesen Objekten ergeben sich daraus -- sie
können eine Produktmeinung, eine Bewertung, weiterführende Infos, kleine
Bilder und vieles mehr enthalten. Auf der Webseite
\cmd{http://microformats.org/} sind viele dieser Formate aufgeführt.

Das Serendipity-Plugin namens \emph{Microformats} bindet zwei
Microformats an: \emph{hCalendar} und \emph{hReview}. Für beide Formate
gibt es Browser-Plugins, die die eingegebenen Metadaten auswerten und
speziell darstellen können.

\index{hCalendar}%
\emph{hCalendar} ermöglicht die Darstellung von Terminen und
bietet als Metadaten die Felder: Titel (\emph{summary/title}), Ort
(\emph{Location}), URL, den Anfangs- und Endzeitpunkt des Termins und
eine Beschreibung (\emph{Description}).

\index{hReview}%
\emph{hReview} erlaubt die Bewertung beliebiger Produkte. Als
Metadaten dafür stehen zur Verfügung: Produktname, Produkttyp (Auswahlfeld für
\emph{Produkt, Geschäft (Business), Event (Veranstaltung), Person, Ort,
Webseite, URL}), URL des bewerteten Gegenstandes, eine Bewertung in
Punkten, eine Zusammenfassung, eine vollständige Bewertung, der
Zeitpunkt der Bewertung und der Name des Bewerters.

Darüber hinaus kann man das Plugin mit weiteren Microformats später
relativ einfach aufrüsten. Der Vorteil von solchen Microformats liegt
darin, dass die Metadaten von Programmen (auch Suchmaschinen) gelesen
werden können und man so leicht eine universelle Produktdatenbank
erstellen kann. Je mehr Benutzer solche Metadaten angeben, desto
einfacher kann man in Zukunft z.\,B.\ alle Meinungsberichte zum Apple i\-Phone
suchen und eine Durchschnittsbewertung bilden. Für Ihre Leser hat es den
Vorteil, dass sie mittels Browser-Plugins schnell Termine in ihre eigene
Termindatenbank aufnehmen könnten. Die Möglichkeiten der Microformats
stecken noch in den Kinderschuhen, und die Zukunft bringt hier womöglich
noch viel mehr Flexibilität. Eine Initiative, dieses Format bei Bloggern
populär zu machen, ist das \emph{StructuredBlogging}-Projekt auf
\cmd{http://structuredblogging.org/}.

Alle Microformats können die Metadaten im Frontend beliebig formatiert
darstellen. Dies kann man mittels der Smarty-Template-Dateien
beeinflussen, die das Plugin in einem Standardformat mitliefert.

Das Microformats-Plugin bindet die Erfassung der Metadaten in die
Erstellungsmaske für einen Blog-Artikel im Bereich \emph{Erweiterte
Optionen} ein. Dort können Sie zwei Auswahlboxen aktivieren, die einem
Artikel jeweils ein \emph{hCalendar}- oder \emph{hReview}-Objekt (oder
beides) zuordnen. Wenn Sie eine solche Box aktivieren, werden die
Eingabeboxen darunter eingeblendet.

Damit die Metadaten, die Sie eingetragen haben, später im Frontend
dargestellt werden können, müssen Sie eine Smarty-Funktion an der
gewünschten Stelle einfügen. Dies geschieht üblicherweise über die
Template-Datei \cmd{entries.tpl} in der Nähe von \cmd{\$entry.body}. Dort
müssen Sie für jedes Microformat die Smarty-Funktion
\cmd{\{microformats\_show\}} aufrufen:
\index{Template-Funktionen!\$microformats@microformats\_show}%

\begin{ospcode}
  \{microformats\_show data=\$entry.properties type="{}hReview"{}\}
  \{microformats\_show data=\$entry.properties type="{}hCalendar"{}\}
\end{ospcode}

\index{Template-Dateien!hCalendar.tpl}%
\index{Template-Dateien!hReview.tpl}%
Der Aufruf dieser Funktion sorgt dafür, dass das Array mit den Eintrags-Metadaten
(\cmd{\$entry.properties}) an die Template-Datei des jeweiligen Microformats
(\cmd{hCalendar.tpl} oder \cmd{hReview.tpl}) weitergereicht wird. Die
jeweilige Template-Datei stellt dann die Metadaten in beliebiger Formatierung dar,
die jeweils verfügbaren Variablen können Sie am einfachsten dieser Datei
entnehmen.

Analog zum Community-Rating-Plugin lassen sich die Microformats in
RSS-Feed-Template-Dateien einbinden, indem Sie dem
Smarty-Funktionsaufruf den Parameter \cmd{escaped=true} hinzufügen (siehe
Seite \pageref{communityrating-escaped}).

In den Konfigurationsoptionen des Microformat-Plugins können Sie
Folgendes festlegen:

\begin{ospdescription}
\ospitem{\menu{Subnode hinzufügen}}
Nur wenn Sie diese Option aktivieren, bindet das Microformats-Plug\-in die
XML-Metadaten ein, die Browser-Plugins benötigen, um Ihre
eingegebenen Metadaten anzuzeigen. Die Einbindung erfolgt \emph{inline},
was bedeutet, das XML wird direkt innerhalb der HTML-Seite eingebunden.
Je nach Struktur Ihrer Webseite kann das jedoch dazu führen, dass die
Webseite nicht mehr XHTML-konform ist.
Die Struktur der XML-Metadaten wird ebenfalls über die Template-Dateien
\cmd{hCalendar.tpl} bzw. \cmd{hReview.tpl} bestimmt. Wenn sich diese
Microformats also in Zukunft kompatibler einbinden lassen, kann man die
Art der Einbindung so überarbeiten.

\ospitem{\menu{Zeitzone}}
Für \emph{hCalendar}-Einträge ist die Zeitzone, auf die sie sich beziehen,
sehr wichtig, damit internationale Benutzer einen Termin in ihre Zeitzone
umrechnen können. Stellen Sie daher im Auswahlfeld \menu{Zeitzone} die
korrekte Zone ein, in der Sie leben. Für Deutschland ist dies \menu{+1
(CET)}.

\ospitem{\menu{Maximale Punktzahl}}
\emph{hReview}-Einträgen können Sie bewerten. Die
maximal von Ihnen vergebene Punktzahl müssen Sie hier eintragen. Beachten
Sie dabei, dass die Punktzahl mit Dezimalstellen angegeben werden sollte
(damit auch 2.5 Punkte möglich sind).

\ospitem{\menu{Punktabstände}}
Die Abstände Ihrer Bewertungen müssen Sie hier eintragen. Wenn Sie also
nur ganze Punkte vergeben, tragen Sie 1.0 ein, andernfalls können auch
Werte wie 0.5 für Halb-Punktsprünge eingetragen werden.

\end{ospdescription}

Zusammen mit dem Microformat-Plugin wird auch ein Seitenleisten-Plugin
namens \emph{Kommende Termine} mitgeliefert. Mit diesem können Sie von
Ihnen eingetragene \emph{hCalendar}-Termine in der Seitenleiste
darstellen und auch manuell zusätzliche Termine (z.\,B.\ von
\cmd{http://upcoming.org}) eintragen.
\index{upcoming.org}%

Wenn Sie eigene Microformats einbinden wollen, müssen Sie dazu folgende
Veränderungen vornehmen:

\begin{osplist}
\item Eigene \cmd{hMicroformat.tpl} erstellen.
\item Die Plugin-Datei \cmd{microformatsBackend.inc.php} anpassen und
    dort einen Eingabe-Abschnitt für das neue Microformat einbinden.
\item In der Plugin-Datei \cmd{serendipity\_event\_microformats.php}
    an einigen Stellen die Besonderheiten des Formats festlegen.
    Folgende Methoden müssen dazu angepasst werden:
    \cmd{getSupportedProperties()}\osplinebreak{} (\cmd{\$supported\_properties}),
    \cmd{addProperties()} (\cmd{\$supported\_formats}), \cmd{case
    'backend\_preview'} (\cmd{\$supported\_formats}), \cmd{case
    'backend\_\osplinebreak{}display'} (\cmd{\$mf\_exist, \$itemtypes}).
\item In der Smarty-Funktionsdatei des Plugins (\cmd{smarty.inc.php})
    muss bei \cmd{microformats\_serendipity\_show()} für das neue Format die Variable
    \cmd{\$params['mf\_type']}  abgefragt werden.
\end{osplist}

\ospvacat


 

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "serendipity"
%%% End:
