%revised
\chapter{Der Serendipity-Kern}
\label{workflow}%

\index{Serendipity!Kernarchitektur}%
\index{Framework}%
Serendipity ist im Inneren ein Framework, das entsprechend der angeforderten
URL die gewünschte Aktion ausführt. Daher initialisiert sich bei jedem Aufruf
einer URL von Serendipity das gesamte Kernkonstrukt auf die immer gleiche Art
und Weise.

\section{Frontend}

Zentrale Anlaufstelle fast aller Aktionen im Frontend ist die
\cmd{index.php}-Datei. Egal ob ein einzelner Blog-Artikel, eine Übersicht oder
der Inhalt eines Plugins ausgegeben wird -- alle Ausgaben werden durch diese
Datei \emph{geroutet}. Auch bei der Verwendung von \emph{URL-Umformung} mittels
\cmd{mod\_re\-wri\-te} oder Ähnlichem werden alle Aufrufe über die
\cmd{.htaccess}-Datei im Hintergrund zur \cmd{index.php} weitergeleitet.

Aufgabe der \cmd{index.php}-Datei ist es nun, die Serendipity-Komponenten
\emph{zusammenzubauen}. Zuerst sendet diese Datei einige benötigte
HTTP"=Kopfzeilen und bindet die Datei \cmd{serendipity\_config.inc.php} ein.
Diese Datei ist das Herz des Frameworks, da sie sich darum kümmert, alle
benötigten Komponenten und Sourcecode-Dateien einzubinden und erforderliche
Konfigurationswerte einzulesen.

Dort werden einige PHP-Konstanten gesetzt, eine PHP-Session gestartet und die wichtigen
Serendipity-Stammpfade festgelegt. Daraufhin erfolgt die Einbindung der Datei
\cmd{include/compat.inc.php}. Hier werden die URL-Variablen korrekt zugewiesen
und abhängig von der Konfiguration des PHP-Servers bearbeitet. Zusätzlich wird
hier die zentrale \cmd{\$serendipity}-Variable erstmals instanziert. Auch werden
einige zentrale PHP-Funktionen definiert, die Serendipity im Folgenden
immer wieder benötigen wird.

Nachdem diese Datei abgearbeitet wurde, folgt in der
Datei \cmd{serendipity\_""config.inc.php} die weitere Definition des
\cmd{\$serendipity}-Arrays. Hier wird beispielsweise die Versionsnummer der
Software festgehalten, die Art der Fehlerbehandlung bestimmt, und Standardwerte
für einige der Serendipity"=Optionen werden vorbelegt.

Nachdem diese Variablen feststehen, ist es an der Zeit, den Sprachkern
nachzuladen. Dieser richtet sich nach der vom Besucher festgelegten Sprache.
Falls der Besucher ein angemeldeter Redakteur ist, wird dessen Sprachvariable
aus den persönlichen Einstellungen bezogen. Auch die konfigurierte
Browser-Sprache kann einen Einfluss darauf haben, in welcher Sprache Serendipity
mit dem Benutzer spricht. Die einmal festgelegte Sprache wird
daraufhin in der PHP-Session für den nächsten Aufruf gespeichert. Alle
sprachbezogenen Aktionen werden mittels der \cmd{include/lang.inc.php}-Datei
durchgeführt.

Nachdem nun die gewünschte Sprachdatei eingebunden wurde, kann Serendipity mit
dem Besucher interagieren. An dieser Stelle wird geprüft, ob Serendipity
überhaupt bereits installiert wurde (falls nicht, startet der Installationsprozess).

Als Nächstes setzt Serendipity die PHP-Include-Pfade so, dass alle zu
Serendipity gehörenden Dateien eingebunden werden können. Dies ist besonders dann
wichtig, wenn Serendipity in einer \emph{Shared Installation}
(siehe Seite \pageref{sharedinstall}) betrieben wird.

Nun kann Serendipity die zentrale Konfigurationsdatei
\cmd{serendipity\_con\-fig\_local.inc.php} einlesen. Hierin sind die
Zugangsparameter zur Datenbank enthalten. Wenn diese Zugangsparameter korrekt
gelesen wurden, kann eine Verbindung zur Datenbank hergestellt werden.

Die Einbindung der \cmd{include/functions.inc.php} sorgt dafür, dass sämtliche
PHP-Kernfunktionen Serendipitys geladen werden. Dazu werden weitere Dateien wie
\cmd{include/functions\_config.inc.php} eingebunden, die diese Funktionen
jeweils themenspezifisch bündeln (siehe auch Seite \pageref{s9yfiles}).

\longpage
Nun wird das \cmd{\$serendipity}-Array mit allen Konfigurationswerten der
Datenbank befüllt. Der Redakteur kann so mit der Benutzerdatenbank abgeglichen
werden, um einen gültigen Login zu erkennen und ggf. die persönliche
Konfiguration des Besuchers zu laden.

Als Letztes erfolgt in der \cmd{serendipity\_config.inc.php} der Aufruf der
Plugin-API (siehe Seite \pageref{pluginapi}). Beim ersten Aufruf werden 
alle installierten Plugins in den Speicher geladen und etwaige Aktionen ausgeführt.

Nachdem nun das Serendipity-Framework geladen wurde, kann der Ablauf der
\cmd{index.php} fortgesetzt werden. Hier werden weitere HTTP-Kopfzeilen
gesendet. 

Da nun der vollständige Zugriff auf die Datenbank möglich ist, kann Serendipity
abhängig von der Konfiguration der Permalinks prüfen, welche Seite der
Besucher angefordert hat. Dazu dienen zahlreiche \cmd{IF-Abfragen}, die den
Großteil dieser Datei ausmachen.

Jeder mögliche Ausgabefall (Archiv-Übersicht, Kategorie-Übersicht,
Einzelartikel, Volltextsuche \ldots) wird hier mit der aktuellen URL
(\cmd{\$uri}) verglichen. Falls eine der IF-Bedingungen zutrifft, ruft
Serendipity die für die Unterseite notwendigen Befehle ab.

Meist bestehen diese Befehle darin, benötigte Variablen vorzubelegen und
Komponenten der URL (Autor-ID, Kategorie-ID, Zeitraum der Archive \ldots)
auszulesen. Abschließend wird in beinahe jeder der IF-Bedingungen die Datei
\cmd{include/genpage.inc.php} aufgerufen, die für die Ausgabe einer
Template-Datei verantwortlich zeichnet.

In dieser Datei wird hauptsächlich die \emph{Smarty}-Bibliothek geladen, die für
die Auswertung der Template-Dateien zuständig ist. Serendipity reicht einige
Parameter an die dafür zuständige \cmd{serendipity\_smarty\_init()}-Funktion
weiter. Diese Funktion wird in der Datei \cmd{include/functions\_""smarty.inc.php}
deklariert. Sie setzt alle gewünschten Variablen und wertet anschließend etwaige
\cmd{config.inc.php}-Dateien Ihres Templates aus. Darüber können zusätzliche
Template-Optionen eingestellt werden. Sämtliche zusätzlichen Smarty-Modifier und
eigene Smarty-Funktionen werden an dieser Stelle des Ablaufs gesetzt, und
Standard-Serendipity-Variablen werden an die Templates weitergereicht.

Daraufhin kann Serendipity anhand der URL-Parameter den eigentlichen Inhalt der
Seite zusammenstellen. Die Funktion \cmd{serendipity\_fetchEn\-tries()} sorgt
dafür, dass die angeforderten Artikel aus der Datenbank eingelesen werden.
Daraufhin werden sie über die Funktion \cmd{serendipity\_""print\-Entries}
bearbeitet und letztlich an die erforderliche Template-Datei zugewiesen.

Nachdem die Datei \cmd{genpage.inc.php} den eigentlichen Seiteninhalt
aufbereitet hat (Smarty-Variable \ospsmarty{CONTENT}), kann die \cmd{index.php}-Datei als letzte
Maßnahme für die Ausgabe des Inhalts sorgen, indem sie den Darstellungsprozess
von \emph{Smarty} aufruft.

\section{Backend}

Der Ablauf im Backend ist beinahe identisch. Anstelle der \cmd{index.php} wird
hier jedoch immer die \cmd{serendipity\_admin.php} aufgerufen. Diese prüft den
Aufruf zusätzlich auf einen gültigen Login und stellt das Menü zusammen.
Anschließend wird abhängig von der gewählten Aktion im Backend die entsprechende
Include-Datei aus dem Verzeichnis \cmd{include/admin/} eingebunden. Diese Datei
führt die gewünschte Aktion aus (z.\,B.\ Verwalten von Einträgen) und liefert den
HTML-Teil zurück, der im rechten Bereich des Backends angezeigt werden soll.

Dieser HTML-Teil wird über die Template-Datei \cmd{admin/index.tpl} entsprechend
eingebunden und anschließend zusammen mit dem Menü und dem Kopfbereich ausgegeben.

Eine Übersicht über die Inhalte aller zu Serendipity gehörenden Dateien finden
Sie ab Seite \pageref{s9yfiles}.

\section{Sonderfälle}
 
Obwohl die meisten Serendipity-Ansichten entweder über das Backend
(also \cmd{serendipity\_admin.php}) oder Frontend (\cmd{index.php}) geroutet werden,
gibt es einige Sonderfälle. Diesen Sonderfällen ist jedoch gemein, dass sie alle
das Serendipity"=Framework einbinden, um auf identische Funktionen und Plugins
zugreifen zu können.

\index{Trackbacks}%
\subsection{Kommentare, Trackbacks}
 
Eingehende Trackbacks (und Pingbacks) werden nicht über das zentrale Framework
abgearbeitet, sondern über eine eigenständige Datei \cmd{comment.""php}. Diese
bindet das Serendipity-Framework zwar ein, dient aber ansonsten aus Gründen der
Übersichtlichkeit ausschließlich der Abarbeitung von Trackbacks. Da diese einen
ressourcenintensiven Prozess darstellen, werden sie nicht über die zentrale
Datei bearbeitet. Dies erleichtert Logging und evtl. auch den Ausschluss des
Trackback-Mechanismus' bei Ressourcenproblemen (siehe Seite \pageref{commentphp}).

Falls Ihr Serendipity-Blog so konfiguriert ist, dass Kommentare in einem Popup
angezeigt werden, dient die \cmd{comment.php} auch zur Darstellung 
und Entgegennahme von Kommentaren. Ohne Popup-Darstellung übernimmt dies 
wie gewohnt die \cmd{index.php}-Datei, daher befindet sich hier
stellenweise duplizierter Code.

\index{wfwComment}%
Einen Sonderfall von Kommentaren stellen die sogenannten \cmd{wfwComments} dar. Sie
sind Teil eines Standards, der speziell für RSS-Reader ins Leben gerufen wurde.
Er erlaubt, dass man direkt vom RSS-Reader aus Kommentare zu einem Blog-Eintrag
verfassen kann, ohne dazu erst die URL des Blogs und dort ein
Kommentarfeld aufrufen zu müssen. Serendipity nimmt derartige Kommentare über die Datei
\cmd{wfwcomment.php} entgegen.

\subsection{Exit-Nachverfolgung}

Serendipitys Plugin zum \cmd{Externe Links zählen} (siehe Seite \pageref{trackexits})
dient zur statistischen Erfassung, auf welche Links Ihre Besucher klicken. Dabei
leitet Serendipity den Besucher auf die eigentlich gewünschte URL weiter. Damit
dies Ressourcen sparend geschehen kann, ist diese Funktionalität in der Datei
\cmd{exit.php} gekapselt.

\subsection{RSS-Feeds}

Da die Darstellung von RSS-Feeds unabhängig vom Frontend geschieht, ist diese Aufgabe
über die separate Datei \cmd{rss.php} geregelt.

\subsection{Mediendatenbank-Popup}

Die Mediendatenbank kann an einigen Stellen des Front- und Backends aufgerufen
werden und erfolgt meist als Popup. Um dies komfortabler und isolierter zu
verwalten, befindet sich der dafür notwendige Code in der Datei 
\cmd{serendipity\_admin\_image\_selector.php}.

\index{XML-RPC}%
\subsection{XML-RPC}

Serendipity unterstützt über ein Plugin die Möglichkeit, Blog-Artikel mittels
fremder Anwendungen zu erstellen, ohne dafür das Serendipity-Backend benutzen zu
müssen.

Hierfür wurde die Datei \cmd{serendipity\_xmlrpc.php} geschaffen. In früheren
Serendipity-Versionen war hier der vollständige Code enthalten, um die
gewünschte API zum Erstellen von Artikeln abzudecken. Nachdem dies als Plugin
ausgelagert wurde, dient die Datei nur noch als eine Art Grundgerüst, um das
Plugin aufzurufen.

\index{Serendipity!Dateien}%
\section{Serendipity-Dateien}
\label{s9yfiles}

Serendipity besteht aus einer größeren Menge an Dateien und Systembibliotheken:

\begin{ospdescription}
\ospitem{Stammverzeichnis} Das Stammverzeichnis enthält folgende Dateien:
\begin{ospdescription}
\ospitem{\cmd{.htaccess}}  Steueranweisungen für den Webserver
(\emph{URL"=Umformung} etc.) 
\ospitem{\cmd{comment.php}} stellt Kommentare/Trackbacks in einem Popup dar.
\ospitem{\cmd{exit.php}} leitet verfolgte URLs an das gewünschte Ziel weiter (bei
Verwendung des Plugins \emph{URL-Exits verfolgen}).
\ospitem{\cmd{index.php}} stellt den zentralen Anlaufpunkt für alle
Frontend"=Ausgaben dar.
\ospitem{\cmd{rss.php}} gibt RSS-Feeds aus.
\ospitem{\cmd{serendipity.css.php}} gibt die Stylesheets von Serendipity aus.
\ospitem{\cmd{serendipity\_admin.php}} stellt den zentralen Anlaufpunkt für alle
Backend-Ausgaben dar.
\ospitem{\cmd{serendipity\_admin\_image\_selector.php}} stellt das
Mediendatenbank"=Popup dar.
\ospitem{\cmd{serendipity\_config.inc.php}} lädt das Serendipity Framework.
\ospitem{\cmd{serendipity\_config\_local.inc.php}} enthält zentrale
Konfigurationswerte Serendipitys.
\ospitem{\cmd{serendipity\_define.js.php}} konvertiert einige PHP-Variablen, damit sie
in JavaScripts zur Verfügung stehen.
\ospitem{\cmd{serendipity\_editor.js}} stellt JavaScript-Funktionen der
Mediendatenbank bereit.
\ospitem{\cmd{serendipity\_xmlrpc.php}} bindet die Anlaufstelle für die XML-RPC API
ein.
\ospitem{\cmd{wfwcomment.php}} bindet eine Anlaufstelle für wfwComment-API-Aufrufe ein.
\end{ospdescription}

\ospitem{Verzeichnis \cmd{archives}}
Dient nur als Platzhalter für das symbolische Verzeichnis \cmd{archives}, das
Serendipity innerhalb der URL verwendet. Hier werden jedoch keine Dateien
gespeichert, sondern diese werden aus der Datenbank gelesen. Einige Plugins
speichern in diesem Verzeichnis temporäre Dateien.

\ospitem{Verzeichnis \cmd{bundled-libs}}
Enthält einige Fremd-Bibliotheken zur Erweiterung der Funktionen Serendipitys
(z.\,B.\ \cmd{PEAR}-Klassen und \cmd{Smarty}).

\index{Deployment}%
\ospitem{Verzeichnis \cmd{deployment}}
Enthält funktionsreduzierte Rumpf-Dateien für die \emph{Shared Installation}
(siehe Seite \pageref{sharedinstall}) von Serendipity. Diese entsprechen den 
Dateinamen des Stammverzeichnisses und binden die entsprechende Datei später ein.

\ospitem{Verzeichnis \cmd{docs}}
Enthält einige Dateien zur Dokumentation Serendipitys. Die Datei \cmd{NEWS}
enthält ein Protokoll von Änderungen zwischen den verschiedenen Versionen
Serendipitys. 

\ospitem{Verzeichnis \cmd{htmlarea}}
Enthält den Sourcecode des \cmd{HTMLArea}-WYSIWYG-Editors zur
Darstellung einer Microsoft Word-ähnlichen Oberfläche beim 
Bearbeiten von Artikeln (siehe Seite \pageref{wysiwyg}).

\ospitem{Verzeichnis \cmd{include}}
Enthält die zentralen Funktionskomponenten Serendipitys:

\begin{ospdescription}
\ospitem{\cmd{compat.inc.php}} enthält Bearbeitungsroutinen, die zur
Kompatibilitätswahrung und Vereinheitlichung verschiedener PHP"=Versionen nötig sind.
\ospitem{\cmd{functions.inc.php}} enthält zentrale Funktionen für Serendipity und
lädt die Unter-Funktionsdateien.
\ospitem{\cmd{functions\_calendars.inc.php}} enthält Funktionen zur Bearbeitung von
Datumsangaben und Zeitwerten.
\ospitem{\cmd{functions\_comments.inc.php}} enthält Funktionen zur Behandlung von Blog-Kommentaren.
\ospitem{\cmd{functions\_entries.inc.php}} enthält Funktionen zur Behandlung von
Blog-Artikeln.
\ospitem{\cmd{functions\_entries\_admin.inc.php}} enthält Funktionen zur Bearbeitung
von Blog-Artikeln im Backend.
\ospitem{\cmd{functions\_images.inc.php}} enthält Funktionen zur Behandlung von
Objekten der Mediendatenbank.
\ospitem{\cmd{functions\_images\_crop.inc.php}} enthält Funktionen zum Beschneiden
von Bildern (derzeit noch experimentell).
\ospitem{\cmd{functions\_installer.inc.php}} enthält Funktionen zur Installation Serendipitys.
\ospitem{\cmd{functions\_permalinks.inc.php}} enthält Funktionen zur Bearbeitung von
Permalinks/URL"=Werten.
\ospitem{\cmd{functions\_plugins\_admin.inc.php}} enthält Funktionen zur
Konfiguration von Plugins im Backend. 
\ospitem{\cmd{functions\_rss.inc.php}} enthält Funktionen zur Ausgabe von RSS-Feeds.
\ospitem{\cmd{functions\_smarty.inc.php}} enthält Funktionen zur Interaktion mit der
Smarty-Bibliothek.
\ospitem{\cmd{functions\_trackbacks.inc.php}} enthält Funktionen zur Annahme und
zum Versand von Trackbacks.
\ospitem{\cmd{functions\_upgrader.inc.php}} enthält Funktionen zum
Aktualisierungsvorgang für Serendipity.
\ospitem{\cmd{genpage.inc.php}} enthält Anweisungen zur Erstellung und zur Ausgabe von
Seiten im Frontend.
\ospitem{\cmd{lang.inc.php}} enthält Anweisungen zum Laden der notwendigen Sprachdateien.
\ospitem{\cmd{plugin\_api.inc.php}} enthält die Klassen der Plugin-Schnittstelle.
\ospitem{\cmd{plugin\_api\_extension.inc.php}} enthält erweiterte Funktionen, auf
die Plugins zurückgreifen\osplinebreak{} können.
\ospitem{\cmd{plugin\_internal.inc.php}} enthält eine Liste eingebauter Plugins,
die für Serendipity zur Verfügung stehen.
\ospitem{\cmd{template\_api.inc.php}} enthält die Klasse der Template"=Schnittstelle,
wenn eine andere Schnittstelle als Smarty zum Einsatz kommen soll (siehe Seite
\pageref{templateapi}).
\end{ospdescription}

\ospitem{Verzeichnis \cmd{include/admin}}
Enthält die Unterseiten des Backends:

\begin{ospdescription}
\ospitem{\cmd{category.inc.php}} enthält die Maske zur Bearbeitung von Kategorien.
\ospitem{\cmd{comments.inc.php}} enthält die Maske zur Bearbeitung von Kommentaren.
\ospitem{\cmd{configuration.inc.php}} enthält die Maske zur Konfiguration Serendipitys.
\ospitem{\cmd{entries.inc.php}} enthält die Maske zum Bearbeiten/Erstellen von
Blog"=Artikeln.
\ospitem{\cmd{entries\_overview.inc.php}} enthält die Maske für die Übersicht der Blog-Artikel.
\ospitem{\cmd{export.inc.php}} enthält die Maske zum Exportieren von Blog-Artikeln.
\ospitem{\cmd{groups.inc.php}} enthält die Maske zur Bearbeitung von Benutzergruppen.
\ospitem{\cmd{images.inc.php}} enthält die Maske zum Verwalten der Mediendatenbank.
\ospitem{\cmd{import.inc.php}} enthält die Maske zum Importieren von Blog-Artikeln.
\ospitem{\cmd{installer.inc.php}} enthält die Maske zur Installation Serendipitys.
\ospitem{\cmd{overview.inc.php}} enthält die Maske zur Startseite des Backends.
\ospitem{\cmd{personal.inc.php}} enthält die Maske zu den persönlichen Einstellungen.
\ospitem{\cmd{plugins.inc.php}} enthält die Maske zur Verwaltung von Plugins.
\ospitem{\cmd{templates.inc.php}} enthält die Maske zum Verwalten von Templates.
\ospitem{\cmd{upgrader.inc.php}} enthält die Maske zum Aktualisieren von Serendipity.
\ospitem{\cmd{users.inc.php}} enthält die Maske zur Verwaltung von Redakteuren.
\end{ospdescription}

\ospitem{Verzeichnis \cmd{include/admin/importers}}
Enthält die verschiedenen Import-Module für die Schnittstelle zu anderen
Blog-Systemen. Der Dateiname steht jeweils für das Blog"=System, die Datei
\cmd{generic.inc.php} enthält den RSS-Feed-Import.

\ospitem{Verzeichnis \cmd{include/db}}
Enthält die Funktionsbibliotheken zur Verwendung unterschiedlicher 
Datenbanksysteme. Die Datei \cmd{db.inc.php} enthält die systemübergreifenden
Funktionen, die anderen Dateien enthalten den Funktionssatz des jeweils
gleichnamigen Datenbanksystems.

\ospitem{Verzeichnis \cmd{include/tpl}}
Enthält einige Vorlagedateien zur Darstellung von Konfigurationsoptionen des
Blogs. Die \cmd{htacces\_\ldots.tpl}-Dateien enthalten Vorlagen für die
automatisch erstellte \cmd{.htaccess}-Datei, in Abhängigkeit von der gewählten
Form der URL-Umformung und der eingesetzten PHP-Version (mit/ohne
CGI-Einbindung). Die Datei \cmd{config\_local.inc.""php} enthält die Anweisungen
zur zentralen Blog-Konfiguration (siehe Seite \pageref{configlocal}) und
\cmd{config\_personal.inc.php} die persönlichen Einstellungen.

\label{lang-dir}%
\ospitem{Verzeichnis \cmd{lang}}
Enthält die Sprachdateien zur Übersetzung der Serendipity"=Meldungen. Das Kürzel
am Ende jeder Datei steht für die entsprechende Sprache (\cmd{de} = Deutsch,
\cmd{en} = Englisch usw.). Die Dateien \cmd{addlang.*}, \cmd{plugin\_""lang.php}
und \cmd{append.sh} sind nur für Entwickler gedacht, damit einfach neue
Sprachkonstanten in alle Dateien hinzugefügt werden können.

Innerhalb dieser Datei sorgt der PHP-Befehl \cmd{define()} dafür, einer
Konstante (erster Parameter) einen beliebigen Wert (zweiter Parameter)
zuzuordnen. Wenn einfache oder doppelte Anführungszeichen im Inhalt einer
Konstante vorkommen, müssen Sie darauf achten, diese mit einem Backslash (\textbackslash)
zu escapen:

\begin{ospcode}
\@define('KONSTANTENNAME1', 'Ich bin{}\textbackslash{}'s, der "{}Waldi"{}!');
\@define('KONSTANTENNAME2', ``Ich bin's, der
\textbackslash{}"{}Waldi\textbackslash{}"{}!');
\end{ospcode}

Serendipity setzt das \cmd{@}-Zeichen vor jeden \cmd{define()}-Aufruf, damit etwaige
doppelte Deklarationen einer Konstante keine Fehlermeldung provozieren.

Das Unterverzeichnis \cmd{UTF-8} enthält dieselben Dateien ein weiteres Mal,
jedoch entgegen zur nationalen Zeichensatzkonvertierung (meist ISO) im UTF-8-Zeichensatz.

\ospitem{Verzeichnis \cmd{plugins}}
Enthält die installierbaren Plugins. Der Name des jeweiligen Unterverzeichnisses
entspricht dem Namen der Plugin-Dateien. Hier abgelegte Plugins müssen zuerst
über das Backend installiert werden, bevor sie aktiv sind.

\ospitem{Verzeichnis \cmd{sql}}
Enthält Dateien mit SQL-Anweisungen. Die Datei \cmd{db.sql} enthält alle
Anweisungen, die bei der Installation Serendipitys ausgeführt werden. Diese
Datei enthält einige Variablen (eingefasst in geschweiften Klammern), die bei der
Installation automatisch entsprechend des Datenbank-Zielsystems in den korrekten
SQL-Dialekt übersetzt werden.

Die Dateien \cmd{db\_update\_X\_Y\_Z.sql} enthalten die SQL-Anweisungen, die
beim Aktualisieren von Serendipity automatisch ausgeführt werden sollen, um neue
Tabellen zu erstellen bzw. bestehende Tabellen anzupassen. Dabei steht \cmd{X}
für die vorher installierte Serendipity-Version und \cmd{Y} für die neue
Version. Bei einem Update werden alle Versionszwischenstände
ebenfalls ausgeführt. \cmd{Z} steht dabei für das verwendete
Datenbank-Zielsystem (MySQL, PostgreSQL oder SQ\-Lite).

\ospitem{Verzeichnis \cmd{templates}}
Enthält die verfügbaren Templates. Das Verzeichnis \cmd{carl\_contest} enthält
seit Serendipity 1.0 alle Standarddateien, die
verwendet werden, wenn ein Template-Verzeichnis nicht über eine entsprechende
Datei verfügt. Das Verzeichnis \cmd{default} enthält darüber hinaus weitere
Standarddateien, falls diese nicht im Verzeichnis \cmd{carl\_contest} liegen.
Diese beiden Sonderverzeichnisse sollten daher bei jeder
Serendipity"=Installation beibehalten und stets aktualisiert werden. Änderungen
an diesen Dateien sollten Sie niemals dort vornehmen, sondern stattdessen in
einer lokalen Kopie eines eigenen Template"=Verzeichnisses.

\ospitem{Verzeichnis \cmd{templates\_c}}
Enthält die von Smarty erstellten Temporärdateien mit in PHP-Code übersetzten 
Templates.

\ospitem{Verzeichnis \cmd{tests}}
\index{Unit-Tests}%
Enthält (rudimentäre) Unit-Test-Dateien für Serendipity.

\ospitem{Verzeichnis \cmd{uploads}}
In diesem Verzeichnis werden die Dateien der Mediendatenbank gespeichert.
\end{ospdescription}

\index{Serendipity!Funktionen}%
\section{Serendipity-Funktionen}

Auf eine ausführliche Beschreibung aller Serendipity-Funktionen muss aus
Platzgründen in diesem Buch verzichtet werden. Alle verfügbaren Parameter sowie
Rückgabewerte sind jedoch als PHPDoc-Kommentare oberhalb der
Funktionsdeklaration jeder Serendipity-Kerndatei enthalten und können dort
leicht nachgeschlagen werden. Der Name der Datei, in der sich die jeweilige Funktion
befindet, ist in der folgenden Liste aufgeführt.

Im Folgenden finden Sie eine Liste von gebräuchlichen Serendipity"=Funktionen,
die Sie bei der Entwicklung von Plugins und Ähnlichem häufig einsetzen werden.

\subsection{Zentrale Funktionen}
\label{zentralefunktionen}%
Zentrale Funktionen können an mehreren Stellen Serendipitys eingesetzt werden.

\begin{ospdescription}
\ospitem{\cmd{serendipity\_die()} (\cmd{include/compat.inc.php})}
Gibt eine (beliebige) Fehlermeldung aus, falls die reguläre Ausführung von
Serendipity unmöglich ist.

\ospitem{\cmd{serendipity\_mb()} (\cmd{include/lang.inc.php})}
Dient als Wrapper-Funktion, um Multi-Byte-Zeichensatzoperationen durchzuführen.
PHP bietet für derartige Multi-Byte-Sprachen (asiatische) spezielle Funktionen
an, was Serendipity für den Programmierer einfacher ansprechbar werden lässt. 

\ospitem{\cmd{serendipity\_serverOffsetHour()} (\cmd{include/functions.inc.php})}
Liefert einen UNIX-Zeitstempel zurück, der abhängig von der Konfiguration des
Servers in die richtige Zeitzone umgerechnet wurde.

\ospitem{\cmd{serendipity\_strftime(), serendipity\_formatTime()}}
\ospadditem{(\cmd{include/functions.inc.php})}
Konvertiert einen UNIX-Zeitstempel in ein lesbares Format und wendet etwaige
Zeitzonen-Umrechnungen an.

\ospitem{\cmd{serendipity\_walkRecursive()} (\cmd{include/functions.inc.php})}
Dient als Hilfsfunktion, um eine hierarchische Struktur innerhalb eines
eindimensionalen Arrays zu durchwandern und aufzubereiten. Dies wird vor allem
für verschachtelte Kategorien und Kommentare verwendet, die eine Verschachtelung
anhand eines \cmd{parent\_id}-Array-Schlüssels angeben.

Üblicherweise enthält z.\,B.\ die Liste von Kategorien keine hierarchische
Struktur, sondern jede Kategorie ist in eine eindimensionale Liste alphabetisch
einsortiert. Der Sinn der Funktion \cmd{serendipity\_""walkRecursive} ist es nun,
das Array später korrekt eingerückt darzustellen, so dass Unterkategorien
sequentiell direkt auf die Oberkategorie folgen und mit Leerzeichen (oder
anderen Zeichen) eingerückt werden.

\ospitem{\cmd{serendipity\_sendMail()} (\cmd{include/functions.inc.php})}
Sendet eine E-Mail mit Serendipity-Kopf- und -Fußzeilen.

\ospitem{\cmd{serendipity\_utf8\_encoded()} (\cmd{include/functions.inc.php})}
Kodiert eine Zeichenkette im Zeichensatz des Blogs in das UTF-8-Format. Falls
die Zeichenkette bereits im UTF-8-Format vorliegt, wird keine weitere
Umkodierung vorgenommen.

\ospitem{\cmd{serendipity\_parseFileName()} (\cmd{include/functions.inc.php})}
Teilt eine Datei in ihre Bestandteile auf (Grundname, Datei-Endung).
 
\ospitem{\cmd{serendipity\_trackReferrer()} (\cmd{include/functions.inc.php})}
Liest den HTTP-Referrer aus und speichert ihn für statistische Zwecke in der Datenbank.

\ospitem{\cmd{serendipity\_request\_start(), serendipity\_request\_end()}}
\ospadditem{(\cmd{include/functions.inc.php})}
Führt bestimmte Operationen aus, bevor/nachdem Serendipity eine fremde URL
aufruft. Dies dient der Verhinderung von Schreibproblemen mit PHP-Sessions.

\ospitem{\cmd{serendipity\_build\_query()} (\cmd{include/functions.inc.php})}
Erstellt eine Zeichenkette anhand eines übergebenen Arrays, damit dessen Werte
z.\,B.\ in einer HTTP-GET-URL übertragen werden können.

\ospitem{\cmd{serendipity\_pickKey()} (\cmd{include/functions.inc.php})}
Dient als Smarty-Modifier, um die Elemente eines Unter-Arrays auszuliefern.

\ospitem{\cmd{serendipity\_getTemplateFile()}}
\ospadditem{(\cmd{include/functions\_config.inc.php})}
Liefert den vollen Pfad zu einer gewünschten Datei des aktuellen Templates.

\ospitem{\cmd{serendipity\_load\_configuration()}}
\ospadditem{(\cmd{include/functions\_config.inc.php})}
Liest alle Konfigurationswerte Serendipity in das zentrale
\cmd{\$serendi\-pity}-Array. 

\ospitem{\cmd{serendipity\_logout()} (\cmd{include/functions\_config.inc.php})}
Führt den Logout eines Benutzers durch.

\ospitem{\cmd{serendipity\_session\_destroy()}}
\ospadditem{(\cmd{include/functions\_config.inc.php})}
Löscht alle PHP-Sessiondaten des aktuellen Benutzers, um ihn vollständig
auszuloggen. 

\ospitem{\cmd{serendipity\_login(), serendipity\_authenticate\_author}}
\ospadditem{(\cmd{include/functions\_config.inc.php})}
Wertet den Login eines Redakteurs aus und initalisiert dessen Konfigurationswerte.

\ospitem{\cmd{serendipity\_issueAutologin(), serendipity\_setAuthorToken()}}
\ospadditem{(\cmd{include/functions\_config.inc.php})}
Setzt ein Login-Cookie, damit ein Redakteur automatisch bei den folgenden Seitenaufrufen
eingeloggt werden kann.

\ospitem{\cmd{serendipity\_checkAutologin()}}
\ospadditem{(\cmd{include/functions\_config.inc.php})}
Wertet ein automatisches Login-Cookie eines Redakteurs aus.

\ospitem{\cmd{serendipity\_userLoggedIn()}}
\ospadditem{(\cmd{include/functions\_config.inc.php})}
Liefert zurück, ob ein Redakteur momentan eingeloggt ist.

\ospitem{\cmd{serendipity\_JSsetcookie()}}
\ospadditem{(\cmd{include/functions\_config.inc.php})}
Gibt JavaScript-Code aus, um ein Cookie zu setzen.

\ospitem{\cmd{serendipity\_setCookie()}}
\ospadditem{(\cmd{include/functions\_config.inc.php})}
Setzt ein Cookie.

\ospitem{\cmd{serendipity\_deleteCookie()}}
\ospadditem{(\cmd{include/functions\_config.inc.php})}
Löscht ein Cookie.

\ospitem{\cmd{serendipity\_is\_iframe()}}
\ospadditem{(\cmd{include/functions\_config.inc.php})}
Prüft, ob ein iframe zur Vorschau eines Artikels im Backend eingebunden werden
muss. 

\ospitem{\cmd{serendipity\_iframe(), serendipity\_iframe\_create()}}
\ospadditem{(\cmd{include/functions\_config.inc.php})}
Erstellt einen iframe zur Artikelvorschau im Backend.

\ospitem{\cmd{serendipity\_probeInstallation()}}
\ospadditem{(\cmd{include/functions\_config.inc.php})}
Prüft, welche Voraussetzungen zur Installation der Server unterstützt
(Datenbanken, URL-Umformung).

\ospitem{\cmd{serendipity\_header()} (\cmd{include/functions\_config.inc.php})}
Sendet einen HTTP-Header.

\ospitem{\cmd{serendipity\_getSessionLanguage()}}
\ospadditem{(\cmd{include/functions\_config.inc.php})}
Liefert die aktuelle Sprache des Besuchers.

\ospitem{\cmd{is\_utf8()} (\cmd{include/functions\_trackbacks.inc.php})}
Prüft, ob eine Zeichenkette im UTF-8-Zeichensatz vorliegt.

\ospitem{\cmd{\_serendipity\_send()} (\cmd{include/functions\_trackbacks.inc.php})}
Öffnet eine Socket-Verbindung zu einem fremden Server und sendet Daten (meist Trackbacks/Pingbacks).

\end{ospdescription}

\subsection{Redakteure, Rechte}

Funktionen zur Verwaltung von Redakteuren und deren Rechten.

\begin{ospdescription}

\ospitem{\cmd{serendipity\_fetchUsers()} (\cmd{include/functions.inc.php})}
Holt ein Array mit der Liste aller verfügbaren Serendipity-Redakteure.

\ospitem{\cmd{serendipity\_fetchUser()} (\cmd{include/functions.inc.php})}
Holt ein Array mit den Eigenschaften eines speziellen Serendipity-Redakteurs.

\ospitem{\cmd{serendipity\_addAuthor()} (\cmd{include/functions\_config.inc.php})}
Fügt einen neuen Redakteur hinzu.

\ospitem{\cmd{serendipity\_deleteAuthor()}}
\ospadditem{(\cmd{include/functions\_config.inc.php})}
Löscht einen Redakteur.

\ospitem{\cmd{serendipity\_remove\_config\_var()}}
\ospadditem{(\cmd{include/functions\_config.inc.php})}
Entfernt eine Konfigurationsoption eines Redakteurs.

\ospitem{\cmd{serendipity\_set\_config\_var(), serendipity\_set\_user\_var()}}
\ospadditem{(\cmd{include/functions\_config.inc.php})}
Setzt einen Konfigurationswert eines Redakteurs.

\ospitem{\cmd{serendipity\_get\_config\_var(),
serendipity\_get\_user\_var()}}
\ospadditem{(\cmd{include/functions\_config.inc.php})}
Liest den Konfigurationswert eines Redakteurs aus.

\ospitem{\cmd{serendipity\_getPermissions()}}
\ospadditem{(\cmd{include/functions\_config.inc.php})}
Liefert die Rechte eines Redakteurs zurück.

\ospitem{\cmd{serendipity\_getPermissionNames()}}
\ospadditem{(\cmd{include/functions\_config.inc.php})}
Liefert alle verfügbaren internen Rechte sowie deren Einteilung in die
Benutzerränge von älteren Serendipity-Versionen zurück.

\ospitem{\cmd{serendipity\_getDBPermissionNames()}}
\ospadditem{(\cmd{include/functions\_config.inc.php})}
Liefert alle in der Datenbank hinterlegten Rechte zurück. Dort können auch
etwaige von Plugins vergebene Rechte miteinbezogen werden.

\ospitem{\cmd{serendipity\_getAllPermissionNames()}}
\ospadditem{(\cmd{include/functions\_config.inc.php})}
Liefert alle verfügbaren Rechte (interne und aus der Datenbank) zurück.

\ospitem{\cmd{serendipity\_checkPermission()}}
\ospadditem{(\cmd{include/functions\_config.inc.php})}
Prüft, ob ein Redakteur ein bestimmtes Recht besitzt.

\ospitem{\cmd{serendipity\_updateGroups()}}
\ospadditem{(\cmd{include/functions\_config.inc.php})}
Aktualisiert die Gruppenmitgliedschaften eines Redakteurs.

\ospitem{\cmd{serendipity\_getAllGroups()}}
\ospadditem{(\cmd{include/functions\_config.inc.php})}
Liefert alle eingerichteten Benutzergruppen zurück.

\ospitem{\cmd{serendipity\_fetchGroup()} (\cmd{include/functions\_config.inc.php})}
Liefert die einer Benutzergruppe zugeordneten Rechte zurück.

\ospitem{\cmd{serendipity\_getGroups()} (\cmd{include/functions\_config.inc.php})}
Liefert alle Gruppenmitgliedschaften eines Redakteurs zurück.

\ospitem{\cmd{serendipity\_getGroupUsers()}}
\ospadditem{(\cmd{include/functions\_config.inc.php})}
Liefert alle Mitglieder einer gewünschten Benutzergruppe zurück.

\ospitem{\cmd{serendipity\_deleteGroup()}}
\ospadditem{(\cmd{include/functions\_config.inc.php})}
Löscht eine Benutzergruppe.

\ospitem{\cmd{serendipity\_addGroup()} (\cmd{include/functions\_config.inc.php})}
Fügt eine Benutzergruppe hinzu.

\ospitem{\cmd{serendipity\_addDefaultGroup()}}
\ospadditem{\cmd{include/functions\_config.inc.php})}
Konvertiert einen Benutzerrang einer alten Serendipity-Installation in eine neue
Benutzergruppe gleichen Namens.

\ospitem{\cmd{serendipity\_intersectGroup()}}
\ospadditem{(\cmd{include/functions\_config.inc.php})}
Prüft, ob ein gewünschter Benutzer in derselben Gruppe ist wie der derzeit
eingeloggte Redakteur.

\ospitem{\cmd{serendipity\_updateGroupConfig()}}
\ospadditem{(\cmd{include/functions\_config.inc.php})}
Aktualisiert die einer Benutzergruppe zugewiesenen Rechte.

\ospitem{\cmd{serendipity\_ACLGrant()} (\cmd{include/functions\_config.inc.php})}
Gewährt einer Benutzergruppe Zugriff auf einen speziellen Objekttyp 
(hauptsächlich für Objekte der Mediendatenbank).

\ospitem{\cmd{serendipity\_ACLGet()} (\cmd{include/functions\_config.inc.php})}
Prüft, ob ein Benutzer anhand seiner Gruppenmitgliedschaften Zugriff auf einen
speziellen Objekttyp besitzt.

\ospitem{\cmd{serendipity\_ACL\_SQL()} (\cmd{include/functions\_config.inc.php})}
Liefert Teile einer SQL-Abfrage, die benötigt werden, um Zugriffe auf bestimmte
Objekttypen (Mediendatenbank, Kategorien \ldots) in Abhängigkeit von den
Gruppenmitgliedschaften auszuwerten.

\ospitem{\cmd{serendipity\_hasPluginPermissions()}}
\ospadditem{(\cmd{include/functions\_config.inc.php})}
Prüft, ob es einem Redakteur erlaubt ist, die Funktionalitäten eines
auszuführenden Plugins aufzurufen (siehe Seite \pageref{verboteneplugins}).

\ospitem{\cmd{serendipity\_checkXSRF(), serendipity\_reportXSRF()}}
\ospadditem{(\cmd{include/functions\_config.inc.php})}
Prüft bei einem Seitenaufruf, ob der Redakteur diese Aktion tatsächlich
willentlich ausgelöst hat oder ob er Opfer einer XSRF-Attacke (siehe Seite \pageref{xsrf})
war.

\ospitem{\cmd{serendipity\_checkFormToken(), serendipity\_setFormToken()}}
\ospadditem{(\cmd{include/functions\_config.inc.php})}
Setzt bzw. überprüft einen eindeutigen Formularwert (\emph{Token}) auf gültigen
Inhalt. Dies wird für die XSRF-Prüfung benötigt.

\ospitem{\cmd{show\_plugins()} (\cmd{include/functions\_plugins\_admin.inc.php})}
Erstellt die Plugin-Verwaltungsansicht im Backend für eine gewünschte
Plugin-Sektion (Seitenleisten-Plugins, Ereignis-Plugins). Links zum Konfigurieren
und Verschieben der Plugins werden mit ausgeliefert. Über weitere
Hilfsfunktionen \cmd{ownership()} und \cmd{placement\_box()} werden Teilelemente
des Layouts (Plugin-Eigentümer, Platzierung) ausgeliefert.

\ospitem{\cmd{serendipity\_plugin\_config()}}
\ospadditem{(\cmd{include/functions\_plugins\_admin.inc.php})}
Stellt die Konfigurationsmaske für Plugins dar. Dabei werden die
Konfigurationswerte der Plugin API entnommen.
\end{ospdescription}

\subsection{Artikel, Kategorien, Kommentare, Trackbacks}

Funktionen zur Verwaltung von Artikeln, Kommentaren/Trackbacks und Kategorien.

\begin{ospdescription}

\ospitem{\cmd{serendipity\_addCategory()} (\cmd{include/functions.inc.php})}
Fügt dem Blog eine neue Kategorie hinzu.

\ospitem{\cmd{serendipity\_updateCategory()} (\cmd{include/functions.inc.php})}
Ändert eine bestehende Kategorie des Blogs.

\ospitem{\cmd{serendipity\_rememberComment()},}
\ospadditem{\cmd{serendipity\_rememberCommentDetails()},}
\ospadditem{\cmd{serendipity\_forgetCommentDetails()}}
\ospadditem{(\cmd{include/functions\_comments.inc.php})}
Speichert/löscht die Eingaben eines Kommentarformulars in Cookie-Werten.

\ospitem{\cmd{serendipity\_displayCommentForm()}}
\ospadditem{(\cmd{include/functions\_comments.inc.php})}
Stellt das Kommentarformular dar und weist die notwendigen Smarty-Variablen zu.

\ospitem{\cmd{serendipity\_fetchComments()}}
\ospadditem{(\cmd{include/functions\_comments.inc.php})}
Holt eine Liste gewünschter Kommentare.

\ospitem{\cmd{serendipity\_generateCommentList()}}
\ospadditem{(\cmd{include/functions\_comments.inc.php})}
Erstellt ein HTML \cmd{SELECT}-Auswahlfeld mit einer Liste aller gewünschten 
Kommentare.

\ospitem{\cmd{serendipity\_printComments()}}
\ospadditem{(\cmd{include/functions\_comments.inc.php})}
Stellt eine Liste gewünschter Kommentare mittels Smarty-Templates dar.

\ospitem{\cmd{serendipity\_printCommentsByAuthor()}}
\ospadditem{(\cmd{include/functions\_comments.inc.php})}
Stellt eine Liste gewünschter Kommentare anhand der Übergabe eines
Kommentatornamens mittels Smarty-Templates dar.

\ospitem{\cmd{serendipity\_deleteComment()}}
\ospadditem{(\cmd{include/functions\_comments.inc.php})}
Löscht einen Blog-Kommentar.

\ospitem{\cmd{serendipity\_allowCommentsToggle()}}
\ospadditem{(\cmd{include/functions\_comments.inc.php})}
Schaltet einen Blog-Artikel für die Kommentierung frei oder hebt diese
Möglichkeit auf.

\ospitem{\cmd{serendipity\_approveComment()}}
\ospadditem{(\cmd{include/functions\_comments.inc.php})}
Schaltet einen moderierten Kommentar frei.

\ospitem{\cmd{serendipity\_saveComment()}}
\ospadditem{(\cmd{include/functions\_comments.inc.php})}
Speichert einen neuen Kommentar zu einem Blog-Artikel und führt etwaige
Anti-Spam-Prüfungen durch.

\ospitem{\cmd{serendipity\_mailSubscribers()}}
\ospadditem{(\cmd{include/functions\_comments.inc.php})}
Schickt eine E-Mail an alle Abonnenten eines Blog-Artikels.

\ospitem{\cmd{serendipity\_cancelSubscription()}}
\ospadditem{(\cmd{include/functions\_comments.inc.php})}
Hebt ein Abonnement eines Blog-Artikels auf.

\ospitem{\cmd{serendipity\_sendComment()}}
\ospadditem{(\cmd{include/functions\_comments.inc.php})}
Verschickt beim Eintreffen eines neuen Blog-Kommentars eine Information per E-Mail.

\ospitem{\cmd{serendipity\_deleteCategory()}}
\ospadditem{\cmd{include/functions\_entries.inc.php})}
Löscht eine Kategorie.

\ospitem{\cmd{serendipity\_fetchCategoryRange()}}
\ospadditem{(\cmd{include/functions\_entries.inc.php})}
Liefert eine Liste von Blog-Kategorien einer gewünschten Oberkategorie.

\ospitem{\cmd{serendipity\_getMultiCategoriesSQL()}}
\ospadditem{(\cmd{include/functions\_entries.inc.php})}
Liefert einen SQL-Codeteil, damit eine Artikelabfrage auf bestimmte
Kategoriezuordnungen eingeschränkt werden kann. Dabei werden etwaige Ober- und
Unterkategorien korrekt berücksichtigt.

\ospitem{\cmd{serendipity\_fetchCategoryInfo()}}
\ospadditem{(\cmd{include/functions\_entries.inc.php})}
Liefert die Eigenschaften einer gewünschten Kategorie.

\ospitem{\cmd{serendipity\_fetchEntries()}}
\ospadditem{(\cmd{include/functions\_entries.inc.php})}
Zentrale Funktion, um eine Liste von Blog-Artikeln zu erhalten, die bestimmten
Kriterien entsprechen.

\ospitem{\cmd{serendipity\_fetchEntryData()},}
\ospadditem{\cmd{serendipity\_fetchEntryProperties()},}
\ospadditem{(\cmd{include/functions\_entries.inc.php})}
Weist die erweiterten Eigenschaften von Artikeln und Kategoriezuordnungen einer
Liste von Blog-Artikeln zu, die mittels \cmd{serendipity""\_fetchEntries()}
bezogen wurden.

\ospitem{\cmd{serendipity\_fetchEntry()}}
\ospadditem{(\cmd{include/functions\_entries.inc.php})}
Liefert einen speziellen Artikeldatensatz mit allen erweiterten Eigenschaften
und Kategoriezuordnungen zurück.

\ospitem{\cmd{serendipity\_fetchCategories()}}
\ospadditem{(\cmd{include/functions\_entries.inc.php})}
Liefert eine Liste von Blog-Kategorien, auf die ein gewünschter Redakteur
Zugriff hat. Kann auch unabhängig vom Redakteur eine Liste aller Kategorien des
Blogs liefern.

\ospitem{\cmd{serendipity\_rebuildCategoryTree()}}
\ospadditem{(\cmd{include/functions\_entries.inc.php})}
Führt die notwendigen Datenbankoperationen aus, um bei neu hinzugefügten
Kategorien die IDs der Nested-Set-Architektur (siehe z.\,B.\ \cmd{http://www.klempert.de/nested\_sets/})
korrekt zu setzen.

\ospitem{\cmd{serendipity\_searchEntries()}}
\ospadditem{(\cmd{include/functions\_entries.inc.php})}
Liefert eine Liste von Blog-Artikeln zurück, die ein gewünschtes Suchwort enthalten.

\ospitem{\cmd{serendipity\_getTotalEntries()}}
\ospadditem{(\cmd{include/functions\_entries.inc.php})}
Liefert die Anzahl von aktuell im Frontend dargestellten Artikeln zurück.

\ospitem{\cmd{serendipity\_printEntries()}}
\ospadditem{(\cmd{include/functions\_entries.inc.php})}
Zentrale Funktion, um Blog-Einträge für die Ausgabe im Smarty"=Template
aufzubereiten. Benötigte Variablen und Arrays werden gesetzt, etwaige Plugins
ausgeführt und an das Smarty-Template \cmd{entries.""tpl} weitergegeben.

\ospitem{\cmd{serendipity\_printEntries\_rss()}}
\ospadditem{(\cmd{include/functions\_entries.inc.php})}
Stellt Einträge innerhalb eines RSS-Feeds dar.

\ospitem{\cmd{serendipity\_purgeEntry(), serendipity\_deleteEntry()}}
\ospadditem{(\cmd{include/functions\_entries.inc.php})}
Löscht einen Artikel.

\ospitem{\cmd{serendipity\_updertEntry()}}
\ospadditem{(\cmd{include/functions\_entries.inc.php})}
Aktualisiert einen Artikel oder fügt einen neuen ein (\emph{updert} =
\emph{Up\-d}a\-te + Ins\emph{ert}).

\ospitem{\cmd{serendipity\_generateCategoryList()}}
\ospadditem{(\cmd{include/functions\_entries.inc.php})}
Erzeugt ein HTML-Ausklappfeld mit allen verfügbaren Kategorien.

\ospitem{\cmd{serendipity\_generateCategoryList()}}
\ospadditem{(\cmd{include/functions\_entries.inc.php})}
Aktualisiert die Kategoriezuordnungen eines Artikels.

\ospitem{\cmd{serendipity\_printArchives()}}
\ospadditem{(\cmd{include/functions\_entries.inc.php})}
Erzeugt eine Archivübersicht mit Artikeln eines gewünschten Zeitraums und gibt
diese Artikelliste an das Smarty-Template \cmd{entries\_""archives.tpl} weiter.

\ospitem{\cmd{serendipity\_getTotalCount()}}
\ospadditem{(\cmd{include/functions\_entries.inc.php})}
Liefert die Anzahl aller im Blog vorhandenen Kommentare, Trackbacks oder
Artikel zurück.

\ospitem{\cmd{serendipity\_printEntryForm()}}
\ospadditem{(\cmd{include/functions\_entries\_admin.inc.php})}
Stellt das HTML-Formular zum Bearbeiten eines Blog-Artikels im Backend dar.

\ospitem{\cmd{serendipity\_emit\_htmlarea\_code()}}
\ospadditem{(\cmd{include/functions\_entries\_admin.inc.php})}
Gibt den benötigten JavaScript-Code zurück, damit ein WYSIWYG-Editor angezeigt
werden kann.

\ospitem{\cmd{serendipity\_handle\_references()}}
\ospadditem{(\cmd{include/functions\_trackbacks.inc.php})}
Überprüft alle in einem Blog-Artikel enthaltenen Links und speichert sie in den
entsprechenden Datenbanktabellen.

\ospitem{\cmd{serendipity\_trackback\_is\_success()},}
\ospadditem{\cmd{serendipity\_pingback\_is\_success()}}
\ospadditem{(\cmd{include/functions\_trackbacks.inc.php})}
Prüft, ob ein Trackback/Pingback gültig versendet wurde.

\ospitem{\cmd{serendipity\_pingback\_autodiscover()},}
\ospadditem{\cmd{serendipity\_trackback\_autodiscover()}}
\ospadditem{(\cmd{include/functions\_trackbacks.inc.php})}
Überprüft einen Blog-Artikel auf Trackback/Pingback"=Links und führt
diese aus.

\ospitem{\cmd{serendipity\_reference\_autodiscover()}}
\ospadditem{(\cmd{include/functions\_trackbacks.inc.php})}
Überprüft einen Blog-Artikel auf enthaltene Hyperlinks und speichert diese in
der Datenbank.

\ospitem{\cmd{add\_trackback(), add\_pingback()}}
\ospadditem{(\cmd{include/functions\_trackbacks.inc.php})}
Speichert ein eingehendes Trackback/Pingback.

\ospitem{\cmd{report\_trackback\_success()}, \cmd{report\_trackback\_failure()},}
\ospadditem{\cmd{report\_pingback\_success()}, \cmd{report\_pingback\_failure()}}
\ospadditem{(\cmd{include/functions\_trackbacks.inc.php})}
Liefert XML-Code für eine Erfolgs-/Fehlermeldung bei einem Trackback/Pingback zurück.

\end{ospdescription}

\subsection{Permalinks}

Funktionen zur Behandlung von URLs und Permalinks.

\begin{ospdescription}
\ospitem{\cmd{serendipity\_makeFilename()}}
\ospadditem{(\cmd{include/functions\_permalinks.inc.php})}
Konvertiert eine Zeichenkette in ein Format, das innerhalb einer URL ohne
Sonderzeichen verwendet werden kann.

\ospitem{\cmd{serendipity\_initPermalinks()}}
\ospadditem{(\cmd{include/functions\_permalinks.inc.php})}
Setzt die Serendipity-Variablen, die die Konfiguration der Permalinks enthalten.

\ospitem{\cmd{serendipity\_permalinkPatterns()}}
\ospadditem{(\cmd{include/functions\_permalinks.inc.php})}
Erzeugt eine Liste von regulären Ausdrücken, die verwendet werden, um zu prüfen,
ob die aktuelle URL einem festgelegten Permalink entspricht.

\ospitem{\cmd{serendipity\_searchPermalink()}}
\ospadditem{(\cmd{include/functions\_permalinks.inc.php})}
Durchsucht die Datenbank nach einem Permalink für die aktuelle URL.

\ospitem{\cmd{serendipity\_getPermalink(), serendipity\_rewriteURL(),}}
\ospadditem{\cmd{serendipity\_archiveURL(), serendipity\_authorURL(),}}
\ospadditem{\cmd{serendipity\_categoryURL(),}}
\ospadditem{\cmd{serendipity\_feedCategoryURL(),}}
\ospadditem{\cmd{serendipity\_feedAutorURL(),}}
\ospadditem{\cmd{serendipity\_archiveDateUrl()}}
\ospadditem{(\cmd{include/functions\_permalinks.inc.php})}
Gibt einen Permalink zu einem Objekt (Blog-Artikel, Redakteur, Kategorie) aus.

\ospitem{\cmd{serendipity\_updatePermalink()}}
\ospadditem{(\cmd{include/functions\_permalinks.inc.php})}
Aktualisiert einen in der Datenbank gespeicherten Permalink.

\ospitem{\cmd{serendipity\_insertPermalink()}}
\ospadditem{(\cmd{include/functions\_permalinks.inc.php})}
Fügt einen Permalink in die Datenbank ein, so dass die Ansicht des gewünschten
Objekts (Artikel, Redakteur, Kategorie) später über diese URL wieder aufgerufen
werden kann.

\ospitem{\cmd{serendipity\_buildPermalinks()}}
\ospadditem{(\cmd{include/functions\_permalinks.inc.php})}
Erzeugt Permalinks in der Datenbank für alle Artikel, Redakteure und Kategorien
des Blogs. Dabei wird die momentan konfigurierte Permalink"=Struktur verwendet.

\ospitem{\cmd{serendipity\_makePermalinks(),}}
\ospadditem{\cmd{serendipity\_makePermalinkRegex()}}
\ospadditem{(\cmd{include/functions\_permalinks.inc.php})}
Erzeugt einen Permalink, indem die Platzhalter der Permalink"=Konfiguration durch
die Werte des aufrufenden Objekts ersetzt werden.

\ospitem{\cmd{serendipity\_currentURL()}}
\ospadditem{(\cmd{include/functions\_permalinks.inc.php})}
Liefert die URL des im Frontend dargestellten Permalinks.

\ospitem{\cmd{serendipity\_getUriArguments()}}
\ospadditem{(\cmd{include/functions\_permalinks.inc.php})}
Liefert die URL-Bestandteile des im Frontend dargestellten Permalinks.

\end{ospdescription}

%PJ:Weiter bin ich noch nicht
\subsection{Installation, Upgrades}

Funktionen zur Installation und Aktualisierung Serendipitys.

\begin{ospdescription}
\ospitem{\cmd{serendipity\_ini\_bool(), serendipity\_ini\_bytesize()}}
\ospadditem{(\cmd{include/functions\_installer.inc.php})}
Liest PHP-Konfigurationswerte ein und wandelt sie in ein von Serendipity
interpretierbares Format um.

\ospitem{\cmd{serendipity\_updateLocalConfig()}}
\ospadditem{(\cmd{include/functions\_installer.inc.php})}
Aktualisiert die zentrale Konfigurationsdatei \cmd{serendipity\_config\_""local.inc.php}
mit den aktuellen Konfigurationswerten.

\ospitem{\cmd{serendipity\_installDatabase(),}}
\ospadditem{\cmd{serendipity\_parse\_sql\_tables(),}}
\ospadditem{\cmd{serendipity\_parse\_sql\_inserts()}}
\ospadditem{(\cmd{include/functions\_installer.inc.php})}
Richtet die Datenbank ein und erstellt die Serendipity-Tabellen.

\ospitem{\cmd{serendipity\_query\_default()}}
\ospadditem{(\cmd{include/functions\_installer.inc.php})}
Prüft einen Konfigurationswert auf jeweils sinnvolle Voreinstellungen bei der Installation.

\ospitem{\cmd{serendipity\_check\_rewrite()}}
\ospadditem{(\cmd{include/functions\_installer.inc.php})}
Prüft, ob der Server dynamische URL-Umformung unterstützt.

\ospitem{\cmd{serendipity\_parseTemplate(),}}
\ospadditem{\cmd{serendipity\_printConfigTemplate()}}
\ospadditem{(\cmd{include/functions\_installer.inc.php})}
Stellt die Konfigurationsoptionen dar, die durch die Dateien
\cmd{include/""tpl/config\_local.inc.php} oder 
\cmd{include/tpl/config\_personal"".inc.php} bestimmt werden.

\ospitem{\cmd{serendipity\_checkConfigItemFlags()}}
\ospadditem{(\cmd{include/functions\_installer.inc.php})}
Prüft die Werte der einzelnen Konfigurationsoptionen, um deren Ausgabeort zu bestimmen.

\ospitem{\cmd{serendipity\_guessInput()}}
\ospadditem{(\cmd{include/functions\_installer.inc.php})}
Gibt den HTML-Code für eine Konfigurationsoption zurück (einzeilige
Texteingabefelder, Ja/Nein-Schalter, Auswahlfelder etc.)

\ospitem{\cmd{serendipity\_checkInstallation()}}
\ospadditem{(\cmd{include/functions\_installer.inc.php})}
Prüft, ob die Serendipity-Installation problemlos durchgeführt werden konnte.

\ospitem{\cmd{serendipity\_installFiles()}}
\ospadditem{(\cmd{include/functions\_installer.inc.php})}
Erzeugt die für Serendipity notwendigen Dateien bei der Installation
(\cmd{.htaccess} und \cmd{serendipity\_config\_local.inc.php}).

\ospitem{\cmd{serendipity\_updateConfiguration()}}
\ospadditem{(\cmd{include/functions\_installer.inc.php})}
Aktualisiert die zentralen Serendipity-Dateien und die Datenbank, wenn sich wichtige
Konfigurationswerte (Permalinks) ändern.

\ospitem{\cmd{serendipity\_httpCoreDir()}}
\ospadditem{(\cmd{include/functions\_installer.inc.php})}
Liefert den aktuellen Systempfad zum Serendipity-Verzeichnis.

\end{ospdescription}

\subsection{Bilder}

Funktionen zur Mediendatenbank.

\begin{ospdescription}
\ospitem{\cmd{serendipity\_isActiveFile()}}
\ospadditem{(\cmd{include/functions\_images.inc.php})}
Prüft, ob eine hochzuladende Datei eine potenziell gefährliche Dateiendung
besitzt. 

\ospitem{\cmd{serendipity\_fetchImagesFromDatabase()}}
\ospadditem{(\cmd{include/functions\_images.inc.php})}
Holt eine Liste von gewünschten Objekten der Mediendatenbank.

\ospitem{\cmd{serendipity\_fetchImageFromDatabase()}}
\ospadditem{(\cmd{include/functions\_images.inc.php})}
Holt eine einzelnes Objekt aus der Mediendatenbank.
 
\ospitem{\cmd{serendipity\_updateImageInDatabase()}}
\ospadditem{(\cmd{include/functions\_images.inc.php})}
Aktualisiert ein Objekt der Mediendatenbank.

\ospitem{\cmd{serendipity\_deleteImage()}}
\ospadditem{(\cmd{include/functions\_images.inc.php})}
Löscht ein Objekt der Mediendatenbank.

\ospitem{\cmd{serendipity\_fetchImages()}}
\ospadditem{(\cmd{include/functions\_images.inc.php})}
Holt eine Liste von Mediendateien direkt aus der Verzeichnisstruktur anstelle
der Mediendatenbank.

\ospitem{\cmd{serendipity\_insertHotlinkedImageInDatabase()}}
\ospadditem{(\cmd{include/functions\_images.inc.php})}
Fügt einen Verweis zu einer Mediendatei eines fremden Servers in die eigene
Mediendatenbank ein.

\ospitem{\cmd{serendipity\_insertImageInDatabase()}}
\ospadditem{(\cmd{include/functions\_images.inc.php})}
Fügt der Mediendatenbank eine Datei hinzu.

\ospitem{\cmd{serendipity\_makeThumbnail()}}
\ospadditem{(\cmd{include/functions\_images.inc.php})}
Erzeugt ein Vorschaubild einer Datei.

\ospitem{\cmd{serendipity\_scaleImg(),}}
\ospadditem{\cmd{serendipity\_resize\_image\_gd()}}
\ospadditem{(\cmd{include/functions\_images.inc.php})} 
Ändert die Größe eines Bildes.

\ospitem{\cmd{serendipity\_rotateImg(), serendipity\_rotate\_image\_gd()}}
\ospadditem{(\cmd{include/functions\_images.inc.php})} 
Rotiert ein Bild.

\ospitem{\cmd{serendipity\_generateThumbs(), serendipity\_syncThumbs()}}
\ospadditem{(\cmd{include/functions\_images.inc.php})}
Erzeugt Vorschaubilder aller Dateien der Mediendatenbank.

\ospitem{\cmd{serendipity\_guessMime()}}
\ospadditem{(\cmd{include/functions\_images.inc.php})}
Erkennt den MIME-Typ einer Datei anhand des Dateinamens.

\ospitem{\cmd{serendipity\_functions\_gd()}}
\ospadditem{(\cmd{include/functions\_images.inc.php})}
Kapselt PHP-Grafikfunktionen und liefert den richtigen PHP"=Funktionsnamen in
Abhängigkeit vom gewählten Dateiformat zurück.

\ospitem{\cmd{serendipity\_calculate\_aspect\_size()}}
\ospadditem{(\cmd{include/functions\_images.inc.php})}
Berechnet die notwendigen Bildmaße, wenn ein Bild proportional verkleinert oder
vergrößert werden soll.

\ospitem{\cmd{serendipity\_displayImageList()}}
\ospadditem{(\cmd{include/functions\_images.inc.php})}
Stellt eine Übersicht der Objekte der Mediendatenbank dar. Die
darzustellenden Objekte werden anhand der Benutzereingaben ausgelesen und
mittels Smarty-Variablen und Templates dargestellt.

\ospitem{\cmd{serendipity\_isImage()}}
\ospadditem{(\cmd{include/functions\_images.inc.php})}
Prüft, ob ein Objekt der Mediendatenbank ein Bild ist.

\ospitem{\cmd{serendipity\_killPath(), serendipity\_deletePath()}}
\ospadditem{(\cmd{include/functions\_images.inc.php})}
Löscht ein Verzeichnis mitsamt Unterverzeichnissen und darin
enthaltenen Dateien.

\ospitem{\cmd{serendipity\_traversePath()}}
\ospadditem{(\cmd{include/functions\_images.inc.php})}
Durchsucht ein Verzeichnis mitsamt seiner Unterverzeichnisse nach Dateien und
liefert eine Verzeichnis- und Dateiliste zurück.

\ospitem{\cmd{serendipity\_sortPath()}}
\ospadditem{(\cmd{include/functions\_images.inc.php})}
Sortiert eine Verzeichnisliste.

\ospitem{\cmd{serendipity\_uploadSecure()}}
\ospadditem{(\cmd{include/functions\_images.inc.php})}
Prüft einen Dateinamen, der von einem Redakteur angegeben wurde, und entfernt
potenziell gefährliche Sonderzeichen.

\ospitem{\cmd{serendipity\_getimagesize()}}
\ospadditem{(\cmd{include/functions\_images.inc.php})}
Liefert die Datei- und Bildgröße sowie den MIME-Typ einer Datei zurück.

\ospitem{\cmd{serendipity\_getImageFields()}}
\ospadditem{(\cmd{include/functions\_images.inc.php})}
Liefert ein Array mit möglichen Datenbank-Feldnamen der Objekte einer Mediendatenbank.

\ospitem{\cmd{serendipity\_directoryACL()}}
\ospadditem{(\cmd{include/functions\_images.inc.php})}
Prüft die Zugriffsrechte eines Redakteurs auf die Verzeichnisse der
Mediendatenbank. 

\ospitem{\cmd{serendipity\_getImageData()}}
\ospadditem{(\cmd{include/functions\_images.inc.php})}
Liest die Metadaten eines Objekts aus der Mediendatenbank.

\ospitem{\cmd{serendipity\_showPropertyForm()}}
\ospadditem{(\cmd{include/functions\_images.inc.php})}
Stellt das Formular zum Bearbeiten der Metadaten einer Datei in der
Mediendatenbank dar.

\ospitem{\cmd{serendipity\_parseMediaProperties()}}
\ospadditem{(\cmd{include/functions\_images.inc.php})}
Liest die Metadaten eines Objekts der Mediendatenbank und bereitet sie für die
Darstellung auf.

\ospitem{\cmd{serendipity\_mediaTypeCast()},}
\ospadditem{\cmd{serendipity\_metaFieldConvert(),}}
\ospadditem{\cmd{serendipity\_getMediaRaw()}}
\ospadditem{(\cmd{include/functions\_images.inc.php})}
Versucht, Metadaten einer Datei (EXIF-Daten, ID3-Daten) in ein für die Datenbank
verwendbares Format zu bringen. Konvertiert Datums- und Zahlenwerte in das
benötigte Format.

\ospitem{\cmd{serendipity\_insertMediaProperty()}}
\ospadditem{(\cmd{include/functions\_images.inc.php})}
Speichert Metadaten einer Datei in der Mediendatenbank.

\ospitem{\cmd{serendipity\_parsePropertyForm()}}
\ospadditem{(\cmd{include/functions\_images.inc.php})}
Bereitet die vom Benutzer übermittelten Metadaten einer Datei auf und speichert
sie entsprechend in der Mediendatenbank.

\ospitem{\cmd{serendipity\_fetchMediaProperties()},}
\ospadditem{\cmd{serendipity\_getMetaData()}}
\ospadditem{(\cmd{include/functions\_images.inc.php})}
Liest Metadaten eines Objekts aus der Mediendatenbank.

\ospitem{\cmd{serendipity\_checkPropertyAccess()}}
\ospadditem{(\cmd{include/functions\_images.inc.php})}
Prüft, ob ein Redakteur auf bestimmte Objekte der Mediendatenbank zugreifen darf,
und entfernt alle nicht zulässigen Metadaten aus einer Liste.

\ospitem{\cmd{serendipity\_prepareMedia()}}
\ospadditem{(\cmd{include/functions\_images.inc.php})}
Bereitet die Metadaten eines Objekts der Mediendatenbank auf und setzt
benötigte Zusatzvariablen für die Darstellung eines Objekts.

\ospitem{\cmd{serendipity\_showMedia()}}
\ospadditem{(\cmd{include/functions\_images.inc.php})}
Stellt ein Objekt der Mediendatenbank mittels Smarty-Templates
(\cmd{me\-dia\_pane.tpl} oder \cmd{media\_properties.tpl}) dar.

\ospitem{\cmd{serendipity\_imageAppend()}}
\ospadditem{(\cmd{include/functions\_images.inc.php})}
Prüft, ob eine Datei in der Mediendatenbank bereits existiert. Ist das der Fall, wird
ein numerischer Index an die Datei angehängt (aus \cmd{bild.jpg} wird
\cmd{bild2.jpg}).

\ospitem{\cmd{serendipity\_checkMediaSize()}}
\ospadditem{(\cmd{include/functions\_images.inc.php})}
Prüft, ob eine hochgeladene Datei bestimmte Ressourcenlimits überschreitet.

\ospitem{\cmd{serendipity\_moveMediaDirectory()}}
\ospadditem{(\cmd{include/functions\_images.inc.php})}
Verschiebt ein Verzeichnis innerhalb der Mediendatenbank und im
Verzeichnissystem. 

\ospitem{\cmd{serendipity\_getMediaPaths()}}
\ospadditem{(\cmd{include/functions\_images.inc.php})}
Holt eine Liste aller Verzeichnisse der Mediendatenbank, auf die ein Redakteur
Zugriff hat.

\ospitem{\cmd{serendipity\_checkDirUpload()}}
\ospadditem{(\cmd{include/functions\_images.inc.php})}
Prüft, ob ein Redakteur Schreibzugriff auf ein bestimmte Verzeichnis der
Mediendatenbank besitzt.

\end{ospdescription}

\subsection{Smarty}

Funktionen zur Verwaltung von Smarty. Die meisten von den in
\cmd{include/""functions\_smarty.inc.php} festgelegten Funktionen dienen als
Smarty-Modifier oder Smarty-Functions. Diese sind ab Seite \pageref{smartyfunctions} 
und Seite \pageref{smartymodifier} dokumentiert.

\begin{ospdescription}
\ospitem{\cmd{serendipity\_smarty\_init()}}
\ospadditem{(\cmd{include/functions\_smarty.inc.php})}
Startet das Smarty-Framework und initialisiert alle notwendigen Variablen und Objekte.

\ospitem{\cmd{serendipity\_smarty\_purge()}}
\ospadditem{(\cmd{include/functions\_smarty.inc.php})}
Löscht die temporären Dateien des Smarty-Frameworks 
(kompilierte Templates im \cmd{templates\_c}-Verzeichnis).

\ospitem{\cmd{serendipity\_smarty\_shutdown()}}
\ospadditem{(\cmd{include/functions\_smarty.inc.php})}
Beendet die Seitenausführung und gibt die aktuelle Smarty-Template-Seite aus.

\ospitem{\cmd{serendipity\_printEntryFooter()}}
\ospadditem{(\cmd{include/functions\_entries.inc.php})}
Setzt abhängig von den auf der aktuellen Seite dargestellten Blog-Artikeln die
notwendigen Footer-Elemente (Anzahl der Artikel, Anzahl der Seiten, aktuelle
Seite) zusammen. 

\ospitem{\cmd{serendipity\_loadthemeOptions()}}
\ospadditem{(\cmd{include/functions\_config.inc.php})}
Lädt die Template-Konfigurationsoptionen, die dem aktuellen Template zugeordnet wurden.
\end{ospdescription}

\subsection{Datenbank}

Funktionen zur Abfrage und Verwaltung der Datenbank.

\begin{ospdescription}
\ospitem{\cmd{serendipity\_db\_update()} (\cmd{include/db.inc.php})}
Führt eine Datenbankabfrage aus, die einen Datensatz aktualisiert (\cmd{UPDATE
table SET \ldots}). Dabei wird die Liste der zu aktualisierenden Feldnamen und
Werte der Funktion übergeben und automatisch in das benötigte SQL-Format
übersetzt. 

\ospitem{\cmd{serendipity\_db\_insert()} (\cmd{include/db.inc.php})}
Führt eine Datenbankabfrage aus, die einen Datensatz einfügt (\cmd{IN\-SERT INTO table
(\ldots) VALUES (\ldots)}). Dabei wird die Liste der einzufügenden Feldnamen
und Werte der Funktion übergeben und automatisch in das benötigte SQL-Format
übersetzt. 

\ospitem{\cmd{serendipity\_db\_bool()} (\cmd{include/db.inc.php})}
Prüft, ob ein der Funktion übergebener Wert einem \emph{Boolean}-Wert
(\cmd{true/false}) entspricht.

\ospitem{\cmd{serendipity\_db\_get\_interval()} (\cmd{include/db.inc.php})}
Liefert abhängig vom eingesetzten Datenbanksystem ein SQL"=Codefragment zurück,
mit dem anhand eines Datenbankfeldes eine Einschränkung des Zeitraums der
Datensätze vorgenommen wird.

\ospitem{\cmd{serendipity\_db\_implode()} (\cmd{include/db.inc.php})}
Liefert ein SQL-Codefragment, damit ein PHP-Array mit Werten sicher innerhalb
einer Datenbankabfrage verwendet werden kann.

\ospitem{\cmd{serendipity\_db\_begin\_transaction()},}
\ospadditem{\cmd{serendipity\_db\_end\_transaction()}}
\ospadditem{(z.\,B.\ \cmd{include/mysql.inc.php})}
Führt eine Datenbankabfrage zum Anfang/Ende einer Transaktion aus.

\ospitem{\cmd{serendipity\_db\_query()} (z.\,B.\ \cmd{include/mysql.inc.php})}
Führt eine Datenbankabfrage mittels einer SQL-Abfrage aus und liefert die
Ergebnisse zurück.

\ospitem{\cmd{serendipity\_db\_insert\_id()} (z.\,B.\ \cmd{include/mysql.inc.php})}
Liefert den Primärschlüssel der zuletzt mittels \cmd{INSERT INTO\ldots} 
eingefügten Datenbankzeile.

\ospitem{\cmd{serendipity\_db\_affected\_rows()},}
\ospadditem{\cmd{serendipity\_db\_matched\_rows()}}
\ospadditem{(z.\,B.\ \cmd{include/mysql.inc.php})}
Liefert die Anzahl der von der letzten SQL-Abfrage betroffenen Ergebniszeilen
(\cmd{SELECT}, \cmd{DELETE} \ldots) zurück.

\ospitem{\cmd{serendipity\_db\_updated\_rows()} (z.\,B.\ \cmd{include/mysql.inc.php})}
Liefert die Anzahl der von der letzten SQL-Abfrage aktualisierten Datensätze (\cmd{UPDATE})
zurück.

\ospitem{\cmd{serendipity\_db\_escape\_string()} (z.\,B.\ \cmd{include/mysql.inc.php})}
Liefert den Wert einer übergebenen Variable in einer Formatierung zurück, die
eine gefahrlose Verwendung innerhalb einer SQL-Abfrage ermöglicht. Etwaige
Sonderzeichen werden dabei \cmd{escaped} (umformatiert), so dass kein Missbrauch
stattfinden kann. Diese Funktion muss immer auf alle Variablen angewendet
werden, die der Benutzer in Formularen oder per URL-Wert einbringt.

\ospitem{\cmd{serendipity\_db\_limit()} (z.\,B.\ \cmd{include/mysql.inc.php})}
Liefert den für das jeweilige Datenbanksystem benötigten SQL-Code zurück, um die
Anzahl der Ergebnisse einer \cmd{SELECT}-Abfrage einzuschränken. Dieser SQL-Code
weicht in den verschiedenen SQL"=Dialekten fundamental voneinander ab.
 
\ospitem{\cmd{serendipity\_db\_concat()} (z.\,B.\ \cmd{include/mysql.inc.php})}
Liefert den für das jeweilige Datenbanksystem benötigten SQL-Code zurück, um
mehrere Datenbankspalten miteinander in einer Ausgabe zu verbinden (\cmd{CONCAT}).

\ospitem{\cmd{serendipity\_db\_connect(), serendipity\_db\_reconnect()}}
\ospadditem{(z.\,B.\ \cmd{include/mysql.inc.php})}
Stellt eine Verbindung zur Datenbank her.

\ospitem{\cmd{serendipity\_db\_probe()} (z.\,B.\ \cmd{include/mysql.inc.php})}
Testet die Verbindung zur Datenbank.

\ospitem{\cmd{serendipity\_db\_schema\_import()} (z.\,B.\ \cmd{include/mysql.inc.php})}
Importiert eine SQL-Anweisung, die aus einem Plugin oder einer Datei des
\cmd{sql}-Verzeichnisses von Serendipity stammt. Dabei werden etwaige
Platzhalter korrekt in das für das jeweilige Datenbanksystem benötigte
SQL-Format gewandelt.

\end{ospdescription}


%revised
\index{Datenbank}%
\section{Datenbank}

Serendipity speichert seine Daten in verschiedenen Datenbanktabellen. Viele
Tabellen sind miteinander verknüpft, meist anhand von 1:n"=Primärschlüsseln oder
weiteren unabhängigen n:m-Verbindungen.


\label{er-schema}
\index{ERModell@ER-Modell}
\index{Relationsschema}
\ospfigure{0.8}{img/dbrel.eps}{Datenbank ER-Modell}{fig:img/dbrel.eps}%


Dabei benutzt Serendipity keine \emph{Foreign Key}-Assoziierung, die PostgreSQL
oder MySQL zu bieten haben. Der Grund dafür ist, dass die Serendipity-Tabellen 
möglichst ohne viel Portierungsaufwand auch auf anderen
Datenbanksystemen wie SQLite einsetzbar sein sollen. Jeglicher
Einsatz von Fremdschlüsseln wird durch den Serendipity-Code verwaltet und
nicht die Datenbank. Abbildung \figref{fig:img/dbrel.eps} zeigt einen 
Screenshot des Datenbank"=Relationsschemas.


\subsection{Benutzer- und Rechtemanagement}

Die folgenden Tabellen dienen der Verwaltung von Benutzern, Gruppen und
deren Rechten. Sie werden in den SQL-Datenbankabfragen mit \cmd{JOIN}s
einbezogen. 

\index{Datenbank-Tabellen!serendipity\_authors}%
\subsubsection{serendipity\_authors}
Enthält die Redakteure des Blogs.
\begin{ospdescription}
\ospitem{\cmd{authorid} (Primärschlüssel, int(11))} enthält die fortlaufende ID
eines Redakteurs.
\ospitem{\cmd{realname} (varchar(255)) }enthält den dargestellten Namen des Redakteurs.
\ospitem{\cmd{username} (varchar(32))} enthält den Loginnamen des Redakteurs.
\ospitem{\cmd{password} (varchar(32))} enthält das Passwort des Redakteurs als MD5-Prüfsumme.
\ospitem{\cmd{email} (varchar(128))} enthält die E-Mail-Adresse des Redakteurs.
\ospitem{\cmd{mail\_comments} (int(1))} gibt an, ob der Redakteur bei Eingang neuer
Kommentare eine E-Mail erhält.
\ospitem{\cmd{mail\_trackbacks} (int(1))} gibt an, ob der Redakteur bei Eingang
neuer Trackbacks eine E-Mail erhält.
\ospitem{\cmd{userlevel} (int(4))} enthält den Benutzerrang eines Redakteurs. Der
numerische Wert 255 steht für Administratoren, 1 für Chefredakteure und 0 für
normale Redakteure. Der Benutzerrang ist seit Einführung der Benutzergruppen nur
noch für ältere Plugins von Bedeutung.
\ospitem{\cmd{right\_publish} (int(1))} gibt an, ob ein Redakteur Einträge
veröffentlichen darf.
\end{ospdescription}

\index{Datenbank-Tabellen!serendipity\_groups}%
\subsubsection{serendipity\_groups}
Enthält die Benutzergruppen des Blogs.
\begin{ospdescription}
\ospitem{\cmd{id} (Primärschlüssel, int(11))} enthält die fortlaufende ID einer Gruppe.
\ospitem{\cmd{name} (varchar(64))} enthält den Namen der Redakteursgruppe.
\end{ospdescription}

\index{Datenbank-Tabellen!serendipity\_authorgroups}%
\subsubsection{serendipity\_authorgroups}
Enthält eine n:m-Zuordnungstabelle, mit der Autoren den Benutzergruppen
zugeordnet werden.
\begin{ospdescription}
\ospitem{\cmd{groupid} (Fremdschlüssel, int(10))} enthält die ID der Benutzergruppe.
\ospitem{\cmd{authorid} (Fremdschlüssel, int(10))} enthält die ID des Redakteurs.
\end{ospdescription}

\index{Datenbank-Tabellen!serendipity\_groupconfig}%
\subsubsection{serendipity\_groupconfig}
Enthält eine Zuordnung von Rechten zu Benutzergruppen. Eine Benutzergruppe kann
beliebig viele und beliebig benannte Rechte haben.
\begin{ospdescription}
\ospitem{\cmd{id} (Fremdschlüssel, int(10))} enthält die ID der Benutzergruppe.
\ospitem{\cmd{property} (varchar(128))} enthält den Namen des Rechts.
\ospitem{\cmd{value} (varchar(64))} enthält den Wert des Rechts, d.\,h.\ ob dieses
gesetzt (\cmd{true}) oder nicht gesetzt (\cmd{false}) ist. Auch andere Werte als
\cmd{true} oder \cmd{false} können von Plugins gesetzt werden.
\end{ospdescription}

\index{Datenbank-Tabellen!serendipity\_access}%
\subsubsection{serendipity\_access}
\index{ACL}%
Enthält die ACL (\emph{Access Control List}), anhand derer bestimmten
Benutzergruppen Zugriff auf Teile der Serendipity-Inhalte zugewiesen werden
kann. Die Tabelle ist so abstrahiert, dass beliebige Rechte eingerichtet
werden können. Für jedes Tupel \cmd{groupid, artifact\_id} können mehrere
unterschiedliche \cmd{artifact\_mode}-Werte hinterlegt werden.

\begin{ospdescription}
\ospitem{\cmd{groupid} (Fremdschlüssel, int(10))} enthält die ID einer
Benutzergruppe.
\ospitem{\cmd{artifact\_id} (Fremdschlüssel, int(10))} enthält die ID des
Fremdobjekts, für das ein Recht vergeben wird.
\ospitem{\cmd{artifact\_type} (varchar(64))} legt fest, für welchen Objekttyp ein
Recht vergeben wird. Mögliche Werte sind: \cmd{category} (für Kategorien),
\cmd{directory} (für Verzeichnisse der Mediendatenbank).
\ospitem{\cmd{artifact\_mode} (varchar(64))} legt fest, welche Eigenschaft ein Recht
hat. Mögliche Werte sind: \cmd{read} (Leserecht), \cmd{write} (Schreibrecht).
\ospitem{\cmd{artifact\_index} (varchar(64))} legt ein zusätzliches Attribut für
ein Recht fest, falls ein Fremdobjekt nicht direkt mittels \cmd{artifact\_id}
zugeordnet werden kann. Beispielsweise enthält \cmd{artifact\_index} den Namen
des Verzeichnisses der Mediendatenbank, für das ein Recht vergeben werden soll,
da die vorhandenen Verzeichnisse nicht in der Datenbank verfolgt werden.
\end{ospdescription}

\subsection{Mediendatenbank}

Die Objekte der Mediendatenbank dienen lediglich als Container für Metadaten.
Die eigentlichen Dateien liegen weiterhin im Dateisystem.

\index{Datenbank-Tabellen!serendipity\_images}%
\subsubsection{serendipity\_images}
\begin{ospdescription}
\ospitem{\cmd{id} (Primärschlüssel, int(11))} enthält die fortlaufende ID eines Medienobjekts.
%FM@GH korrekt?
\ospitem{\cmd{name} (varchar(255))} enthält den Dateinamen (ohne Endung).
\ospitem{\cmd{extension} (varchar(5))} enthält die Dateiendung.
\ospitem{\cmd{mime} (varchar(255))} enthält den MIME-Typen für das Medienobjekt.
\ospitem{\cmd{size} (int(11))} enthält die Dateigröße (in Bytes).
\ospitem{\cmd{dimensions\_width} (int(11))} enthält die Bildbreite.
\ospitem{\cmd{dimensions\_height} (int(11))} enthält die Bildhöhe.
\ospitem{\cmd{date} (int(11))} enthält das Hochladedatum (in UNIX-Sekunden).
\ospitem{\cmd{thumbnail\_name} (varchar(255))} enthält das Suffix für die Vorschaubilder.
\ospitem{\cmd{authorid} (Fremdschlüssel, int(11))} verweist auf den Eigentümer der Datei.
\ospitem{\cmd{path} (text)} enthält den Namen des Verzeichnisses, in dem das Bild
gespeichert ist.
\ospitem{\cmd{hotlink} (int(1))} gibt an, ob das Bild von einem fremden Server
geladen wird.
\ospitem{\cmd{realname} (varchar(255))} enthält den ursprünglichen Namen einer
Datei, wenn diese zur Vermeidung doppelter Dateinamen automatisch umbenannt wurde.
\end{ospdescription}

\index{Datenbank-Tabellen!serendipity\_mediaproperties}%
\subsubsection{serendipity\_mediaproperties}

Zu jedem Objekt der Mediendatenbank können beliebig viele Metadaten gespeichert
werden. Diese Metadaten können in verschiedene Unterkategorien aufgeteilt
werden, um zwischen frei vergebenen Metadaten und solchen, die in der Datei
festgelegt wurden, zu unterscheiden.
 
\begin{ospdescription}
\ospitem{\cmd{mediaid} (Fremdschlüssel, int(11))} verweist auf die ID des Medienobjekts.
\ospitem{\cmd{property} (int(11))} enthält den Bezeichner einer Medieneigenschaft.
\ospitem{\cmd{property\_group} (int(11))} enthält die Zuordnung in eine
Metadaten-Gruppe. Mögliche Werte: \cmd{base\_keyword} (freie Schlüsselwörter),
\cmd{base\_property} (freie Metafelder), \cmd{base\_metadata} (Metadaten der Datei).
\ospitem{\cmd{property\_subgroup} (int(11))} kann eine Untergruppierung der
Metadaten enthalten, vor allem im Falle von \cmd{base\_metadata}-Gruppen. Werte
wie \cmd{EXIF}, \cmd{XMP} oder \cmd{ID3} geben die Quelle der Eigenschaft an.
\ospitem{\cmd{value} (int(11))} enthält den zugeordneten Wert einer Medieneigenschaft.
\end{ospdescription}

\subsection{Artikel, Kategorien, Kommentare}

Die folgenden sechs Datenbanktabellen enthalten den Kern der redaktionellen
Inhalte Ihres Blogs: Artikel, Kommentare und Kategorien.
%FM@GH korrekt?

\index{Datenbank-Tabellen!serendipity\_entries}%
\subsubsection{serendipity\_entries}
Enthält die Blog-Artikel.
\begin{ospdescription}
\ospitem{\cmd{id} (Primärschlüssel, int(11))} enthält die ID des Artikels.
\ospitem{\cmd{title} (varchar(200))} enthält den Titel des Artikels.
\ospitem{\cmd{timestamp} (int(10))} enthält die Erstellungszeit des Artikels.
\ospitem{\cmd{last\_modified} (int(10))} enthält das Datum der letzten Aktualisierung.
\ospitem{\cmd{body} (text)} enthält den Artikeltext.
\ospitem{\cmd{extended} (text)} enthält den erweiterten Artikeltext.
\ospitem{\cmd{comments} (int(4))} enthält die Anzahl an Kommentaren zu diesem Artikel.
\ospitem{\cmd{trackbacks} (int(4))} enthält die Anzahl an Trackbacks zu diesem Artikel.
\ospitem{\cmd{exflag} (int(1))} gibt an, ob der Artikel einen erweiterten
Artikeltext besitzt.
\ospitem{\cmd{author} (varchar(20))} enthält den Namen des erstellenden Redakteurs.
\ospitem{\cmd{authorid} (int(11))} enthält die ID des erstellenden Redakteurs.
\ospitem{\cmd{isdraft} (bool)} gibt an, ob der Eintrag ein Entwurf ist.
\ospitem{\cmd{allow\_comments} (bool)} gibt an, ob Kommentare zu diesem Artikel
erlaubt sind.
\ospitem{\cmd{moderate\_comments} (bool)} gibt an, ob Kommentare zu diesem Artikel
moderiert werden.
\end{ospdescription}

\index{Datenbank-Tabellen!serendipity\_entryproperties}%
\subsubsection{serendipity\_entryproperties}
Enthält eine Reihe an zusätzlichen Eigenschaften zu einem Artikel (n:m-Zuordnung).
\begin{ospdescription}
\ospitem{\cmd{entryid} (Fremdschlüssel, int(11))} enthält die zugeordnete Artikel-ID
\ospitem{\cmd{property} (varchar(255))} enthält den Namen der zusätzlichen Eigenschaft.
\ospitem{\cmd{value} (text)} enthält den Wert der Eigenschaft, z.\,B.\ HTML-Text oder
Dateinamen der Mediendatenbank.
\end{ospdescription}

\index{Datenbank-Tabellen!serendipity\_category}%
\subsubsection{serendipity\_category}
Enthält die im Blog erstellten Kategorien. Die Kategorien sind unendlich
ineinander verschachtelbar, da sie der Nested-Set-Datenbankstruktur folgen.
\begin{ospdescription}
\ospitem{\cmd{categoryid} (Primärschlüssel, int(11))} enthält die fortlaufende ID
einer Kategorie.
\ospitem{\cmd{category\_name} (varchar(255))} enthält den Namen einer Kategorie.
\ospitem{\cmd{category\_icon} (varchar(255))} enthält ein optionales Symbolbild, das
Einträgen dieser Kategorie zugewiesen werden kann.
\ospitem{\cmd{category\_description} (text)} enthält die Beschreibung einer Kategorie.
\ospitem{\cmd{authorid} (Fremdschlüssel, int(11))} enthält die ID des
Redakteurs, der diese Kategorie erstellt hat.
\ospitem{\cmd{category\_left} (Fremdschlüssel, int(11))} enthält einen Verweis
auf die \emph{linke} Kategorie in der Nested-Set"=Hierarchie. 
\ospitem{\cmd{category\_right} (Fremdschlüssel, int(11))} enthält einen Verweis
auf die \emph{rechte} Kategorie in der Nested-Set"=Hierarchie.
\ospitem{\cmd{parentid} (Fremdschlüssel, int(11))} enthält einen Verweis auf
die übergeordnete Kategorie.
\end{ospdescription}

\index{Datenbank-Tabellen!serendipity\_entrycat}%
\subsubsection{serendipity\_entrycat}
Weist Einträge bestehenden Kategorien mittels n:m-Verknüpfung hinzu. Ein Eintrag
kann somit mehreren Kategorien zugeordnet werden.
\begin{ospdescription}
\ospitem{\cmd{entryid} (Fremdschlüssel, int(11))} enthält die ID des Artikels.
\ospitem{\cmd{categoryid} (Fremdschlüssel, int(11))} enthält die ID einer Kategorie.
\end{ospdescription}

\index{Datenbank-Tabellen!serendipity\_comments}%
\subsubsection{serendipity\_comments}
Enthält die Kommentare und Trackbacks zu Artikeln.
\begin{ospdescription}
\ospitem{\cmd{id} (Primärschlüssel, int(11))} enthält die ID eines Kommentars.
\ospitem{\cmd{entry\_id} (Fremdschlüssel, int(10))} enthält die ID des Artikels, zu
dem der Kommentar gehört.
\ospitem{\cmd{parent\_id} (Fremdschlüssel, int(10))} enthält die ID des
übergeordneten Kommentars, falls sich der aktuelle Kommentar auf einen anderen beziehen soll.
\ospitem{\cmd{timestamp} (int(10))} enthält das Datum, an dem der Kommentar
gespeichert wurde.
\ospitem{\cmd{title} (varchar(150))} enthält den Titel des Kommentars.
\ospitem{\cmd{author} (varchar(80))} enthält den Namen des Kommentators.
\ospitem{\cmd{email} (varchar(200))} enthält die E-Mail-Adresse des Kommentators.
\ospitem{\cmd{url} (varchar(200))} enthält die Homepage-Adresse des Kommentators. 
\ospitem{\cmd{ip} (varchar(15))} enthält die IP-Adresse des Kommentators.
\ospitem{\cmd{body} (text)} enthält den Kommentartext.
\ospitem{\cmd{type} (varchar(100))} gibt an, ob der Eintrag ein Kommentar
(\cmd{NORMAL}), Trackback (\cmd{TRACK\-BACK}) oder Pingback (\cmd{PINGBACK}) ist.
\ospitem{\cmd{subscribed} (bool)} gibt an, ob der Kommentator über weitere
Kommentare zum Artikel per E-Mail benachrichtigt werden soll.
\ospitem{\cmd{status} (varchar(50))} gibt den Status eines Kommentars an:
\cmd{approved} (veröffentlicht) oder \cmd{pending} (in Moderation).
\ospitem{\cmd{referer} (referer(200))} enthält die URL, die der Kommentator vor dem
Aufruf Ihres Blogs besucht hat.
\end{ospdescription}

\index{Datenbank-Tabellen!serendipity\_references}%
\subsubsection{serendipity\_references}
Alle URLs, die ein Redakteur in einem Artikel einbindet, werden in dieser
Datenbanktabelle gespeichert. Solche Referenzen können durch Plugins
dargestellt oder ausgewertet werden. Des Weiteren enthält diese Tabelle auch
alle Referenzen von aufgerufenen Bildern Ihrer Mediendatenbank (siehe Seite \pageref{mdb-profi}).

\begin{ospdescription}
\ospitem{\cmd{id} (Primärschlüssel, int(11))} enthält die fortlaufende ID einer
referenzierten URL. 
\ospitem{\cmd{entry\_id} (Fremdschlüssel, int(10))} enthält die ID des Artikels, zu
dem die referenzierte URL gehört.
\ospitem{\cmd{link} (text)} enthält die vollständige referenzierte URL.
\ospitem{\cmd{name} (text)} enthält den beschreibenden Text zu der referenzierten URL.
\ospitem{\cmd{type} (varchar(128))} legt den Typ der Referenz fest. \cmd{media}
steht für verwiesene Mediendatenbank"=Objekte, ein leerer Typ steht für
gewöhnlich referenzierte URLs. 
\end{ospdescription}

\subsection{Zentraltabellen}
 
Weiterhin greift Serendipity auf eine Menge weiterer Tabellen zu, die nicht den
vorigen Gruppierungen zuzuordnen sind.

\index{Datenbank-Tabellen!serendipity\_config}%
\subsubsection{serendipity\_config}
Enthält sämtliche Konfigurationsoptionen des Blogs, von Plugins und persönlichen
Einstellungen der Redakteure.
\begin{ospdescription}
\ospitem{\cmd{name} (varchar(255))} enthält den Namen einer Konfigurationsoption.
Plugin-Optionen werden mit dem Namen des Plugins als Präfix gespeichert.
\ospitem{\cmd{value} (text)} enthält den Wert einer Konfigurationsoption.
\ospitem{\cmd{authorid} (Fremdschlüssel, int(11))} enthält die ID eines Redakteurs,
falls die Konfigurationsoption einer persönlichen Einstellung entspricht.
\end{ospdescription}

\index{Datenbank-Tabellen!serendipity\_permalinks}%
\subsubsection{serendipity\_permalinks}
Enthält eine Look-Up-Tabelle von Permalinks. Serendipity kann die aufgerufene
URL mit einem der in dieser Tabelle hinterlegten Permalinks vergleichen, um dann
die entsprechenden Inhalte darzustellen. Dabei unterstützt Serendipity
Permalinks für Einträge, Kategorien, Autoren und RSS-Feeds.

\begin{ospdescription}
\ospitem{\cmd{permalink} (varchar(255))} enthält die URL des Permalinks.
\ospitem{\cmd{entry\_id} (varchar(255))} enthält die ID des Zielinhalts
(Kategorie-ID, Autor-ID, Artikel-ID).
\ospitem{\cmd{type} (varchar(255))} legt den Typ des Permalinks (\cmd{category},
\cmd{author}, \cmd{entry}) fest.
\ospitem{\cmd{data} (varchar(255))} kann zusätzliche Werte enthalten, derzeit noch
nicht genutzt.

\end{ospdescription}

\index{Datenbank-Tabellen!serendipity\_plugincategories}%
\subsubsection{serendipity\_plugincategories}
Enthält eine Zuordnung der Plugins zu ihren jeweiligen Gruppen. Diese Tabelle
wird automatisch gefüllt, sie kann gefahrlos geleert werden, um eine
Neu-Initialisierung zu erzwingen.

\begin{ospdescription}
\ospitem{\cmd{class\_name} (varchar(250))} enthält den Namen eines Plugins.
\ospitem{\cmd{category} (varchar(250))} enthält den Namen einer Kategorie, die dem
Plugin zugeordnet ist.
\end{ospdescription}

\index{Datenbank-Tabellen!serendipity\_pluginlist}%
\subsubsection{serendipity\_pluginlist}
Enthält Metadaten zu den verfügbaren, installierbaren Plugins. Diese Tabelle
wird automatisch gefüllt, sie kann gefahrlos geleert werden, um eine
Neu-Initialisierung zu erzwingen. Der Inhalt dieser Tabelle gilt als
Zwischenspeicher, damit die performance-intensive Plugin-Abfrage nur bei Bedarf
ausgeführt werden muss.

\begin{ospdescription}
\ospitem{\cmd{plugin\_file} (varchar(255))} enthält den Basisnamen eines Plugins.
\ospitem{\cmd{class\_name} (varchar(255))} enthält den PHP-Klassennamen eines Plugins.
\ospitem{\cmd{plugin\_class} (varchar(255))} enthält den Serendipity-internen
Klassennamen eines Plugins, bei dem interne Plugins mit einem \cmd{@}-Zeichen
gekennzeichnet werden.
\ospitem{\cmd{pluginPath} (varchar(255))} enthält den Pfad zum Plugin.
\ospitem{\cmd{name} (varchar(255))} enthält den Namen des Plugins.
\ospitem{\cmd{description} (text)} enthält die Beschreibung eines Plugins.
\ospitem{\cmd{version} (varchar(12))} enthält die Versionsnummer eines Plugins.
\ospitem{\cmd{upgrade\_version} (varchar(12))} enthält die aktuell online verfügbare
Version des Plugins.
\ospitem{\cmd{plugintype} (varchar(255))} legt den Typ eines Plugins
fest (\cmd{sidebar} für Seitenleisten-Plugins, \cmd{event} für Ereignis-Plugins).
\ospitem{\cmd{pluginlocation} (varchar(255))} gibt an, wo das Plugin heruntergeladen
werden kann (\cmd{local} oder \cmd{Spartacus}).
\ospitem{\cmd{stackable} (int(1))} gibt an, ob ein Plugin mehrfach installiert
werden kann.
\ospitem{\cmd{author} (varchar(255))} gibt den Namen des Plugin-Autors an.
\ospitem{\cmd{requirements} (text)} gibt etwaige Rahmenbedingungen für das Plugin an.
\ospitem{\cmd{website} (varchar(255))} gibt eine Homepage des Plugin-Autors an.
\ospitem{\cmd{last\_modified} (int(11))} gibt an, ob und wann das Plugin zuletzt
auf Ihrem Server aktualisiert wurde.
\end{ospdescription}

\index{Datenbank-Tabellen!serendipity\_plugins}%
\subsubsection{serendipity\_plugins}
Enthält eine Liste der installierten und aktivierten Plugins im Blog.
\begin{ospdescription}
\ospitem{\cmd{name} (Primärschlüssel, varchar(128))} enthält den Namen des Plugins
inklusive der zufällig zugeteilten ID.
\ospitem{\cmd{placement} (varchar(6))} legt fest, wo das Plugin platziert ist.
Mögliche Werte: \cmd{event} (Ereignis-Plugin), \cmd{eventh} (deaktiviertes
Ereignis-Plugin), \cmd{left} (Plugin in linker Seitenleiste),  \cmd{right}
(Plugin in rechter Seitenleiste), \cmd{hidden} (verstecktes
Seitenleisten-Plugin) sowie die Namen aller selbständig festgelegten Seitenleisten.
\ospitem{\cmd{sort\_order} (int(4))} gibt einen numerischen Wert zur
Sortierungsreihenfolge der Plugins untereinander an.
\ospitem{\cmd{authorid} (int(11))} enthält die ID des Redakteurs, der das Plugin
installiert hat.
\ospitem{\cmd{path} (varchar(255))} enthält den Verzeichnispfad zum jeweiligen Plugin.
\end{ospdescription}

\index{Datenbank-Tabellen!serendipity\_exits}%
\index{Datenbank-Tabellen!serendipity\_referrers}%
\subsubsection{serendipity\_exits, serendipity\_referrers}
\cmd{serendipity\_exits} enthält bei aktiviertem Exit-Tracking (siehe Seite \pageref{trackexits})
Statistiken über  Links in Ihren Blog-Artikeln, auf die Besucher geklickt haben.
\cmd{serendipity\_referrers} enthält bei aktiviertem Referrer-Tracking 
(siehe Seite \pageref{trackreferrer}) die Statistiken über Webseiten, 
von denen aus Besucher auf Ihr Blog gelangen. 
Beide Tabellen werden über den Umweg der Tabelle \cmd{serendipity\_suppress}
gefüllt.

\begin{ospdescription}
\ospitem{\cmd{entry\_id} (Primärschlüssel, int(11))} enthält die ID des zugehörigen
Blog-Artikels, von dem aus ein Exit-Link geklickt wurde bzw. auf dessen URL von
einem fremden Blog verwiesen wurde.
\ospitem{\cmd{day} (date)} enthält das Datum, an dem der Tabelleneintrag erstellt wurde.
\ospitem{\cmd{count} (int(11))} enthält die Anzahl für den jeweiligen statistischen Wert.
\end{ospdescription}

\index{Datenbank-Tabellen!serendipity\_suppress}%
\subsubsection{serendipity\_suppress}
Diese Tabelle dient der Befüllung der Tabellen \cmd{serendipity\_exits} und
\cmd{serendipity\_referrers}. Eine verweisende URL oder die in einem Artikel
eingebundene URL wird beim Aufruf durch einen Besucher erst in dieser Tabelle
zwischengespeichert. Erst sobald der jeweilige Link mehr als einmal
aufgerufen/übermittelt wurde, wird der Besuch auch in der zugehörigen Tabelle
\cmd{serendipity\_exits} oder \cmd{serendipity\_referrers} gespeichert. Dies
kann in geringem Maß Spam erschweren, aber leider mittlerweile 
auch nicht mehr verhindern.

\begin{ospdescription}
\ospitem{\cmd{ip} (varchar(15))} IP des Besuchers.
\ospitem{\cmd{scheme} (varchar(5))} enthält den Teil der URL des Tabelleneintrags,
der das Protokoll angibt (z.\,B.\ \cmd{http://}).
\ospitem{\cmd{host} (int(128))} enthält den Servernamen einer URL.
\ospitem{\cmd{port} (int(5))} enthält den Port einer URL.
\ospitem{\cmd{path} (int(255))} enthält den Verzeichnisteil einer URL.
\ospitem{\cmd{query} (int(255))} enthält zusätzliche GET-Parameter einer URL.
\ospitem{\cmd{last} (timestamp)} enthält das Datum des letzten Besuchs der URL.
\end{ospdescription}

\index{Datenbank-Tabellen!serendipity\_spamblocklog}%
\subsubsection{serendipity\_spamblocklog}
\label{db-spamblocklog}%
Diese Tabelle enthält Protokollmeldungen des Antispam-Plugins (siehe Seite
\pageref{spamblock}), beispielsweise Hinweise zu abgewiesenen oder
moderierten Kommentaren und Fehlermeldungen. Mit der Zeit kann diese Tabelle
recht groß werden, da Serendipity sie nicht selbständig leert. Sie können
alle Einträge gefahrlos löschen, wenn Sie diese nicht weiter benötigen (siehe
Seite \pageref{spamblocklog-loeschen}). Selbstverständlich können Sie in den
Einstellungen des Anti-Spam-Plugins die Protokollierung auch vollständig deaktivieren.

Ein Protokolleintrag wird vom Anti-Spam-Plugin nur dann erstellt, wenn ein
neuer Kommentar zu einem Blog-Artikel verfasst wurde. Daher ist ein
Protokolleintrag stets mit einem Blog-Artikel und einem Kommentar verbunden.

\begin{ospdescription}
\ospitem{\cmd{timestamp} (int(10))} enthält das Datum, an dem der Protokolleintrag
erstellt wurde.
\ospitem{\cmd{type} (varchar(255))} enthält eine Klassifizierung des
Protokolleintrags.
\ospitem{\cmd{reason} (text)} enthält den ausführlichen Protokolltext.
\ospitem{\cmd{entry\_id} (int(10))} enthält die ID des Artikels, auf den sich der
Protokolleintrag bezieht.
\ospitem{\cmd{author} (varchar(80))} enthält den Namen des Kommentarautors.
\ospitem{\cmd{email} (varchar(200))} enthält die E-Mail-Adresse des Kommentarautors.
\ospitem{\cmd{url} (varchar(200))} enthält die Homepage des Kommentarautors.
\ospitem{\cmd{useragent} (varchar(255))} enthält den verwendeten Browser des
Kommentarautors.
\ospitem{\cmd{ip} (varchar(15))} enthält die IP-Adresse des Kommentarautors.
\ospitem{\cmd{referer} (varchar(255))} enthält die URL der vorher vom Kommentarautor
besuchten Webseite.
\ospitem{\cmd{body} (text)} enthält den Kommentartext.
\end{ospdescription}


%revised
\index{SVN}%
\index{CVS}%
\index{Sourcecode-Verwaltung}%
\index{Sourceforge}%
\index{BerliOS}%
\section{Sourcecode-Verwaltung}
\label{sourcecodeverwaltung}

Serendipity ist letztlich nur eine Ansammlung von PHP-Dateien. In allen
OpenSource-Projekten ist es üblich, den Quellcode für Interessierte vollständig 
offen und transparent zu verwalten.

Dazu hat sich seit langer Zeit der Service von
SourceForge\footnote{\cmd{http://www.sourceforge.net/}} als Standard etabliert,
der OpenSource-Projekten kostenlos Verwaltungsdienste und Speicherplatz anbietet. 

Die Projektseite von Serendipity befindet sich unter
\cmd{http://www.source\-forge.net/projects/php-blog}. Dort gibt es einige
Mailinglisten, Bug-Tracker und vor allem den Download der offiziellen
Serendipity-Releases. 

Bis vor einigen Jahren wurde auch der Quellcode von Serendipity dort mittels
einer Software namens
CVS\footnote{\cmd{http://de.wikipedia.org/wiki/Concurrent\_Versions\_System}} verwaltet.
CVS ist eine Software, die auf einem Server läuft, um dort mehreren Entwicklern
den direkten Zugriff auf den Quellcode zu ermöglichen. Die Entwickler können
dort alle Dateien auf ihren lokalen Entwicklungsrechner herunterladen, ihre
Änderungen vornehmen und die Dateien dann wieder auf den Server (in das
sogenannte \emph{Repository}, das Archiv) hochladen. 

Gewissermaßen kann man CVS mit FTP vergleichen, nur dass CVS weitaus komplexere Upload- und
Downloadmethoden unterstützt. Bei jeder Änderung am Quellcode (\emph{Commit}, eine Übertragung)
protokolliert der CVS-Server dies und speichert es als neue \emph{Revision}. So
können jederzeit einfach Änderungen rückgängig gemacht oder Vergleiche
zwischen verschiedenen Versionsständen angestellt werden. Auch ist durch dieses
Vorgehen sichergestellt, dass zwei Entwickler nicht versehentlich die Änderungen
einer anderen Person unwiderruflich löschen -- CVS dient also gleichzeitig als Backup.
 
\index{Branches}%
\index{trunk}%
Entwickler können zu einem gewünschten Zeitpunkt sogenannte \emph{Branches} des Quellcodes
erstellen. Dabei wird eine Kopie des aktuellen Quellcodes angelegt, neue
Änderungen am Code werden in dieser Kopie vorgenommen. Dadurch kann eine
Software bereits neue, experimentelle Features in Version 2.0 einbauen, während
die stabile Versionsnummer 1.0 parallel weiterentwickelt wird. CVS
erlaubt es auch, zwischen diesen verschiedenen \emph{Verästelungen}
Codevergleiche durchzuführen. Auch Serendipity nutzt dieses Prinzip, bei dem
lediglich Bugfixes in einer stabilen Versionsnummer eingefügt werden. Nur die
jeweils neueste Beta-Versionslinie (\emph{trunk}, engl. Baumstamm) 
enthält möglicherweise noch nicht vollständig getestete Features.

Um CVS nutzen zu können, benötigt man eine Software wie \cmd{TortoiseCVS} oder
den Kommandozeilen-Client \cmd{cvs}. Erst über diese Programme kann man die
Fähigkeiten von CVS nutzen, ähnlich wie bei Verwendung eines FTP-Programms.
 
\index{Subversion}%
Vor einigen Jahren wurde der Nachfolger von CVS verfügbar: \emph{Subversion},
kurz SVN. SVN ähnelt CVS in sehr vielen Bereichen, ist aber leistungsfähiger,
schneller und erlaubt einige sehr sinnvolle Verwaltungsoperationen wie z.\,B.\
vollständig symbolisch erzeugte \emph{Branches}.

Damals bot SourceForge noch keinen SVN-Zugriff an, daher migrierten die
Entwickler von Serendipity auf einen anderen Dienstleister namens
\emph{BerliOS}\footnote{\cmd{http://developer.berlios.de}}. Bis heute wird dort
das Serendipity-Sourcecode-Repository mittels SVN gepflegt. 

Dennoch ist das alte CVS-Repository bei SourceForge noch vorhanden. Dort werden
separat die erweiterten Plugins (\emph{Spartacus}) gepflegt. Die Aufteilung in
SVN und CVS hat somit noch den Vorteil, dass das verbreitetere (und
einfachere) CVS so für freiwillige Plugin-Entwickler leichter verfügbar ist.

\subsection{Freier Zugriff}

Die SVN- und CVS-Quellen sind für Besucher mit vollem Lesezugriff frei
zugänglich. Um darauf zuzugreifen, benötigen Sie eine CVS- oder SVN-Software.
Weitere Anweisungen, wie Sie auf ein \emph{Repository} zugreifen können, sind
auf den Projektseiten \cmd{http://sourceforge.net/cvs/?group\_""id=75065} (CVS)
und \cmd{http://developer.berlios.de/svn/?group\_id=""2573} (SVN) ausführlich
dokumentiert. 

Schreibzugriff können Sie erlangen, indem Sie im Serendipity"=Entwicklerforum
danach fragen und einige Beispiele dafür geben, was Sie beisteuern wollen. Wie
dieser Prozess vonstatten geht, ist auf Seite \pageref{community} näher erläutert.

Wenn Sie über kein CVS-Programm verfügen, können Sie auch über webbasierte
CVS-Clients Einblick in das \emph{Repository} erhalten. Den Quellcode von
Serendipity finden Sie unter
\cmd{http://svn.berlios.de/viewcvs/seren\-dipity/trunk/} und alle
Spartacus-Plugins unter
\cmd{http://php-blog.cvs.""sourceforge.net/php-blog/additional\_plugins/}. Von dort
aus können Sie sogar einzelne Dateien direkt herunterladen oder neue
Dateiversionen miteinander vergleichen.

\subsection{Aktualisierung über CVS/SVN}

CVS ist nicht nur für Entwickler von Interesse. Wenn Sie SSH-Zugriff zu Ihrem
Server besitzen, kann CVS sehr hilfreich dabei sein, Serendipity auf dem
aktuellsten Stand zu halten.

\osppagebreak

Anstatt erst ein ZIP-Archiv mit der neuen Serendipity-Version herunterzuladen,
könnten Sie Ihren Server auch direkt über einen \emph{CVS/SVN checkout} laufen
lassen. Sobald Sie Serendipity z.\,B.\ mittels

\begin{ospcode}
\$ cd /home/www/example.com/
\$ svn checkout svn://svn.berlios.de/serendipity/trunk
\end{ospcode}

auf Ihren Server geladen haben, reicht später ein einfaches

\begin{ospcode}
\$ cd /home/www/example.com/
\$ svn update
\end{ospcode}

um die aktuellste Version der Serendipity-Dateien zu erhalten. Dabei hat CVS/SVN
einen zentralen Vorteil: Falls Sie jemals manuell eine Datei editiert haben,
kann der CVS/SVN-Client dafür sorgen, dass Ihre Änderungen nicht überschrieben
werden. Bis zu gewissen Grenzen kann CVS/SVN automatisch dafür sorgen, dass Ihre
Änderungen mit den offiziellen Änderungen an einer Datei verbunden werden. Nur
wenn sich eine Datei grundlegend ändert, wird CVS/SVN auf einen Konflikt hinweisen.

Im gleichen Zug ermöglicht es Ihnen CVS/SVN, Ihre eigenen Änderungen an
Serendipity mittels

\begin{ospcode}
\$ cd /home/www/example.com/
\$ svn diff
\end{ospcode}
 
in einem maschinenlesbaren Format auszuwerten. Wenn Sie beispielsweise
sinnvollen Code zur Community beisteuern wollen, hilft dieses
\emph{DIFF-Format}, Ihre Änderungen allen zur Verfügung zu stellen.

Auch die Spartacus-Plugins können Sie komfortabel über einen \emph{CVS checkout}
verwalten. Dabei kommt Ihnen zugute, dass Serendipity beliebig verschachtelte
Verzeichnisstrukturen des \cmd{plugins}-Verzeichnisses unterstützt. Einen Checkout
des CVS-Moduls \cmd{additional\_plugins} können Sie wie folgt erreichen:

\begin{ospcode}
\$ cd /home/www/example.com/plugins
\$ cvs -d:pserver:anonymous@php-blog.cvs.sf.net:/cvsroot/php-blog login
\$ cvs -d:pserver:anonymous@php-blog.cvs.sf.net:/cvsroot/php-blog 
 checkout additional\_plugins
\end{ospcode}

Daraufhin enthält das Verzeichnis \cmd{/plugins/additional\_plugins} alle
Zusatz-Plugins von Serendipity. Danach können Sie jedes verfügbare Plugin direkt
aktivieren, ohne es herunterzuladen. Regelmäßige Updates an Plugins können dann
ebenfalls per \cmd{cvs update} eingespielt werden. 

Dasselbe Vorgehen gilt neben \cmd{plugins} übrigens auch für \cmd{templates}:

\begin{ospcode}
\$ cd /home/www/example.com/templates
\$ cvs -d:pserver:anonymous@php-blog.cvs.sf.net:/cvsroot/php-blog login
\$ cvs -d:pserver:anonymous@php-blog.cvs.sf.net:/cvsroot/php-blog 
 checkout additional\_themes
\end{ospcode}
 
\index{Spartacus}%
\subsection{Spartacus}

\emph{Spartacus} ist Serendipitys zentrales Plugin-Archiv. Es besteht aus zwei
Komponenten: einem Server und einem Client. Der Server (SourceForge) bietet die
Plugins an, der Client (das Spartacus-Plugin Ihres Blogs) lädt ein Plugin
herunter. 

Im Hintergrund passiert Folgendes: Auf dem SourceForge-Server wird das
CVS-Repository \cmd{additional\_plugins} verwaltet. Dort werden regelmäßig einmal
am Tag durch einen automatisierten Vorgang\footnote{Für Interessierte: Das
automatische Script zur Erstellung ist in diesem Repository als Datei
\cmd{emerge\_spartacus.php} hinterlegt.} zahlreiche
XML"=Dateien erstellt, die alle notwendigen Informationen der Plugins enthalten.

Daraufhin werden anhand dieser XML-Informationen automatisch HTML-Dateien
erzeugt, die auf \cmd{http://spartacus.s9y.org} dargestellt werden. Jedes Plugin
wird zudem als ZIP-Archiv komprimiert und ebenfalls auf dem Webserver zur
Verfügung gestellt.

\index{Netmirror.org}
Die Sammlung an XML-Dateien sowie der Quellcode der Plugins werden zusätzlich
automatisch an den Mirror \cmd{netmirror.org} ausgeliefert. Sollte einmal ein
Server nicht erreichbar sein, gibt es somit immer noch einen weiteren
Notfallserver.

Nun ist der serverseitige Vorgang abgeschlossen, und der Client (Ihr Blog) muss
lediglich darauf zugreifen. Beim Aufruf der Plugin"=Verwaltungsoberfläche Ihres
Blogs lädt das Plugin automatisch vom konfigurierten Server die XML-Datei
herunter. Die Liste von Ereignis-Plugins befindet sich in der Datei
\cmd{package\_event\_de.xml}, die Seitenleisten-Plugins in der Datei
\cmd{package\_sidebar\_de.xml} und Templates in
\cmd{package\_template.xml}. Plugin-Beschreibungen sind sprachabhängig, das Kürzel am Ende des
Dateinamens legt dabei die Sprache fest. 

Diese XML-Dateien werden vom Plugin in Ihr Verzeichnis \cmd{templates\_c}
heruntergeladen und von dort aus gecached. Erst wenn Ihre temporären Dateien
älter als einen Tag sind, werden sie vom Plugin erneut geladen. Dies verringert
den anfallenden Traffic deutlich.

Die XML-Dateien werden vom Plugin ausgewertet und in der Oberfläche
dargestellt. Wenn Sie nun eines dieser Spartacus-Plugins installieren wollen,
lädt das Plugin die Rohdateien direkt vom konfigurierten Mirror-Server herunter
und speichert sie lokal auf Ihrem Server.

Sobald die Dateien lokal vorhanden sind, werden sie von Serendipity wie übliche
Plugins behandelt. Einmal via Spartacus heruntergeladene Dateien können dann in
Zukunft jeweils mit der aktuellsten Version des Plugins verglichen und
gegebenenfalls neu heruntergeladen werden.
 

%revised
\index{Plugin-API}%
\section{Plugin-API}
\label{pluginapi}%

Die Serendipity Plugin-API stellt das Herz von Serendipity dar. Als API
bezeichnet man eine Sammlung an Funktionen oder Objekten/Klassen, die
standardisierten Zugriff auf ein System zulassen.

Serendipity abstrahiert mit seiner Plugin-API beinahe alle Vorgänge im
Kernsystem. Plugins haben an vielen (und leicht erweiterbaren) Stellen im
Arbeitsablauf des Frontends und Backends die Möglichkeit, beliebig einzugreifen
und PHP-Code auszuführen.

Auf PHP-Seite ist diese Plugin-API mittels objektorientierter Techniken
(\emph{OO}) umgesetzt. Objektorientierte Programmierung hat den Vorteil, dass sie
relativ leicht dokumentiert werden kann und gerade für Rohgerüste durchschaubarer
ist als eine einfache Ansammlung von Funktionen. Objektvererbung und Kapselung
erhöhen zudem die Code-Qualität und führen zu weniger Redundanz. Für Programmierer
ist es wichtig, zwischen einem Objekt und einer Klasse zu unterscheiden: Klassen
legen lediglich eine Struktur fest (ähnlich wie ein Bauplan). Objekte sind
\emph{umgesetzte} Baupläne, also z.\,B.\ ein fertiges Haus. Demzufolge bietet die
Serendipity Plugin-API eine Reihe von Bauplänen an, nach denen Sie Ihre Plugins
entwickeln können. Teile der Plugin-API stehen als \emph{fertige Häuser} direkt
zur Verfügung und können aktiv aufgerufen werden, um z.\,B.\ eine Liste aller
verfügbaren Plugins zu erhalten.

Die Plugin-API unterscheidet sich dabei leicht, je nachdem, ob sie bei einem
Ereignis-Plugin oder einem Seitenleisten-Plugin zum Einsatz kommt.

Ein Plugin besteht dabei aus einer PHP-Datei wie
\cmd{serendipity\_event\_""testplugin.php}. In dieser PHP-Datei wird eine Sammlung
von Plugin-API-Aufrufen innerhalb einer sogenannten \emph{Klasse} gekapselt.
Sämtliche Aktionen und Meta-Informationen des Plugins befinden sich in dieser
Datei und müssen in einem gleichnamigen Verzeichnis wie z.\,B.\
\cmd{plugins/seren\-dipity\_event\_testplugin} abgelegt werden.

Der Serendipity-Kern kümmert sich automatisch darum, alle installierten
Plugin-Dateien zu laden (\emph{instanzieren}) und an den gewünschten Stellen
auszuführen.

Dazu verwendet Serendipity ein ereignisgesteuertes Prinzip. Ein PHP-Script läuft
immer linear von \emph{oben nach unten} ab und führt alle enthaltenen Kommandos
aus. Genauso läuft auch (wie auf Seite \pageref{workflow} dokumentiert) der
Kern-Workflow von Serendipity ab. An zahlreichen Stellen können sogenannte
\emph{Ereignisse} (Events) stattfinden, die die Ausführung des Kerns kurzzeitig 
\emph{pausieren} und stattdessen alle Plugins ausführen, die sich für das jeweilige Ereignis
registriert haben.

Das Plugin erhält dabei eine Liste an Übergabeparametern und -variablen (\cmd{Event-Daten}), mit
denen es beliebige Aktionen durchführen kann. Nachdem dies geschehen ist, wird
das nächste Plugin für dasselbe Ereignis ausgeführt -- solange, bis keine weiteren
auszuführenden Plugins mehr vorhanden sind. Dann kehrt der Kern-Workflow zurück
zu der Stelle vor dem Plugin-Aufruf und fährt fort mit den Daten, die
möglicherweise von Plugins verändert wurden.

Ein Beispiel: Wenn ein Artikel gespeichert wird, bereitet Serendipity die Daten
in einem umfangreichen PHP-Array vor. Bevor diese Daten des Artikels nun in der
Datenbank gespeichert werden, wird das Ereignis namens \cmd{backend\_save}
ausgeführt. Wenn ein Plugin auf dieses Ereignis \emph{lauscht}, kann es die
Artikeldaten verändern. Beispielsweise kann das Plugin \emph{Google Sitemap}
dafür sorgen, dass Google über den gerade erstellten Artikel informiert
(\emph{gepingt}) wird.
 
Ein Plugin kann nur entweder als Ereignis- oder als Seitenleisten-Plugin
vorliegen. Seitenleisten-Plugins können lediglich Ausgaben in der Seitenleiste
einbinden und auf keine Ereignisse reagieren. Ereignis-Plugins wiederum können
ohne Weiteres keine Ausgaben in der Seitenleiste vornehmen. Sie können jedoch
Abhängigkeiten von Plugins untereinander definieren und sowohl ein
Seitenleisten-Plugin als auch ein Ereignis-Plugin im selben Verzeichnis
unterbringen.

Bei der Erstellung eines neuen Plugins ist es am einfachsten, sich ein
bestehendes Plugin vorzunehmen, das so ähnlich funktioniert wie das, was Sie
programmieren möchten. Kopieren Sie dieses Plugin dann in ein neues Verzeichnis
mit neuem Namen, benennen Sie die \cmd{.php}-Datei entsprechend um und ändern Sie den
Namen der PHP-Klasse in dieselbe Bezeichnung. Nun können Sie nach Belieben diesen
Plugin-Klon verändern und Ihren Anforderungen entsprechend anpassen.

Es gibt bereits zahlreiche Plugins für Serendipity, so dass Sie für jedes
Vorhaben zumindest eine grobe Vorlage finden sollten.

\subsection{Seitenleisten-API}

Die API eines Seitenleisten-Plugins ist die einfachste Form, um sich mit einem
Serendipity-Plugin vertraut zu machen. Seitenleisten-Plugins müssen mit dem Präfix
\cmd{serendipity\_plugin\_\ldots} benannt werden.

Ein einfaches Plugin, das lediglich die Ausgabe \cmd{Hallo Welt!} in der
Seitenleiste liefert, können Sie als
\cmd{plugins/serendipity\_plugin\_helloworld/""serendipity\_plugin\_helloworld.php}
speichern:

\input{snippets/helloworld.tex}

\label{api-lang}
Dieses Plugin ist stark vereinfacht, es enthält beispielsweise keine
internationalisierte Sprachverwaltung. Dies wird in Plugins meist per
\emph{Include} einer Datei wie \cmd{lang\_de.inc.php} gelöst, die die
entsprechenden Sprachkonstanten festlegt. Eingebunden wird eine solche
Sprachdatei dann mit folgendem Code am Anfang der PHP-Datei:

\begin{ospcode}
\$probelang = dirname(\_\_FILE\_\_) . '/' . \$serendipity['charset'] . 
'lang\_' . \$serendipity['lang'] . '.inc.php';
if (file_exists(\$probelang)) \{
    include \$probelang;
\}

include dirname(\_\_FILE\_\_) . '/lang\_en.inc.php';
\end{ospcode}

Die Variable \cmd{\$probelang} enthält den Dateinamen der lokalen Sprachdatei, 
die eingebunden wird. Zusätzlich bindet das Plugin zur Sicherheit die englische Sprachdatei ein,
da diese Datei manchmal einige noch nicht übersetzte Konstanten enthalten kann.

Gehen wir nun den vollständigen Code des Plugins einmal durch. Die ersten
drei Zeilen beinhalten eine Sicherheitsabfrage, ob das Plugin auch wirklich im
Serendipity-Kontext ausgeführt wird. Die Konstante \cmd{IN\_serendipi\-ty} ist nur
dann gesetzt, wenn das Serendipity-Framework geladen wurde.

Danach wird die PHP-Klasse \cmd{serendipity\_plugin\_helloworld} definiert, die
sich von der Basisklasse \cmd{serendipity\_plugin} ableitet und deren Methoden
einsetzt. 

Die Methode \cmd{introspect()} dient dem Plugin dazu, seine Metadaten
festzulegen. Dort wird ein Hilfsobjekt \cmd{\$propbag} verwendet, das ein
beliebiges Array mit Daten wie dem Namen des Plugins, der Beschreibung, etwaigen
Copyrights, Voraussetzungen und Liste von Konfigurationsoptionen enthalten kann.

Die Methode \cmd{introspect\_config\_item()} wird verwendet, damit das\osplinebreak{}
Plugin beliebige Konfigurationsoptionen im Plugin-Manager darstellen und
auswerten kann.

Zuletzt wird die Methode \cmd{generate\_content()} deklariert, die später die
eigentliche Ausgabe des Plugins mit beliebigem PHP-Code enthält. 

Dabei liest das Plugin die Konfigurationsoption \cmd{intro} aus, mit der Sie in
der Konfiguration des Plugins einen beliebigen HTML-Text eintragen konnten.
Diese Variable wird ganz einfach ausgegeben.

\index{Fehler!Plugins}%
Sobald ein derartiges Plugin auf dem Server gespeichert wurde, können
Sie es wie gewohnt über die Plugin-Oberfläche aktivieren. Achten Sie darauf,
etwaige PHP-Fehler zu vermeiden. Ansonsten werden diese im Backend oder auch im
Frontend ausgegeben. Fatale PHP-Fehlermeldungen (Syntaxfehler) können zudem
dazu führen, dass das gesamte Serendipity-Frontend nicht mehr aufgerufen werden
kann. Wenn Sie den Fehler nicht direkt finden, können Sie einfach die PHP-Datei
des Plugins löschen, um Ihr Blog wieder funktionabel zu machen.

\index{Event-API}%
\index{Ereignis-API}%
\subsection{Ereignis-API}

Ganz ähnlich wie ein Seitenleisten-Plugin sieht die Struktur eines
Ereignis-Plugins aus.

Auch hier wollen wir als Beispiel ein einfaches Plugin herstellen, das lediglich
ein Stück HTML-Code im Frontend ausgibt.

Dieses speichern wir als
\cmd{plugins/serendipity\_event\_helloworld/se\-rendipity\_event\_helloworld.php}: 

\input{snippets/helloworld2.tex}

Hier bestehen nur wenige Unterschiede:

\begin{osplist}
\item Das Plugin verwendet das Präfix \cmd{serendipity\_event\_} anstelle von
\cmd{se\-rendipity\_plugin\_}. 
\item In der \cmd{introspect(}-Methode gibt das Plugin an, auf welche Ereignisse
es reagieren will (\cmd{event\_hooks}).
\item Es deklariert zwei Hilfsmethoden, \cmd{show()} und \cmd{selected()}. Mit
diesen beiden Methoden kapselt das Plugin Zugriffe auf die Darstellung seines
Inhalts und die Überprüfung, ob es aufgerufen wird.
\item Die zentrale Methode stellt \cmd{event\_hook()} anstelle von
\cmd{generate\_con\-tent()} bei Seitenleisten-Plugins dar.
\end{osplist}

\index{Dispatcher}%
\index{Event-Hook}%
Wichtigste Stelle aller Ereignis-Plugins ist die \cmd{event\_hook()}-Methode.
Sie ist eine Art \emph{Dispatcher} (Verteiler) und wird für jedes
Ereignis aufgerufen, so dass das Plugin anhand der Parameter entscheidet,
ob es zu diesem Ereignis eine Hilfsmethode oder direkten PHP-Code ausführt. 

Diese Prüfung findet in einer großen \cmd{switch}-Anweisung statt, die alle
möglichen und \emph{gelauschten} Ereignisse mit dem aktuellen Ereignis abgleicht
und den entsprechenden Codeteil ausführt.

Sobald Sie obiges Beispiel-Plugin installiert haben, können Sie es über die URL
\cmd{http://www.example.com/serendipity/index.php?serendipity""subpage]=beispiel} aufrufen.
Die URL-Variable \cmd{subpage} richtet sich dabei nach dem Wert, den Sie im
Plugin für \cmd{pagetitle} festgelegt haben. 

Ereignis-Plugins sind meist komplexer als Seitenleisten-Plugins, weil sie mehr
Aktionen ausführen müssen und mehr Abhängigkeiten berücksichtigen. Das hier
vorgestellte Plugin ist daher sogar schon etwas komplexer, da es einen ganz
eigenen Inhalt im Frontend einbindet. Einfachere Ereignis-Plugins könnten auch
mit weniger Code schon simple Dinge ausführen, wie Leerzeilen durch den
HTML-Code \cmd{<br />} (PHP-Funktion \cmd{nl2br()}) zu ersetzen:

\input{snippets/helloworld3.tex}

Dieses Plugin entspricht einer entschlackten Version des
\cmd{serendipity\_""event\_nl2br}-Plugins von Serendipity, aus dem alle unnötigen
Attribute entfernt wurden.

\subsection{Methoden der Plugin-API}

Die Serendipity Plugin-API besteht im Wesentlichen aus fünf Klassen:

\begin{osplist}
 
\item \cmd{serendipity\_plugin\_api} für generelle API-Aufrufe,

\item \cmd{serendipity\_plugin} als Basis für abgeleitete Plugin-Klassen,

\item \cmd{serendipity\_event} als Basis speziell für abgeleitete Ereignis-Plugins und

\item \cmd{serendipity\_plugin\_api\_extension} für weiterführende API-Aufrufe. 
\item Konfigurationseigenschaften und Meta-Werte von Plugins werden über die Klasse
\cmd{serendipity\_property\_bag} abgedeckt. 

\end{osplist}
Alle Klassen sind in \cmd{include/plugin\_api.inc.php} und
\cmd{include/plugin""\_api\_extension.inc.php} deklariert. Die Funktionsparameter
sind in dieser Datei ausführlich mittels \cmd{phpDoc}-Kommentaren beschrieben.
Schlagen Sie die Parameter-Dokumentation bitte in dieser Datei nach.

\index{Plugin-API!serendipity\_plugin\_api}%
\subsubsection{Klasse serendipity\_plugin\_api}

Die Kern-Aufrufe der Plugin-API können über PHP meist statisch aufgerufen
werden, d.\,h.\ mittels \cmd{serendipity\_plugin\_api::methodenname()}. Der
Serendipity-PHP-Kern macht hiervon regen Gebrauch, um nicht unnötigerweise eine
Objektinstanz weiterreichen zu müssen.

Nur wenige dieser Methoden sollten in Ihren Plugins angesprochen werden, da die
API größtenteils selbstverwaltend ist. Wichtiger für selbstentwickelte Plugins
sind vielmehr die Objektmethoden der abgeleiteten Klassen
\cmd{serendipity\_plugin} und \cmd{serendipity\_event}.

Folgende Methoden sind verfügbar:

\begin{ospdescription}
\index{Plugin-API!serendipity\_plugin\_api!register\_default\_plugins}%
\ospitem{\cmd{register\_default\_plugins()}}
Wird bei der Installation des Blogs aufgerufen, um eine Liste von
Standard-Plugins einzufügen.

Zusätzliche Plugins können über die Datei \cmd{plugins/preload.txt} gesteuert
werden. Diese Datei kann ein Plugin pro Zeile (getrennt durch Zeilenumbruch)
festlegen und getrennt durch einen Doppelpunkt angeben, auf welcher Seite
(\cmd{left}, \cmd{right}, \cmd{event}) das Plugin installiert werden soll:

\begin{ospcode}
serendipity\_event\_nl2br:event
serendipity\_plugin\_history:left
\ldots
\end{ospcode}

\index{Plugin-API!serendipity\_plugin\_api!create\_plugin\_instance}%
\ospitem{\cmd{create\_plugin\_instance()}}
Aktiviert ein Serendipity-Plugin. Die Parameter der Methode bestimmen den
PHP-Klassennamen sowie die Positionierung des Plugins. Wenn diese Methode eine
Plugin-Datei nicht finden/einbinden kann, liefert sie eine Fehlermeldung wie:

\cmd{Fehler: serendipity\_event\_nl2br:dsfsdf323424334 ()}

Dabei gibt die API die eindeutige ID des nicht ladbaren Plugins sowie den
Pfad zu der Plugin-Datei aus. Falls keine Pfadangabe vorhanden ist, liegt das Plugin
in einem gleichnamigen Verzeichnis der \cmd{plugins}-Struktur.

\index{Plugin-API!serendipity\_plugin\_api!remove\_plugin\_instance}%
\ospitem{\cmd{remove\_plugin\_instance()}}
Entfernt ein aktiviertes Plugin. Die Plugin-Dateien werden jedoch beibehalten, so
dass das Plugin jederzeit erneut aktiviert werden kann.

\index{Plugin-API!serendipity\_plugin\_api!remove\_plugin\_value}%
\ospitem{\cmd{remove\_plugin\_value()}}
Löscht alle Konfigurationswerte eines gewünschten Plugins.

\index{Plugin-API!serendipity\_plugin\_api!enum\_plugin\_classes}%
\ospitem{\cmd{enum\_plugin\_classes()}}
Durchsucht die gesamte Serendipity-Verzeichnisstruktur nach aktivierbaren
Plugins. 

\index{Plugin-API!serendipity\_plugin\_api!traverse\_plugin\_dir}%
\ospitem{\cmd{traverse\_plugin\_dir()}}
Durchsucht ein spezielles Verzeichnis rekursiv nach vorhandenen
Se\-ren\-dipity-Plugins. 

\index{Plugin-API!serendipity\_plugin\_api!getinstalledplugins@get\_installed\_plugins}%
\index{Plugin-API!serendipity\_plugin\_api!enum\_plugins}%
\ospitem{\cmd{get\_installed\_plugins(), enum\_plugins()}}
Liefert eine Liste von installierten Plugins.

\index{Plugin-API!serendipity\_plugin\_api!count\_plugins}%
\ospitem{\cmd{count\_plugins()}}
Liefert die Anzahl von installierten Plugins. 

\index{Plugin-API!serendipity\_plugin\_api!getClassByInstanceID}%
\ospitem{\cmd{getClassByInstanceID()}}
Liefert den PHP-Klassennamen eines Plugins anhand seiner ID.

\index{Plugin-API!serendipity\_plugin\_api!is\_event\_plugin}%
\ospitem{\cmd{is\_event\_plugin()}}
Prüft, ob ein bestimmtes Plugin ein Ereignis-Plugin darstellt.

\index{Plugin-API!serendipity\_plugin\_api!exists}%
\ospitem{\cmd{exists()}}
Prüft, ob bereits ein Plugin desselben Typs installiert ist.

\index{Plugin-API!serendipity\_plugin\_api!autodetect\_instance}%
\ospitem{\cmd{autodetect\_instance()}}
Prüft, ob bereits ein Plugin desselben Typs installiert ist. Wenn nicht, wird
das entsprechende Plugin automatisch aktiviert.

\index{Plugin-API!serendipity\_plugin\_api!load\_plugin}%
\ospitem{\cmd{load\_plugin()}}
Erzeugt ein PHP-Objekt einer gewünschten Plugin-Klasse. Ruft alle notwendigen
Hilfsfunktionen auf, um die Plugin-Pfade und Metadaten zu belegen.

\index{Plugin-API!serendipity\_plugin\_api!includePlugin}%
\ospitem{\cmd{includePlugin()}}
Hilfsfunktion, um die PHP-Klassendefinition eines Plugins einzubinden.

\index{Plugin-API!serendipity\_plugin\_api!probePlugin}%
\ospitem{\cmd{probePlugin()}}
Hilfsfunktion, um die Metadaten eines Plugins einzulesen und gegebenfalls die
notwendigen PHP-Dateien des Plugins einzubinden.

\index{Plugin-API!serendipity\_plugin\_api!getPluginInfo}%
\ospitem{\cmd{getPluginInfo()}}
Liest die in der Datenbank zwischengespeicherten Meta"=Informationen zu einem
Plugin ein.

\index{Plugin-API!serendipity\_plugin\_api!setPluginInfo}%
\ospitem{\cmd{setPluginInfo()}}
Speichert Meta-Informationen zu einem Plugin in der Datenbank.

\index{Plugin-API!serendipity\_plugin\_api!update\_plugin\_placement}%
\ospitem{\cmd{update\_plugin\_placement()}}
Aktualisiert die Position und Ausführungsreihenfolge (links, rechts \ldots)
eines Plugins.

\index{Plugin-API!serendipity\_plugin\_api!update\_plugin\_owner}%
\ospitem{\cmd{update\_plugin\_owner()}}
Aktualisiert den Eigentümer (Blog-Redakteur) eines Plugins.

\index{Plugin-API!serendipity\_plugin\_api!geteventplugins@get\_event\_plugins}%
\ospitem{\cmd{get\_event\_plugins()}}
Hilfsfunktion, um die Liste aller aktivierten Ereignis-Plugins einzulesen und
gegebenenfalls in den Speicher zu laden.

\index{Plugin-API!serendipity\_plugin\_api!generate\_plugins}%
\ospitem{\cmd{generate\_plugins()}}
Führt alle Plugins einer gewünschten Seitenleiste aus und liefert deren Inhalte
zurück. Wird von der Smarty-Template-API aufgerufen (siehe Seite
\pageref{Smarty-Templates}).

\index{Plugin-API!serendipity\_plugin\_api!getplugintitle@get\_plugin\_title}%
\ospitem{\cmd{get\_plugin\_title()}}
Liest den Titel eines Plugins aus.

\index{Plugin-API!serendipity\_plugin\_api!hook\_event}%
\ospitem{\cmd{hook\_event()}}
Die \cmd{hook\_event()}-Methode wird aufgerufen, um ausgehend vom
Abarbeitungsprozess des Serendipity-Frameworks ein Ereignis einzubinden. Diese
Methode geht die Liste aller aktivierten Ereignis-Plugins durch und prüft,
welche Plugins für das gerade aufgerufene Ereignis ausgeführt werden sollen.
Die Methode leitet auch die benötigten Parameter und Variablen an das
jeweilige Plugin weiter.

\end{ospdescription}

\index{Plugin-API!serendipity\_property\_bag}%
\subsubsection{Klasse serendipity\_property\_bag}

Ein \cmd{serendipity\_property\_bag} dient als Kapselung für beliebige Variablen
einer Serendipity-Plugin-Klasse. Dieser Container kann von der Plugin-API leicht
ausgelesen und weitergereicht werden.

Vor allem dient dieser Container der Übergabe an die Plugin-Methode
\cmd{in\-tro\-spect()}, wo er mit individuellen Informationen eines Plugins gefüllt
werden kann. Dieser Vorgang findet jedesmal beim Instanzieren eines Plugins statt.

Intern speichert dieses Objekt seine Werte in einem Klassenarray 
\cmd{\$this->""properties} ab. Die folgenden Methoden kapseln den Zugriff auf
dieses private Array:

\begin{ospdescription}
\index{Plugin-API!serendipity\_property\_bag!add}%
\ospitem{\cmd{add()}}
Fügt eine neue Eigenschaft (Schlüssel und Wert) hinzu.

\index{Plugin-API!serendipity\_property\_bag!get}%
\ospitem{\cmd{get()}}
Liest den Wert einer Eigenschaft aus.

\index{Plugin-API!serendipity\_property\_bag!is\_set}%
\ospitem{\cmd{is\_set()}}
Prüft, ob eine bestimmte Eigenschaft gesetzt ist.

\end{ospdescription}

\index{Plugin-API!serendipity\_plugin\_api\_extension}%
\subsubsection{Klasse serendipity\_plugin\_api\_extension}

Diese Plugin-API-Erweiterungsklasse dient dazu, weitere (seltener benötigte)
Hilfsmethoden zu definieren.

\begin{ospdescription}
\index{Plugin-API!serendipity\_plugin\_api\_extension!prepareReorder}%
\ospitem{\cmd{prepareReorder()}}
Operiert auf einem übermittelten Array und überführt es in eine
eindimensionale Struktur, die entsprechend des Arrays sortiert wird. Dies dient
z.\,B.\ als Hilfsmethode für die Sortierung einer Reihenfolge von Plugins,
statischer Seiten oder anderem.

\index{Plugin-API!serendipity\_plugin\_api\_extension!doReorder}%
\ospitem{\cmd{doReorder()}}
Liefert den notwendigen SQL-Code zum Umsortieren von Datenbankeinträgen anhand
des Arrays, das mithilfe der Methode \cmd{prepareRe\-or\-der} erzeugt wurde.

\index{Plugin-API!serendipity\_plugin\_api\_extension!prepareDelete}%
\ospitem{\cmd{prepareDelete()}}
Durchwandert ein Array und prüft, ob bestimmte Werte darin aufgrund einer
Eltern/Kind-Beziehung gelöscht werden sollen.

\index{Plugin-API!serendipity\_plugin\_api\_extension!isEmail}%
\ospitem{\cmd{isEmail()}}
Prüft, ob ein übermittelter Wert eine gültige E-Mail-Adresse nach RFC-Norm 
darstellt.
\end{ospdescription}

\index{Plugin-API!serendipity\_plugin}%
\subsubsection{Klasse serendipity\_plugin}

Die Klasse \cmd{serendipity\_plugin} dient als Basis sowohl für Ereignis- als
auch Seitenleisten-Plugins. Viele der hier aufgeführten Methoden entsprechen 
lediglich einer \emph{Rohform}, bei objektorientierten Entwurfsmustern\osplinebreak{} spricht
man hier von der \emph{Template-Methode}. 

Es obliegt dem jeweiligen Plugin, die Inhalte für diese Methoden zu gestalten.
Die API selbst greift später nur auf die vom Plugin ausgestalteten Methoden
standardisiert zu.

Jedes Plugin verfügt über folgende Klassenvariablen, die automatisch beim Laden
eines Plugins belegt werden:

\begin{ospdescription}
\index{Plugin-API!serendipity\_plugin!instance@\$instance}%
\ospitem{\cmd{\$instance}}
Enthält die aktuelle ID des Plugins.

\index{Plugin-API!serendipity\_plugin!protected@\$protected}%
\ospitem{\cmd{\$protected}}
Gibt an, ob ein Plugin nur durch dessen Eigentümer konfiguriert werden darf.

\index{Plugin-API!serendipity\_plugin!title@\$title}%
\ospitem{\cmd{\$title}}
Enthält den Titel eines Plugins.

\index{Plugin-API!serendipity\_plugin!pluginPath@\$pluginPath}%
\ospitem{\cmd{\$pluginPath}}
Enthält den Verzeichnispfad zu der Plugin-Datei.

\index{Plugin-API!serendipity\_plugin!pluginFile@\$pluginFile}%
\ospitem{\cmd{\$pluginFile}}
Enthält den vollständigen Pfad zu einem Plugin.

\index{Plugin-API!serendipity\_plugin!serendipityowner@\$serendipity\_owner}%
\ospitem{\cmd{\$serendipity\_owner}}
Enthält die ID des Redakteurs, der das Plugin installiert hat.

\index{Plugin-API!serendipity\_plugin!dependencies@\$dependencies}%
\ospitem{\cmd{\$dependencies}}
Kann ein Array mit Plugin-Namen enthalten, von denen ein Plugin abhängig ist.
Die Klassenvariable kann innerhalb der \cmd{introspect()}-Methode gesetzt
werden: 

\begin{ospcode}
function introspect(\&\$propbag) \{
 \ldots
 \$this->dependencies = array('serendipity\_event\_creativecommons' =>
 'remove'); \ldots
\}
\end{ospcode}

Der Schlüssel des Arrays enthält dabei den Klassennamen der Abhängigkeit,
während der Wert des Arrays entweder \cmd{remove} (das zugehörige Plugin wird
entfernt, wenn das abhängige Plugin gelöscht wird) oder \cmd{keep} (das
zugehörige Plugin bleibt auch nach Deinstallation des abhängigen Plugins
aktiviert) enthält.

\end{ospdescription}

Folgende Methoden werden von der API mit sinnvollem Inhalt vorbelegt und können
eingesetzt werden:

\begin{ospdescription}
\index{Plugin-API!serendipity\_plugin!serendipityplugin@serendipity\_plugin}%
\ospitem{Konstruktor \cmd{serendipity\_plugin()}}
Konstruktor eines Plugins, sorgt dafür, dass die erforderlichen Klassenvariablen
korrekt belegt werden.
 
\index{Plugin-API!serendipity\_plugin!validate}%
\ospitem{\cmd{validate()}}
Prüft einen Plugin-Konfigurationswert auf Gültigkeit. Dabei werden die mittels
\cmd{introspect\_config\_item()}-Methode festgelegten Prüfklassen
(\emph{Property Bag}-Eigenschaft \cmd{validate}) eingesetzt.

\index{Plugin-API!serendipity\_plugin!get\_config}%
\ospitem{\cmd{get\_config()}}
Liefert den Wert einer Konfigurationsoption des Plugins zurück.

\index{Plugin-API!serendipity\_plugin!set\_config}%
\ospitem{\cmd{set\_config()}}
Setzt einen Konfigurationswert des Plugins.

\index{Plugin-API!serendipity\_plugin!register\_dependencies}%
\ospitem{\cmd{register\_dependencies()}}
Installiert die abhängigen Plugins, die im Array \cmd{\$this->dependen\-cies}
aufgeführt wurden.

\index{Plugin-API!serendipity\_plugin!parseTemplate}%
\ospitem{\cmd{parseTemplate()}}
Kann von Plugins eingesetzt werden, um Smarty-\cmd{.tpl}-Dateien zu parsen. Der
in dieser Methode enthaltene Code befindet sich bereits in vielen Plugins an
Stellen innerhalb des normalen Codeflusses. Um diese für zukünftige Plugins zu
vereinheitlichen, wurde die zentrale Methode eingeführt. Sie sorgt automatisch
dafür, dass Template-Dateien auch im lokalen, vorrangigen Template-Verzeichnis eines\osplinebreak{} Blogs
anstelle des Plugin-Verzeichnisses liegen können.
\end{ospdescription}

Folgende Methoden müssen von jeweiligen Plugin ausgestaltet werden:

\begin{ospdescription}
\index{Plugin-API!serendipity\_plugin!install}%
\ospitem{\cmd{install()}}
Wird aufgerufen, wenn ein Plugin installiert wurde. Hier kann ein Plugin z.\,B.\
notwendige Datenbanktabellen erstellen.

\index{Plugin-API!serendipity\_plugin!uninstall}%
\ospitem{\cmd{uninstall()}}
Wird beim Deinstallieren eines Plugins aufgerufen, um z.\,B.\ angelegte
Datenbanktabellen zu löschen.

\index{Plugin-API!serendipity\_plugin!performConfig}%
\ospitem{\cmd{performConfig()}}
Wird immer dann aufgerufen, wenn ein Plugin durch einen Redakteur konfiguriert wird.
Diese Methode kann vor allem dann hilfreich sein, wenn ein Plugin Operationen
durchführen soll, die nur während der Konfigurationsphase wichtig sind und
nicht bei jeder Ausführung des Plugins. 

\index{Plugin-API!serendipity\_plugin!example}%
\ospitem{\cmd{example()}}
Wird ebenfalls aufgerufen, wenn die Konfigurationsoberfläche eines Plugins
angezeigt wird. Über diese Methode kann ein Plugin einen erweiterten
Hilfe/Info-Text anzeigen, der die Bedienung des Plugins erklärt.

\index{Plugin-API!serendipity\_plugin!cleanup}%
\ospitem{\cmd{cleanup()}}
Wird jedesmal dann aufgerufen, wenn ein Redakteur Änderungen an der
Konfiguration des Plugins durchgeführt hat. Kann benutzt werden, um leere oder
ungültige Konfigurationswerte zu verändern.

\index{Plugin-API!serendipity\_plugin!introspect}%
\ospitem{\cmd{introspect()}}
Diese zentrale Methode legt die Meta-Eigenschaften eines Plugins anhand eines
\cmd{serendipity\_property\_bag}-Objekts fest. Folgende Schlüssel für dieses
Objekt sind dabei geläufig:

\begin{ospdescription}
\ospitem{\cmd{name}} enthält den Namen des Plugins.
\ospitem{\cmd{description}} enthält die Beschreibung eines Plugins.
\ospitem{\cmd{configuration}} enthält ein eindimensionales Array mit einer Liste von
Konfigurationsoptionen, die das Plugin anbietet.
\ospitem{\cmd{stackable}} legt fest, ob ein Plugin mehrfach installiert werden darf (\cmd{true/""false}).
\ospitem{\cmd{author}} enthält den Namen des Autors eines Plugins.
\ospitem{\cmd{version}} enthält die Versionsnummer des Plugins.
\ospitem{\cmd{copyright}} enthält den Lizenztypen des Plugins (BSD, GPL \ldots).
\ospitem{\cmd{groups}} enthält ein eindimensionales Array mit einer Liste von
Plugin-Gruppen, denen dieses Plugin zugewiesen wird. Diese Gruppen werden in der
Plugin-Oberfläche ausgewertet, um Plugins sinnvoll zu gliedern.
\ospitem{\cmd{requirements}} kann ein verschachteltes PHP-Array enthalten
(Unterschlüssel \cmd{serendipity}, \cmd{smarty} und \cmd{php}), das die
jeweiligen Versionsabhängigkeiten des Plugins festlegen kann.
\ospitem{\cmd{event\_hooks}} enthält ein eindimensionales Array mit einer Zuordnung
der Ereignisse, für die sich ein Ereignis-Plugin registriert hat. Diese
Eigenschaft gilt nicht für Seitenleisten-Plugins.
\ospitem{\cmd{cachable\_events}} enthält ein Array analog zu \cmd{event\_hooks},
jedoch in diesem Fall mit einer Liste von Ereignissen, die durch das vorliegende
Plugin gecached werden können (siehe Seite \pageref{cachable-events}).
\end{ospdescription}

\index{Plugin-API!serendipity\_plugin!generate\_content}%
\ospitem{\cmd{generate\_content()}}
Zentrale Methode eines Seitenleisten-Plugins, um Inhalte in der Seitenleiste
darzustellen.

\index{Plugin-API!serendipity\_plugin!introspect\_config\_item}%
\ospitem{\cmd{introspect\_config\_item()}}
Bei der Konfiguration eines Plugins wird über \cmd{introspect()} im
Pro\-perty-Bag-Attribut \cmd{configuration} festgelegt, über welche
Konfigurationsoptionen ein Plugin verfügt.

Die Methode \cmd{introspect\_config\_item()} wird von der Plugin-API für jedes
dieser Elemente aufgerufen und muss daraufhin festlegen, wie die jeweilige
Konfigurationsoption ausgegeben wird. Dazu empfiehlt sich, in der Methode eine
große \cmd{switch}-Anweisung zu hinterlegen:

\begin{ospcode}
function introspect\_config\_item(\$name, \&\$propbag) \{
    switch (\$name) \{
    case 'id':
        \$propbag->add('type', 'string');
        \$propbag->add('name', 'Affiliate ID');
        \$propbag->add('description', '');
        \$propbag->add('default', '47110815');
        break;

    case 'tax':
        \$propbag->add('type', 'string');
        \$propbag->add('name', 'Steuern');
        \$propbag->add('description', '(in Prozent)');
        \$propbag->add('default', '19');
        break;
    \}
\}
\end{ospcode}
Erneut wird ein \emph{Property Bag}-Objekt mit den Eigenschaften
jedes Konfigurationswerts gefüllt. Dort gelten folgende Array"=Schlüssel:

\begin{ospdescription}
\ospitem{\cmd{type}} legt den Typ einer Konfigurationsoption fest (\cmd{string},
\cmd{boolean}, \cmd{text} \ldots). Die verfügbaren Typen entsprechen denen 
bei der Festlegung von Template-Optionsfeldern und sind auf Seite
\pageref{apiconfigfield2} aufgeführt.
\ospitem{\cmd{name}} legt den dargestellten Namen des Konfigurationsfelds fest.
\ospitem{\cmd{description}} legt die Beschreibung des Konfigurationsfelds fest. 
\ospitem{\cmd{default}} legt den Standardwert eines Konfigurationsfelds fest.
\ospitem{\cmd{validate}} legt fest, wie ein Konfigurationsfeld geprüft werden kann.
Mögliche Werte sind \cmd{string} (nur Buchstaben und Ziffern), \cmd{words} (nur
Zeichenketten ohne Sonderzeichen), \cmd{number} (nur Zahlen), \cmd{url} (nur
URLs), \cmd{mail} (nur E-Mail-Adressen) oder \cmd{path} (nur gültige
Verzeichnisnamen). Wenn keiner dieser festgelegten Typen verwendet
wird, können Sie einen beliebigen regulären Ausdruck eintragen, z.\,B.\
\cmd{/[A-Z]/}. Die \emph{Property Bag}-Eigenschaft \cmd{validate\_error} enthält
eine Fehlermeldung, die bei ungültigen Eingaben angezeigt werden kann.
\end{ospdescription}

Die Werte der entsprechenden Konfigurationsoption können im Plugin mittels
\cmd{\$this->get\_config('konfigwert')} ausgelesen werden.
\end{ospdescription}

\index{Plugin-API!serendipity\_event}%
\subsubsection{Klasse serendipity\_event}

Ereignis-Plugins leiten sich von der Klasse \cmd{serendipity\_event} ab und
erben dadurch sämtliche aufgeführten Klassenvariablen und Methoden der Klasse
\cmd{serendipity\_plugin}. Hinzu kommen lediglich folgende Methoden:

\begin{ospdescription}
\index{Plugin-API!serendipity\_event!serendipity\_event}%
\ospitem{Konstruktor \cmd{serendipity\_event()}}
Setzt analog zum Konstruktor \cmd{serendipity\_plugin} die benötigten
Klassenvariablen. 

\ospitem{\cmd{getFieldReference()}}
Hilfsmethode, um bei gecachten Plugins auf ein spezielles Feld (\cmd{body} oder
\cmd{extended}) zuzugreifen und es zu verändern. Würde das Plugin direkt
\cmd{\$eventData['body']} modifizieren, könnte dies in Interaktion mit dem
Caching-Plugin zu Problemen führen.

\ospitem{\cmd{event\_hook()}}
Zentrale \emph{Dispatcher}-Methode, damit die jeweils registrierten Ereignisse
durch das Plugin abgefragt und ausgeführt werden können.

\end{ospdescription}

\subsection{Cachable Events}
\index{Cache!Plugin-API}%
\label{cachable-events}
Ein Ereignis-Plugin kann in seiner \cmd{introspect}-Methode eine Liste von
Ereignissen in der Eigenschaft \cmd{event\_hooks} des \cmd{\$propbag}-Objekts
registrieren. Diese Liste legt fest, bei welchen Ereignissen das Plugin
aufgerufen wird.

Dieser Vorgang wird etwas komplexer, wenn die Caching"=Konfigurationsoption des
Plugins \emph{Erweiterte Eigenschaften von Artikeln} (siehe Seite
\pageref{entryproperties}) aktiviert ist.

Das Caching ist ausschließlich für Textformatierungs-Plugins (siehe Seite
\pageref{Textformatierungs-Plugins}) gedacht. Normalerweise ruft Serendipity 
diese für jeden einzelnen Artikel wieder und wieder auf. Bei vielen 
Textformatierungen macht das performancemäßig jedoch
wenig Sinn: Aus einer BBCode-Textformatierung wie \cmd{[b]fett[/b]} wird stets
ein \cmd{<strong>fett</strong>} entstehen; dies müsste Serendipity also
eigentlich nur einmal \emph{parsen} und könnte dann für spätere Aufrufe immer 
nur das vorige Ergebnis (den \emph{Cache}) einlesen und verwenden.

Sobald viele Textformatierungs-Plugins zum Einsatz kommen, kann sich dieses
Caching durchaus als performanceschonend auswirken. Vor dem Speichern eines
Blog-Artikels führt der Serendipity-Kern das Ereignis \cmd{back\-end\_save} aus.
Das Caching-Plugin \cmd{serendipity\_event\_entryproper\-ties} lauscht auf dieses
Ereignis. Aufgrund aktivierter Caching-Option führt dieses Plugin nun wiederum
das Ereignis \cmd{frontend\_display\_cache} aus. Alle Textformatierungs"=Plugins,
die das Caching unterstützen (das sind die meisten), lauschen auf dieses
Ereignis und wenden nun ihre reproduzierbaren Textformatierungen auf den
Artikeltext an. Das Ergebnis entspricht nach diesem Vorgang der
HTML-Formatierung, wie sie später im Blog dargestellt wird.

Diee Formatierung wird nun nicht einfach im Artikeltext gespeichert, denn dies
würde dazu führen, dass beim nächsten Bearbeiten des Artikels der Redakteur nicht
mehr sein vorher eingegebenes \cmd{[b]fett[/b]} sähe, sondern den entsprechenden
HTML-Code. Damit also die Redakteurseingaben immer konsistent bleiben können,
wird das erzeugte Cache-Ergebnis separat in der Datenbanktabelle
\cmd{serendipity\_entryproperties} gespeichert. Die beiden Werte
\cmd{ep\_cache\_body} und \cmd{ep\_cache\_extended} enthalten die nach Aufruf
aller Textformatierungs-Plugins erzeugte HTML-Formatierung des Artikeltexts
und des erweiterten Artikels.

Nachdem der einzusetzende Cache gespeichert wurde, prüft die Serendipity"=Funktion
\cmd{serendipity\_printEntries} bei der Darstellung der Artikel, ob ein Wert für
die Eigenschaften \cmd{ep\_cache\_body} und \cmd{ep\_cache\_exten\-ded} vorliegt.
Ist das der Fall, tauscht die Funktion einfach den \emph{echten} Inhalt des
Artikels mit der gecachten Version aus. Wenn nun später das Ereignis
\cmd{frontend\_display} ausgeführt wird, enthalten die Zusatzarrays
\cmd{\$addData""['no\_scramble']} und \cmd{\$eventData['is\_cached']} den Wert
\cmd{true}. Alle cachbaren Textformatierungs-Plugins erkennen diesen Wert und
wissen, dass sie keine erneute Formatierung anwenden müssen, da dies in der
gecachten Version bereits beim Speichern des Artikels erledigt wurde.

Jedes Plugin, das sich mittels des \cmd{\$propbag}-Objekts (Eigenschaft
\cmd{event\_""hooks}) für das Ereignis \cmd{frontend\_display} registriert hat und
cachbar sein soll, muss dieses Ereignis auch in der Eigenschaft
\cmd{cachable\_events} festlegen. Wurde dies gesetzt, kümmert sich die Plugin-API
beim Aufruf des Textformatierungsereignisses \cmd{frontend\_display} automatisch
darum, dass es im Falle eines gecachten Artikels \emph{nicht} mehr erneut
ausgeführt wird. Der Aufruf des Ereignisses wird somit komplett verhindert.

Zusätzlich kann das Caching-Plugin auch einmalig alle alten Artikel auf Anfrage
cachen, dies wird über das Ereignis \cmd{backend\_cache\_entries} ausgeführt. Das
Ereignis \cmd{backend\_cache\_purge} löscht darüber hinaus einen Cache. Viele
Textformatierungs-Plugins machen von diesen Ereignissen innerhalb der
\cmd{install()}- und \cmd{uninstall()}-Methode Gebrauch, so dass bei der
Installation eines neuen Textformatierungs-Plugins automatisch der bestehende
Cache neu erstellt wird und die neu hinzugekommenen Formatierungen beinhaltet.

Wenn Sie ein Textformatierungs-Plugin entwickeln wollen, das diese Möglichkeiten
des Cachings anwendet, suchen Sie einfach im Quellcode der Plugins nach der
Zeichenkette \cmd{cachable\_events}. Mithilfe dieser Beispiele können Sie den
oben beschriebenen Mechanismus leichter nachvollziehen.

\label{Ereignisse}%
\index{Ereignis-Hooks}
\index{Plugin-API!Events}%
\index{Plugin-API!Hooks}%
\subsection{Ereignis-Hooks}

In vielen Dateien von Serendipity werden Ereignisse mittels der Plugin-API
ausgeführt. Diese Aufrufe sehen dabei wie folgt aus:

\begin{ospcode}
serendipity\_plugin\_api::hook\_event('frontend\_generate\_plugins',
\$eventData, \$addData);
\end{ospcode}

Die zentrale Methode \cmd{hook\_event()} der Plugin-API geht dabei die Liste
aller aktivierten Ereignis-Plugins durch. Dabei wird die Ausführungsreihenfolge
durch die Reihenfolge der Plugins bestimmt. Jedem einzelnen Plugin werden die
beiden Variablen \cmd{\$eventData} und \cmd{\$addData} weitergereicht, falls
sich das Plugin für das definierte Ereignis (hier:
\cmd{frontend\_generate\_""plugins}) registriert hat. Bei jedem Ereignis wird  \cmd{event\_hook()} des jeweiligen Plugins ausgeführt, an die die
Variablen weitergereicht werden, wo sie verarbeitet werden können. Die Variable
\cmd{\$eventData} wird dabei als referenzierte Variable weitergegeben und kann
vom Plugin verändert werden. \cmd{\$addData} hingegen dient nur dem Lesezugriff.
Beide Variablen können auch beliebig verschachtelte Arrays enthalten.

Falls ein Plugin die Inhalte der Variablen \cmd{\$eventData} verändert, können
diese auch durch später folgende Plugins noch weiter abgeändert werden.

Ereignisse lassen sich bei Serendipity leicht und flexibel erweitern. Dazu
genügt es, im PHP-Code von Serendipity eine Zeile wie oben mit einem frei
erfundenen Ereignisnamen einzubinden und ein entsprechendes Plugin zu
entwickeln, das dieses Ereignis registriert. Zusätzlich können beliebige
Ereignis-Hooks auch mittels Smarty-Funktion \cmd{serendipity\_hookPlugin}
aufgerufen werden (siehe Seite \pageref{serendipity-hookPlugin}).

Um das konkrete Umfeld sowie die Parametrisierung eines 
\cmd{hook\_event()}-Aufrufs zu prüfen und für ein eigenes Plugin zu 
nutzen, ist es am einfachsten, im Serendipity-PHP-Code nach dem Auftreten 
dieser Zeile zu suchen. Unter Linux geht dies leicht mit folgendem Befehl:

\begin{ospcode}
find -name \textbackslash*.php \textbackslash
  -exec grep -i -l -d skip \textbackslash
  "serendipity_plugin_api::hook_event('" \textbackslash
  \{\} \textbackslash;
\end{ospcode}

Es folgt eine Liste von bisher vorhandenen Serendipity-Ereignissen, auf die
auch selbstgeschriebene Plugins zugreifen können:

\index{Plugin-API!Ereignisse!Frontend}%
\subsubsection{Frontend-Ereignisse}
\begin{ospdescription}
\ospitem{\picmd{css}} für die Darstellung des CSS Stylesheets. \cmd{eventData} (Array):
CSS-Daten des Template-Stylesheets, kann durch Plugins verändert/erweitert werden.

\ospitem{\picmd{frontend\_configure}} wird aufgerufen, nachdem das
Serendipity-Framework instanziert\osplinebreak{} wurde. Plugins können an dieser Stelle zentrale
Eigenschaften/Werte von Serendipity verändern oder prüfen. \cmd{eventData}:
Serendipity"=Konfigurationswerte.

\ospitem{\picmd{entry\_display}} wird aufgerufen, wenn eine Liste von Blog-Artikeln
dargestellt wird. Dieses Ereignis wird einmalig ausgeführt. \cmd{eventData}: ein
vollständiges Array mit allen darzustellenden Blog-Artikeln. \cmd{addData}:
zusätzliche Parameter mit Eigenschaften des Aufrufs dieses Ereignisses.

\ospitem{\picmd{entries\_header}} (via Smarty \cmd{entries.tpl}) wird im Template aufgerufen, bevor die
Blog-Artikel dargestellt werden. \cmd{addData}: enthält die ID eines Artikels,
falls eine Einzeldarstellung erfolgt. 

\ospitem{\picmd{entries\_footer}} (via Smarty \cmd{entries.tpl}) wird im Template
aufgerufen, nachdem die Blog-Artikel dargestellt wurden.

\ospitem{\picmd{frontend\_header}} (via Smarty \cmd{index.tpl}) wird im Kopfbereich des Templates
aufgerufen.

\ospitem{\picmd{frontend\_footer}} (via Smarty \cmd{index.tpl}) wird im Fußbereich des Templates
aufgerufen.

\ospitem{\picmd{entry\_groupdata}} wird aufgerufen, wenn die Liste der darzustellenden
Artikel nach speziellen Kriterien sortiert werden soll. \cmd{eventData}:
vollständiges Array der zu sortierenden Blog-Artikel.

\ospitem{\picmd{comments\_by\_author\_footer}} (via Smarty \cmd{comments\_by\_authors.tpl})
wird im Template innerhalb der Fußzeile aufgerufen, nachdem die
Kommentaransicht nach Autoren dargestellt wurde.

\ospitem{\picmd{frontend\_fetchentries}} wird aufgerufen, wenn Serendipity eine
Datenbankabfrage ausführt, um mehrere Blog-Artikel einzulesen. Über dieses
Ereignis kann die SQL-Abfrage beeinflusst werden.
\cmd{eventData}: Array mit Teilen der
SQL-Abfrage (\cmd{WHERE}-Bedingungen, \cmd{JOINS} etc.) \cmd{addData}:
Array mit zusätzlichen Parametern beim Aufruf dieses Ereignisses. 

\ospitem{\picmd{frontend\_fetchentry}} wird aufgerufen, wenn Serendipity eine
Datenbankabfrage ausführt, um einen einzelnen Blog-Artikel einzulesen. Über
das Ereignis kann die SQL-Abfrage beeinflusst werden.
\cmd{eventData}: Array mit Teilen der
SQL-Abfrage (\cmd{WHERE}-Bedingungen, \cmd{JOINS} etc.) \cmd{addData}:
Array mit zusätzlichen Parametern beim Aufruf dieses Ereignisses.

\ospitem{\picmd{frontend\_entryproperties}} wird aufgerufen, wenn zusätzliche
Eigenschaften zu den ausgelesenen Blog-Artikeln aus weiteren Datenquellen
eingefügt werden sollen.
\cmd{eventData}: verschachteltes Array mit den Daten der Blog-Artikel.
\cmd{addData}: Array mit allen IDs der in \cmd{addData} enthaltenen Blog-Artikel.

\ospitem{\picmd{frontend\_entryproperties\_query}} wird aufgerufen, wenn Serendipity die
Datenbanktabelle \cmd{serendipi\-ty\_entryproperties} ausliest, über die freie
Eigenschaften zu Blog-Artikeln zugewiesen werden können. Über dieses
Ereignis können innerhalb einer SQL-Abfrage mehrere Tabellen einbezogen
werden.
\cmd{eventData}: enthält ein Array mit Teilen der SQL-Abfrage, über
die erweiterte Eigenschaften der Artikel eingelesen werden können, die später in
das zentrale Blog-Artikel-Array übernommen werden können. 

\ospitem{\picmd{fetchcomments}} wird aufgerufen, wenn Kommentare zu einem Blog-Artikel
ausgelesen werden. \cmd{eventData}: Array mit eingelesenen Kommentardaten.

\ospitem{\picmd{frontend\_display}} wird aufgerufen, wenn der Text eines Blog-Artikels
oder Kommentars formatiert bzw. dargestellt werden soll. Textformatierungs-Plugins\osplinebreak{}
nutzen vor allem dieses Ereignis. \cmd{eventData}: Daten eines einzelnen Artikels
bzw. Kommentars. \cmd{addData}: Array mit zusätzlichen Parametern beim Aufruf
dieses Ereignisses.

\ospitem{\picmd{frontend\_display\_cache}} wird aufgerufen, wenn ein Blog-Artikel in der
Datenbank gespeichert wird. Ereignis-Plugins, die Caching (siehe Seite
\pageref{cachable-events}) unterstützen, führen ihre Textformatierungen bei
diesem Ereignis aus. \cmd{eventData}: dieselben Daten wie vom Ereignis
\cmd{backend\_publish/backend\_save} (Artikeldaten). \cmd{addData}: Array mit
zusätzlichen Parametern beim Aufruf dieses Ereignisses.

\ospitem{\picmd{frontend\_comment}} (via Smarty \cmd{commentform.tpl}) wird aufgerufen, wenn
das Eingabeformular für Kommentare im Frontend dargestellt wird.

\index{Plugin-API!Events!frontend\_display:*} 
\ospitem{\cmd{frontend\_display:opml-1.0:namespace,}}
\ospadditem{\cmd{frontend\_display:rss-0.91:namespace,}}
\ospadditem{\cmd{frontend\_display:rss-1.0:namespace,}}
\ospadditem{\cmd{frontend\_display:rss-2.0:namespace,}}
\ospadditem{\cmd{frontend\_display:atom-1.0:namespace,}}
\ospadditem{\cmd{frontend\_display:atom-0.3:namespace}} wird bei der Darstellung von RSS-Feeds
innerhalb des Namespace-XML-Bereichs aufgerufen. \cmd{eventData}: Array mit
allen Artikeln des Feeds.


\ospitem{\picmd{frontend\_display:html:per\_entry}} wird vor Darstellung eines Artikels im Frontend aufgerufen. \cmd{event\-Data}: Array mit Blog-Artikeln.

\ospitem{\picmd{frontend\_display:opml-1.0:per\_entry,}}
\ospadditem{\picmd{frontend\_display:rss-0.91:per\_entry,}}
\ospadditem{\picmd{frontend\_display:rss-1.0:per\_entry,}}
\ospadditem{\picmd{frontend\_display:rss-2.0:per\_entry,}}
\ospadditem{\picmd{frontend\_display:atom-1.0:per\_entry,}}
\ospadditem{\picmd{frontend\_display:atom-0.3:per\_entry}} wird bei der Darstellung eines
Blog-Artikels in einem Feed ausgeführt. \cmd{eventData}: Array mit einzelnem
Artikel des Feeds.

\ospitem{\picmd{frontend\_rss}} wird ausgeführt, bevor die Daten eines Feeds an das
Smarty"=Framework weitergereicht werden.

\ospitem{\picmd{frontend\_entries\_rss}} wird vor Darstellung eines Feed ausgeführt. \cmd{eventData}: Array mit allen Artikeln des Feeds. \cmd{addData}: Array
mit weiteren Optionen zur Darstellung des Feeds. Array-Schlüssel \cmd{version}
(Version des Feeds), \cmd{comments} (für Kommentar-Feeds), \cmd{fullFeed}
(für Feeds mit vollständigen Artikeln statt eines Teasers),
\cmd{showMail} (gesetzt, wenn E-Mail-Adresse eingebunden werden soll).

\ospitem{\picmd{frontend\_saveComment}} wird aufgerufen, wenn ein Kommentar zu einem
Artikel gespeichert wird. Die Plugins können 
\cmd{\$eventData['allow\_comments']} auf\osplinebreak{} \cmd{false} setzen, wenn ein Kommentar
nicht gespeichert werden soll, z.\,B.\ aus Gründen des Spamschutzes. 
\cmd{eventData}: Array mit den Daten des Artikels, der kommentiert wird. 
\cmd{addData}: Array mit den Daten des Kommentars, der gespeichert werden soll.

\ospitem{\picmd{frontend\_generate\_plugins}} wird aufgerufen, wenn die
Seitenleisten-Plugins für eine Seite ausgewertet werden. Ereignis-Plugins können so
spezielle Seitenleisten-Plugins ausblenden, wenn gewünscht. \cmd{eventData} enthält
ein Array mit den Plugins einer Seitenleiste, die dargestellt werden sollen.
\cmd{add\-Data} enthält ein Array der Methodenparameter, die beim Aufruf der
Plugin-API-Funktion \cmd{serendipity\_plugin\_api::generate\_plug\-ins()} übergeben
wurden.

\ospitem{\picmd{quicksearch\_plugin}} wird aufgerufen, wenn das Forumular des
\menu{Suche}-Seitenleisten"=Plugins dargestellt wird. Hierüber kann zusätzlicher
HTML- oder Java\-Script-Code ausgegeben werden, um das Suchformular z.\,B.\ mit
Ajax"=Fähigkeiten aufzurüsten.

\ospitem{\picmd{frontend\_image\_selector}} (via Smarty \cmd{media\_*.tpl}) sowie weitere
\cmd{frontend\_image\_\ldots}"=Ereignisse werden von dem Mediendatenbank-Popup
ausgegeben,\osplinebreak{} wenn die Formatierungsoptionen für eine ausgewählte Datei angezeigt
werden. Für jede der Formatierungsmöglichkeiten (Vorschau, Link, Platzierung,
Kommentar \ldots) existiert ein eigenes Ereignis.

\ospitem{\picmd{external\_plugin}} wird aufgerufen, wenn ein Plugin die vollständige
HTML-Ausgabe des Frontends übernehmen kann. Dies geschieht vor allem beim Aufruf
einer URL wie \cmd{http://www.example.com/serendipity/plugin/\osplinebreak{}captcha\_4711}. Alle
über den virtuellen Pfad \cmd{/plugin/} aufgerufenen URLs geben die URL-Parameter
an dieses Ereignis weiter, so dass jedes Plugin überprüfen kann, ob es die
Ausgabe des Frontends übernehmen soll. \cmd{eventData} enthält den Teil der URL,
der nach \cmd{\ldots/plugin/} folgt.

\ospitem{\picmd{genpage}} wird aufgerufen, bevor Serendipity das Smarty-Framework
initiiert. \cmd{eventData} enthält die URL der aktuellen Serendipity-Seite. Über
die globale Variable \cmd{\$serendipity['plugindata']['smartyvars']}\osplinebreak{} kann ein
Plugin weitere beliebige Variablen an das Smarty-Framework weitergeben,
\cmd{addData} enthält ein Array mit Zusatzinfos zur Seite sowie die
Schlüssel \cmd{startpage} (\cmd{true}, wenn Serendipity die erste Seite des Blogs
darstellt), \cmd{uriargs} (zusätzliche URL-Parameter) und \cmd{view} (gibt an,
welche Template-Ansicht angefordert wurde, siehe Seite \pageref{global-view}).

\ospitem{\picmd{frontend\_calendar}} wird aufgerufen, wenn das
Kalender-Seitenleisten-Plugin seine Inhalte darstellt. Über dieses Ereignis können
Ereignis-Plugins interne Termine einbinden. \cmd{eventData}: Array mit externen
Terminen, der Array-Schlüssel muss dem aktuellen Tag des dargestellten Monats
entsprechen, der Array-Wert enthält ein Unterarray mit den Schlüsseln \cmd{Class}
(CSS-Klasse), \cmd{Title} (Titel des Termins) und \cmd{Extended} (weitere
Textinfos zu dem Termin). \cmd{addData} enthält ein Array mit Informationen zum
aktuell dargestellten Kalendermonat mit den Array-Schlüsseln \cmd{Month}
(dargestellter Monat), \cmd{Year} (dargestelltes Jahr), \cmd{TS}
(Unix-Zeitstempel des ersten Tages), \cmd{EndTS} (Unix-Zeitstempel des\osplinebreak{} letzten
Tages).

\ospitem{\picmd{frontend\_xmlrpc}} wird aufgerufen, wenn die XML-RPC API (siehe Seite
\pageref{xmlrpc}) des Blogs initiiert werden soll. \cmd{eventData}: Array, das
mit Metadaten des XML-RPC API-Aufrufs gefüllt werden kann.

\ospitem{\picmd{xmlrpc\_deleteEntry}} wird aufgerufen, wenn mittels XML-RPC API ein
Artikel gelöscht wurde.

\ospitem{\picmd{xmlrpc\_fetchEntry}} wird aufgerufen, wenn mittels XML-RPC API die
Daten eines Artikels eingelesen werden.

\ospitem{\picmd{xmlrpc\_updertEntry}} wird aufgerufen, wenn mittels XML-RPC API ein
Artikel aktualisiert oder gespeichert wird.
\end{ospdescription}

\index{Plugin-API!Ereignisse!Backend: Kommentare}%
\subsubsection{Backend-Ereignisse: Kommentare}
\begin{ospdescription}

\ospitem{\picmd{backend\_comments\_top}} wird in der Kopfzeile der Tabellenansicht von
im Backend vorhandenen Kommentaren aufgerufen. \cmd{eventData}: Array mit den auf
dieser Seite dargestellten Kommentaren.

\ospitem{\picmd{backend\_view\_comment}} wird aufgerufen, wenn Kommentare im Bereich
\menu{Kommentare} des\osplinebreak{} Backends angezeigt werden. \cmd{eventData}: Array mit Daten
des Kommentars. \cmd{addData}: URL-Variablen, die bei der Kommentaransicht die
aktuelle Seite identifizieren.

\ospitem{\picmd{backend\_approvecomment}} wird aufgerufen, wenn ein moderierter
Kommentar von einem Redakteur freigeschaltet wurde. \cmd{eventData} enthält ein
Array mit den Daten des Kommentars.

\ospitem{\picmd{backend\_deletecomment}} wird aufgerufen, wenn ein Kommentar gelöscht
wird. \cmd{eventData} enthält ein Array mit Daten des Kommentars. \cmd{addData}
enthält ein Array mit dem Schlüssel \cmd{cid} (ID des Kommentars) und
\cmd{entry\_id} (ID des kommentierten Blog-Artikels).

\ospitem{\picmd{backend\_updatecomment}} wird aufgerufen, wenn ein Redakteur einen
Kommentar bearbeitet hat. \cmd{eventData} enthält die HTTP POST-Formulardaten
(mit den neuen Daten des Kommentars). \cmd{addData} enthält die ID des zu
ändernden Kommentars.

\end{ospdescription}

\index{Plugin-API!Ereignisse!Backend: Artikel}%
\subsubsection{Backend-Ereignisse: Artikel}
\begin{ospdescription}

\ospitem{\picmd{backend\_delete\_entry}} wird aufgerufen, wenn ein Blog-Artikel
gelöscht wird. \cmd{eventData}: ID des gelöschten Artikels.

\ospitem{\picmd{backend\_preview}} wird aufgerufen, wenn die Artikelvorschau im Backend
angefordert wurde. \cmd{eventData}: enthält das Array mit Daten des Artikels.

\ospitem{\picmd{backend\_publish}} wird aufgerufen, wenn ein Artikel veröffentlicht
(und somit auch gespeichert) wird. \cmd{eventData}: enthält das Array mit Daten
des Artikels. \cmd{addData}: enthält \cmd{true}, wenn der Artikel vorher noch nie
gespeichert wurde.

\ospitem{\picmd{backend\_save}} wird aufgerufen, wenn ein Artikel als Entwurf
gespeichert wird. \cmd{ev\-entData}: enthält das Array mit Daten des Artikels.
\cmd{addData}: enthält \cmd{true}, wenn der Artikel vorher noch nie gespeichert
wurde.

\ospitem{\picmd{backend\_display}} wird aufgerufen, wenn das Formular zum Erstellen und
Ändern eines Blog-Artikels im Backend dargestellt wird. Plugins können bei diesem
Ereignis eigene Eingabefelder einbinden, die im Bereich \menu{Erweiterte
Optionen} angezeigt werden. \cmd{eventData}: Array mit Daten des Artikels, der
bearbeitet wird.

\ospitem{\picmd{backend\_entryform}} wird aufgerufen, wenn das Formular zum Erstellen
und Ändern eines Blog-Artikels im Backend dargestellt wird. Im Gegensatz zum
Ereignis \cmd{backend\_display} kann ein Plugin hier auf die Daten eines Artikels
zugreifen und Ausgaben am \emph{Anfang} des Eingabeformulars
einbinden.\cmd{eventData}: Array mit Daten des Artikels, der bearbeitet wird.

\ospitem{\picmd{backend\_entryform\_smarty}} wird aufgerufen, bevor das Smarty-Template
\cmd{admin/entries.tpl}\osplinebreak{} zum Bearbeiten eines Artikels dargestellt wird.
\cmd{eventData} enthält die Variablen des Smarty-Templates, die von der
Artikel-Oberfläche zugewiesen wurden.

\ospitem{\picmd{backend\_entry\_checkSave}} prüft gültige Eingabewerte vor dem
Speichern eines neuen Artikels (mittels JavaScript) auf Gültigkeit.

\ospitem{\picmd{backend\_entry\_updertEntry}} prüft gültige Eingabewerte vor dem
Speichern eines Artikels auf etwaige Fehler. Tritt ein Fehler auf, wird der
Artikel nicht gespeichert. \cmd{eventData}: Array, das mit Fehlermeldungen
gefüllt werden kann. \cmd{addData}: Array mit Daten des Artikels, der geprüft
wird.

\ospitem{\picmd{backend\_entry\_presave}} wird aufgerufen, kurz bevor ein Artikel in
der Datenbank gespeichert wird. \cmd{eventData}: Array mit Daten des Artikels,
der gespeichert wird.

\ospitem{\picmd{backend\_cache\_purge}} wird aufgerufen, wenn Caches von Artikeltexten
geleert werden müssen (siehe Seite \pageref{cachable-events}).

\ospitem{\picmd{backend\_cache\_entries}} wird aufgerufen, wenn Caches der aktuellsten
bestehenden Artikel neu erstellt werden sollen.

\ospitem{\picmd{backend\_import\_entry}} kann während des Blog-Imports von einzelnen
Importern aufgerufen werden, so dass Plugins zusätzliche Informationen für jeden
importierten Artikel setzen können. \cmd{eventData}: Array des neu eingefügten
Artikels. \cmd{addData}: Array mit bereits bestehenden Eigenschaften des
Artikels.

\ospitem{\picmd{backend\_entry\_toolbar\_body}, \picmd{backend\_entry\_toolbar\_extended}}
wird an der Stelle des Artikelformulars im Backend ausgeführt, bei der die
Symbolleiste für Formatierungen und die Einbindung von Dateien in der
Mediendatenbank ausgegeben wird. Plugins können dort eigene Symbolleisten
einbinden. \cmd{backend\_entry\_toolbar\_body} gilt für die Symbolleiste des
\menu{Eintrags} und \cmd{backend\_entry\_toolbar\_ex\-tended} für die Symbolleiste
des \menu{Erweiterten Eintrags}. \cmd{eventData}: enthält ein Array mit den Daten
des Artikels, der im Backend bearbeitet wird.

\ospitem{\picmd{backend\_entry\_iframe}} wird aufgerufen, wenn ein Blog-Artikel als
Vorschau im Backend eingebunden wird. Dies erfolgt über einen iframe.
\cmd{eventData} enthält standardmäßig den Wert \cmd{true}. Wenn ein Plugin dies
auf \cmd{false} ändert, kann es selbständig die Erstellung eines iframe
übernehmen. Der Serendipity-Kern überspringt in diesem Fall die vorgesehenen
Routinen zur Erstellung.
\end{ospdescription}

\index{Plugin-API!Ereignisse!Backend: Kategorien}%
\subsubsection{Backend-Ereignisse: Kategorien}
\begin{ospdescription}

\ospitem{\picmd{backend\_category\_addNew}} wird ausgeführt, wenn im Blog eine neue
Kategorie angelegt wird. \cmd{eventData}: ID der neu angelegten Kategorie.

\ospitem{\picmd{backend\_category\_delete}} wird ausgeführt, wenn ein oder mehrere
Kategorien gelöscht werden. \cmd{eventData}: ID der zu löschenden Kategorie. Kann
einen Von/Bis-Wert enthalten, der in einer MySQL-Abfage wie \cmd{DELETE FROM
\ldots\ WHERE id IN (1, 2, 3, 4 \ldots)} eingesetzt werden kann.

\ospitem{\picmd{backend\_category\_showForm}} stellt beim Bearbeiten einer Kategorie
das HTML-Formular mit den möglichen Eigenschaften dar. \cmd{eventData}: ID der
Kategorie, deren Eigenschaften verändert werden sollen. \cmd{addData}: enthält
ein Array mit den derzeitigen Eigenschaften der Kategorie.

\ospitem{\picmd{backend\_category\_update}} wird aufgerufen, wenn die Eigenschaften
einer Kategorie verändert wurden. \cmd{eventData}: ID der Kategorie.
\end{ospdescription}

\index{Plugin-API!Ereignisse!Backend: Login- und Rechtemanagement}%
\subsubsection{Backend-Ereignisse: Login- und Rechtemanagement}
\begin{ospdescription}

\ospitem{\picmd{backend\_auth}} wird beim Login eines Redakteurs ausgeführt, damit
dessen Benutzername/Passwort auch mit externen Quellen validiert werden kann.
\cmd{eventData}: enthält den Wert \cmd{true}, wenn das Passwort als MD5-Hash
durchgereicht wird. \cmd{addData}: Array mit Schlüsseln \cmd{username} und
\cmd{passwort}.

\ospitem{\picmd{backend\_login}} wird beim Login eines Redakteurs ausgeführt und muss
nicht zwangsläufig ein Benutzername/Passwort-Paar beinhalten. Plugins können so
Redakteure z.\,B.\ anhand von Cookie-Werten oder fester Daten wie IPs
authentifizieren. \cmd{eventData}: enthält den Wert \cmd{true}, wenn der
Redakteur bereits von Serendipity identifiziert werden konnte.

\ospitem{\picmd{backend\_sidebar\_entries\_event\_display\_profiles}} wird aufgerufen,
wenn die persönlichen Einstellungen eines Redakteurs angezeigt werden.
\cmd{eventData} enthält ein Array mit den Daten des Redakteurs.

\ospitem{\picmd{backend\_users\_add}} wird aufgerufen, wenn ein neuer Redakteurszugang
erstellt wurde. \cmd{eventData}: Array mit Eigenschaften des neuen Redakteurs.

\ospitem{\picmd{backend\_users\_delete}} wird aufgerufen, wenn ein Redakteurszugang
gelöscht wurde. \cmd{event\-Data}: Array mit Eigenschaften des zu löschenden
Redakteurs.

\ospitem{\picmd{backend\_users\_edit}} wird aufgerufen, wenn die Eigenschaften eines
Redakteurszugangs verändert wurden. \cmd{eventData}: Array mit Eigenschaften des
zu ändernden Redakteurs.

\label{hook-backend-sidebar-entries}%
\ospitem{\picmd{backend\_sidebar\_entries}} wird bei der Darstellung der Menüpunkte des
Backends ausgeführt. Über dieses Ereignis können zusätzliche Menüpunkte im
Bereich \menu{Einträge} hinzugefügt werden.

\ospitem{\picmd{backend\_sidebar\_entries\_images}} wird bei der Darstellung der
Menüpunkte des Backends ausgeführt. Über dieses Ereignis können zusätzliche
Menüpunkte im Bereich \menu{Mediendatenbank} hinzugefügt werden.

\ospitem{\picmd{backend\_sidebar\_admin\_appearance}} wird bei der Darstellung der
Menüpunkte des Backends ausgeführt. Über dieses Ereignis können zusätzliche
Menüpunkte im Bereich \menu{Aussehen} hinzugefügt werden.

\ospitem{\picmd{backend\_sidebar\_admin}} wird bei der Darstellung der Menüpunkte des
Backends ausgeführt. Über dieses Ereignis können zusätzliche Menüpunkte im
Bereich \menu{Administration} hinzugefügt werden.

\ospitem{\picmd{backend\_frontpage\_display}} wird bei der Darstellung der Startseite
des Backends nach dem Login ausgeführt. Dort können Plugins etwaige Informationen
oder weiterführende Links ausgeben. \cmd{eventData} enthält ein Array, das für
jeden einzelnen Schlüssel ein spezielles HTML-Fragment enthalten kann:
\cmd{welcome} für den Begrüßungstext, \cmd{links\_title} für die Überschrift der
\menu{Weiterführende Links}-Box, \cmd{links} als Array mit allen dargestellten
Links dieser Box, \cmd{links\_css} für die CSS-Klasse dieser Box, \cmd{more} für
alle weiteren HTML-Ausgaben auf der Startseite. \cmd{show\_links} enthält den
Wert \cmd{false}, wenn die Box \menu{Weiterführende Links} nicht angezeigt werden
soll. \cmd{bookmarklet} enthält die URL zu einem JavaScript-Code, mit dem Sie in
Ihrem Browser ein Lesezeichen speichern können, um sofort einen neuen Blog-Artikel
zu verfassen.

\ospitem{\picmd{backend\_login\_page}} wird aufgerufen, wenn das Login-Formular zum
Backend dargestellt wird. \cmd{eventData} enthält ein Array mit mehreren
HTML"=Ausgabefragmenten im Login-Formular und verwendet folgende Schlüssel:
\cmd{header} für die Überschrift des Login-Formulars, \cmd{table} für weitere
Tabellenzeilen des Login-Formulars, \cmd{footer} für eine abschließende Fußzeile
des Formulars.

\end{ospdescription}

\index{Plugin-API!Ereignisse!Backend: Mediendatenbank}%
\subsubsection{Backend-Ereignisse: Mediendatenbank}
\begin{ospdescription}

\ospitem{\picmd{backend\_image\_add}} wird aufgerufen, wenn eine neue Datei in die
Mediendatenbank eingefügt wurde. \cmd{eventData} enthält den Pfad zu der
eingestellten Datei. \cmd{addData} enthält den Pfad zur automatisch erzeugten
Voransicht der Datei.

\ospitem{\picmd{backend\_image\_addHotlink}} wird aufgerufen, wenn ein neuer
\emph{Hotlink} (siehe Seite \pageref{Hotlink}) in die Mediendatenbank eingefügt
wurde. \cmd{eventData} enthält den Pfad zu der temporären lokalen Kopie der zu
verknüpfenden Datei.

\ospitem{\picmd{backend\_image\_addform}} (via Smarty \cmd{media\_upload.tpl}) wird
aufgerufen, wenn das Eingabeformular zum Hochladen neuer Dateien für die
Mediendatenbank dargestellt wird.

\ospitem{\picmd{backend\_directory\_create}} wird aufgerufen, wenn ein neues
Verzeichnis in der Mediendatenbank erstellt wurde. \cmd{eventData}: vollständiger
Pfad des neu angelegten Verzeichnisses.

\ospitem{\picmd{backend\_media\_delete}} wird aufgerufen, wenn eine Datei der
Mediendatenbank gelöscht\osplinebreak{} wird. \cmd{eventData} enthält ein Array mit zu
löschenden zusätzlichen Dateien, z.\,B.\ der automatisch erzeugten Voransicht.

\ospitem{\picmd{backend\_media\_check}} wird aufgerufen, wenn eine Datei geprüft
werden soll, die gerade in die Mediendatenbank hochgeladen wird. Wenn
\cmd{eventData} von einem Plugin auf den Wert \cmd{true} gesetzt
wird, verbietet Serendipity das Einstellen dieser Datei. Dies
kann z.\,B.\ dazu verwendet werden, um das Hochladen von
JavaScript-Dateien oder unerwünschten Dateinamen zu verhindern. \cmd{addData}
enthält den hochgeladenen Dateinamen.

\ospitem{\picmd{backend\_media\_makethumb}} wird aufgerufen, wenn die Voransicht einer
Grafik erstellt werden soll. \cmd{eventData}: enthält ein verschachteltes Array,
dessen Unterarrays jeweils die Schlüssel \cmd{thumbSize} (Bildgröße der
Voransicht) und \cmd{thumb} (Datei-Suffix für die Voransicht) besitzen müssen.
Für jedes Unterarray, das durch Plugins angehängt werden kann, wird eine
weitere Voransichts-Datei erstellt.

\ospitem{\picmd{backend\_media\_path\_exclude\_directories}} wird bei der automatischen
Synchronisation der Mediendatenbank (siehe Seite \pageref{MDB-Synchronisation})
aufgerufen. Plugins können eine übergebene Liste von Datei- und Verzeichnisnamen
modifizieren, um so bestimmte Dateien von der Synchronisation auszuschließen.
\cmd{eventData} enthält ein Array, dessen Schlüssel die Zeichenkette des
auszuschließenden Datei-/Verzeichnisnamens festlegt.

\ospitem{\picmd{backend\_media\_rename}} wird ausgeführt, wenn ein Objekt der
Mediendatenbank umbenannt wird. \cmd{eventData} enthält ein verschachteltes
Array, bei dem jedes Unterarray eine umzubenennende Datei enthält. So können auch
die Namen der Voransichten automatisch umbenannt und durch Plugins verwaltet werden.

\ospitem{\picmd{backend\_thumbnail\_filename\_select}} wird aufgerufen, wenn Dateinamen
und Pfade eines Objekts der Mediendatenbank zusammengestellt werden.
\cmd{eventData} enthält die\osplinebreak{} Metadaten einer Datei der Mediendatenbank.

\end{ospdescription}

\index{Plugin-API!Ereignisse!Backend: Framework}%
\subsubsection{Backend-Ereignisse: Framework}
\begin{ospdescription}

\ospitem{\picmd{css\_backend}} für die Darstellung des CSS Stylesheets im Backend.
\cmd{eventData} (Array): CSS-Daten des Template-Stylesheets, kann durch
Plugins verändert/erweitert werden.

\ospitem{\picmd{backend\_wysiwyg}} wird aufgerufen, wenn im Backend ein
Texteingabebereich für einen WYSIWYG-Editor erscheinen soll.
\cmd{eventData}: Array mit Schlüsseln \cmd{init} (enthält \cmd{true}, wenn das
WYSIWYG-Javascript bereits instanziert wurde), \cmd{item} (Name des
HTML-Formularelements mit der WYS\-IWYG-Eingabe), \cmd{jsname} (ID des
HTML-Formularelements) und \cmd{skip} (enthält \cmd{true}, wenn ein
Eingabeelement nicht ausgegeben werden soll).

\ospitem{\picmd{backend\_wysiwyg\_finish}} wird aufgerufen (entweder über PHP oder auch
über Smarty"=Templates), wenn das WYSIWYG-Javascript instanziert werden soll.

\ospitem{\picmd{backend\_wysiwyg\_nuggets}} wird aufgerufen, wenn ein
WYSIWYG-Editorfeld für erweiterte Texteingabefelder (z.\,B.\ HTML-Klötze,
siehe Seite \pageref{htmlnugget}) eingebunden werden soll. \cmd{eventData}:
enthält ein Array mit den Schlüsseln \cmd{nuggets} (Array mit allen vorhandenen
HTML-WYSIWYG-Elementen) und\osplinebreak{} \cmd{skip\_nuggets} (enthält \cmd{true}, wenn keine
HTML-Klötze zu WYSI\-WYG-Eingabefeldern konvertiert werden sollen).

\ospitem{\picmd{backend\_configure}} wird aufgerufen, wenn das Serendipity-Backend
initialisiert wurde (analog zum Ereignis \cmd{frontend\_configure}).

\ospitem{\picmd{backend\_header}} wird aufgerufen, wenn der HTML-Bereich \cmd{<head>}
des Serendipity-Backends dargestellt wird (analog zum Ereignis
\cmd{frontend\_header}).

\ospitem{\picmd{backend\_trackbacks}} wird aufgerufen, wenn Trackbacks eines Artikels
versendet werden. \cmd{eventData} enthält ein Array mit allen auf Trackbacks zu
prüfenden URLs.

\ospitem{\picmd{backend\_trackback\_check}} wird für jede einzelne URL aufgerufen,
bevor an diese ein Trackback verschickt wird. \cmd{eventData}: automatisch
entdeckte Trackback-URL. \cmd{addData}: URL, bei der geprüft werden soll, ob sie
Trackback-fähig ist.

\ospitem{\picmd{event\_additional\_statistics}} wird vom Statistik-Plugin aufgerufen,
damit weitere Plugins ihre eigenen Statistiken darstellen können.

\ospitem{\picmd{backend\_sidebar\_entries\_event\_display\_\cmdvar{X}}} wird mit einer
vom Plugin am Ende des Ereignisnamens festgelegten Zeichenkette aufgerufen, um
beliebige Ausgaben im Hauptbereich des Backends darzustellen. Über solche
Ereignisse kann jedes Plugin eigene Backend-Bereiche realisieren. Diese
werden über eine URL wie
\cmd{http://www.example.com/serendipity/serendipity\_admin"".php?serendipity[adminModule]=event\_display\&serendipity""[adminAction]=\cmdvar{X}}
aufgerufen. Solche Links kann das Plugin über ein Ereignis wie \cmd{backend\_sidebar\_entries} 
(siehe Seite \pageref{hook-backend-sidebar-entries} leicht direkt im Backend-Menü einbinden.

\ospitem{\picmd{backend\_http\_request}} wird von Serendipity immer dann aufgerufen,
wenn vom Server eine HTTP-Verbindung zu einem fremden Server erstellt wird, z.\,B.\
bei Trackbacks, fremden RSS-Feeds, Importvorgängen und Weiterem. Der Server wird
dabei mittels der PEAR-Klasse \cmd{HTTP\_Request} angesprochen, die einige
Optionen unterstützt. Diese Optionen werden als \cmd{eventData} an die Plugins
weitergereicht, so dass sie verändert werden können, um z.\,B.\ die Verbindung über
den Umweg eines Proxies aufzubauen. Der Wert der Variablen \cmd{addData} gibt
dabei die Quelle der HTTP-Verbindung an: \cmd{image} (Herunterladen von
Mediendaten), \cmd{spartacus} (Operationen des Spartacus-Plugins),
\cmd{trackback\_detect} (Trackbacks erkennen), \cmd{trackback\_send} (Trackbacks senden).

\ospitem{\picmd{backend\_sendmail}} wird aufgerufen, wenn Serendipity eine E-Mail
verschickt. \cmd{eventData} enthält ein Array mit den Daten der E-Mail und
folgenden Schlüsseln: \cmd{to} (Mailempfänger), \cmd{subject} (Betreff),
\cmd{fromName} (Name des Absenders), \cmd{fromMail} (E-Mail-Adresse des
Absenders), \cmd{blogMail} (E-Mail-Adresse des Blogs), \cmd{version} (Version von
Serendipity), \cmd{headers} (E-Mail-Header), \cmd{message} (Text). Der Schlüssel
\cmd{legacy} enthält standardmäßig den Wert \cmd{true}, damit Serendipity die
eigenen Routinen zum Mailversand benutzt. Wenn ein Plugin diese Variable auf
\cmd{false} ändert, kann es den Mailversand selbständig übernehmen. \cmd{addData}
enthält den Zeichensatz des Blogs.

\end{ospdescription}

\index{Plugin-API!Ereignisse!Backend: Plugins und Templates}%
\subsubsection{Backend-Ereignisse: Plugins und Templates}
\begin{ospdescription}

\ospitem{\picmd{backend\_plugins\_fetchlist}} kann die Liste der verfügbaren Plugins
der Plugin-Verwaltung erweitern, wird hauptsächlich vom
\emph{Spartacus}-Plugin (siehe Seite \pageref{Spartacus}) benutzt.
\cmd{eventData}: Array mit Daten der verfügbaren Plugins.


\ospitem{\picmd{backend\_plugins\_fetchplugin}} wird aufgerufen, wenn ein bisher noch
nicht heruntergeladenes Plugin installiert werden soll. Dies wird hauptsächlich
von Spartacus benutzt, um an dieser Stelle das Plugin und dessen Metadaten
einzulesen. \cmd{eventData}: Array mit Daten des zu installierenden Plugins.

\ospitem{\picmd{backend\_plugins\_new\_instance}} wird beim Installieren eines neuen
Plugins aufgerufen. \cmd{eventData}: Name des Plugins. \cmd{addData}:
Positionierung des Plugins (\cmd{event}, \cmd{left}, \cmd{right} \ldots).

\ospitem{\picmd{backend\_pluginlisting\_header}} wird oberhalb der Plugin-Verwaltung
aufgerufen.

\ospitem{\picmd{backend\_plugins\_event\_header}} wird oberhalb der Auflistung aller
verfügbaren Ereignis-Plugins im Backend aufgerufen.

\ospitem{\picmd{backend\_plugins\_sidebar\_header}} wird oberhalb der Auflistung aller
verfügbaren Seitenleisten-Plugins im Backend aufgerufen.

\ospitem{\picmd{backend\_pluginlisting\_header\_upgrade}} wird oberhalb der
Plugin-Verwaltung aufgerufen, wenn ein Redakteur die Liste aller aktualisierbaren
Plugins einsieht.

\ospitem{\picmd{backend\_pluginconfig\_\cmdvar{X}}} wird ausgeführt, wenn eine
Konfigurationsoption eines Plugins keinem intern angebotenen
Datentypen (wie z.\,B.\ \cmd{string}, \cmd{radio} \ldots) entspricht. Das Plugin
kann so eigenständige Konfigurationstypen intern verwalten. \cmd{eventData}
enthält ein Array mit den Schlüsseln \cmd{config\_item} (Name der
Konfigurationsoption), \cmd{cbag} (\emph{Property-Bag}-Objekt der
\cmd{introspect\_config\_item()}-Methode des Plugins),\osplinebreak{} \cmd{plugin} (enthält das
Plugin-Objekt, dem die Konfigurationsoption entspringt), \cmd{value} (enthält den
aktuellen Wert der Konfigurationsoption), \cmd{bag} (\emph{Property-Bag}-Objekt
des Plugins) und \cmd{postKey} (Zeichenkette für die Benennung der
URL-Formularvariablen).

\ospitem{\picmd{backend\_template\_fetchlist}} kann die Liste der verfügbaren Templates
im Backend erweitern, wird hauptsächlich vom \emph{Spartacus}-Plugin benutzt.
\cmd{eventData}: Array mit Daten der verfügbaren Templates.

\ospitem{\picmd{backend\_template\_fetchtemplate}} wird aufgerufen, wenn ein bisher
noch nicht heruntergeladenes Template installiert werden soll. Dies wird
hauptsächlich von Spartacus benutzt, um an dieser Stelle das Template und dessen
Metadaten einzulesen.

\ospitem{\picmd{backend\_templates\_configuration\_top}} wird am Anfang der
Konfigurationsoptionen für ein Template ausgeführt, falls ein Template die
Variable \cmd{\$template\_config} belegt hat (siehe Seite
\pageref{templateoptionen}). \cmd{eventData} enthält ein Array mit den
Konfigurationsoptionen des Templates.

\ospitem{\picmd{backend\_templates\_configuration\_bottom}} wird am Ende der
Konfigurationsoptionen für ein Template ausgeführt, falls ein Template die
Variable \cmd{\$template\_config} belegt hat (siehe Seite
\pageref{templateoptionen}). \cmd{eventData} enthält ein Array mit den
Konfigurationsoptionen des Templates.

\ospitem{\picmd{backend\_templates\_configuration\_none}} wird ausgeführt, wenn das
aktuell gesetzte Template keine eigenständigen Template-Optionen anbietet.

\end{ospdescription}


%revised
\index{Shared Installation}%
\index{Gemeinsame Nutzung}%
\section{Shared Installation}
\label{sharedinstall}%

Serendipity unterstützt die Möglichkeit, die Serendipity-PHP-Dateien nur
einmalig auf einem Webserver hochzuladen und anhand eines zentralen
Verzeichnisses mehrere, vollständig unabhängige Blogs zu betreiben.

Dabei dient das Zentralverzeichnis ähnlich wie bei einer
\emph{PEAR}-Installation lediglich als Funktionsarchiv. Die Blog-Installationen
greifen auf diese Dateien zurück, um das Framework und notwendige Funktionen zu
laden, verwalten sich aber mittels eigener Datenbanktabellen vollständig selbst.

Diese Methode dient sozusagen als Notbehelf dafür, dass Serendipity über seine
Verwaltungsoberfläche jeweils nur ein einzelnes Blog konfigurieren kann. Zwar
lässt sich über den Umweg von individualisierten Unter"=Kategorien des Blogs
(bei Verwendung des Plugins \emph{Erweiterte Eigenschaften von Kategorien}, siehe
Seite \pageref{entryproperties}) etwas Ähnliches erreichen, doch bei dieser 
Methode existiert stets nur eine physikalische Installation Serendipitys, die nur 
auf eine einzelne Datenbank zugreift.

Eine Serendipity-Installation benötigt für die Einrichtung nur folgende
individuelle Dateien und Verzeichnisse:

\begin{osplist}
\item Datei \cmd{serendipity\_config\_local.inc.php} mit den Zugangsdaten zur
Datenbank,
\item Datei \cmd{.htaccess} mit der Einrichtung der Verzeichnisnamen,
\item Verzeichnis \cmd{archives} und \cmd{templates\_c} zum Schreiben von
Temporärdateien,
\item Verzeichnis \cmd{uploads} zum Speichern von Medien.
\end{osplist}

Alle weiteren Dateien und Verzeichnisse können aus dem zentralen
Verzeichnis eingebunden werden.
Dies hat den großen Vorteil, dass Sie die Serendipity-Dateien zentral warten
können. Bei einem Update müssen Sie nur an einer Stelle neue Dateien hochladen
und aktualisieren damit automatisch alle weiteren Blogs.

\subsection{Beispiel}

Am einfachsten lässt sich die Einrichtung mehrerer Blogs auf Basis der
\emph{Shared Installation} mit einem Beispiel verdeutlichen.

Unser Ziel soll sein, drei Blogs einzurichten. Zwei dieser Blogs sollen auf
einer Domain laufen und über \cmd{http://blogs.seniorgamer.de/shooter/} und
\cmd{http://blogs.seniorgamer.de/mmorpg/} aufgerufen werden. Das\osplinebreak{} dritte Blog
befindet sich unter \cmd{http://www.percanat-blog.de/}. 

Jede Domain besitzt einen sogenannten \cmd{Document Root}. In diesem
Stammverzeichnis befinden sich die Dateien der jeweiligen Domain. In unserem
Beispiel haben wir FTP-Zugriff auf folgende Verzeichnisse:

\begin{ospdescription}
\ospitem{\cmd{/home/www/seniorgamer.de/htdocs/}} für Blog 1 und 2
\ospitem{\cmd{/home/www/percanat-blog.de/htdocs/}} für Blog 3
\end{ospdescription}

\index{Deployment}%
In diese Verzeichnisse kopieren wir später das Grundgerüst von Serendipity,
die sogenannten \emph{Deployments}.

\subsubsection{1. Einrichtung des Core}

Der erste Schritt ist die Einrichtung des
Serendipity-Zentralverzeichnisses, des sogenannten \emph{Core}. Am sinnvollsten
ist es, dieses Verzeichnis in einem zentralen Server-Verzeichnis, ähnlich wie
\emph{PEAR}, einzurichten. Oft haben Sie auf einem gehosteten Server aber keinen
Zugriff auf ein Verzeichnis wie \cmd{/usr/local/lib/php}, daher können Sie das
Server-Verzeichnis auch anderweitig einrichten.

Wichtig ist lediglich, dass alle \emph{Deployments} später Lesezugriffsrechte zu
diesem Ordner besitzen. Wenn Ihr Server also den Zugriff auf außerhalb liegende
Verzeichnisse mittels \cmd{open\_basedir}-PHP-Anweisungen oder Ähnlichem
beschränkt, ist die Methode der \emph{Shared Installation} für Sie nicht anwendbar. 

In unserem Beispiel wollen wir einen Mittelweg gehen. Wir ernennen das
Verzeichnis \cmd{/home/www/seniorgamer.de/htdocs/} als Ziel unseres
\emph{Core}, da wir dort sowieso Unterverzeichnisse für zwei der drei Blogs
anlegen werden.

Wir entpacken also nun das übliche Serendipity-Installationsverzeichnis unter
\cmd{/home/www/seniorgamer.de/htdocs/Serendipity}. Sobald Sie die Dateien
hochgeladen haben, müssen Sie keine weitere Installation vornehmen. Nur
\emph{Deployments} müssen installiert werden -- der \emph{Core} selbst enthält
keine Zugangsdaten zu einer Datenbank oder Weiteres.

\subsubsection{2. Einrichtung der Deployments}

Nun müssen wir die \emph{Deployments} einrichten. Serendipity verfügt über
eine kleine Sammlung an Basisdateien, die wir benötigen.

Dazu erstellen wir vorerst ein leeres Blog-Verzeichnis in jedem der
Zielverzeichnisse: 

\begin{ospcode}
/home/www/seniorgamer.de/htdocs/shooter/
/home/www/seniorgamer.de/htdocs/mmorpg/
/home/www/percanat-blog/htdocs/
\end{ospcode}

In jedes dieser drei leeren Verzeichnisse kopieren wir nun den vollständigen
Inhalt des Core-Verzeichnisses
\cmd{/home/www/seniorgamer.de/htdocs/Se\-rendipity/deployment}. Danach sollten Sie
in jedem der drei Verzeichnisse eine Liste wie folgende besitzen:

\begin{ospcode}
/home/www/seniorgamer.de/htdocs/shooter/comment.php
/home/www/seniorgamer.de/htdocs/shooter/exit.php
/home/www/seniorgamer.de/htdocs/shooter/index.php
/home/www/seniorgamer.de/htdocs/shooter/rss.php
/home/www/seniorgamer.de/htdocs/shooter/serendipity\_admin\_image\_selector.
php
/home/www/seniorgamer.de/htdocs/shooter/serendipity\_admin.php
/home/www/seniorgamer.de/htdocs/shooter/serendipity\_config.inc.php
/home/www/seniorgamer.de/htdocs/shooter/serendipity.css.php
/home/www/seniorgamer.de/htdocs/shooter/serendipity\_define.js.php
/home/www/seniorgamer.de/htdocs/shooter/serendipity\_editor.js
/home/www/seniorgamer.de/htdocs/shooter/serendipity\_xmlrpc.php
/home/www/seniorgamer.de/htdocs/shooter/wfwcomment.php
/home/www/seniorgamer.de/htdocs/shooter/comment.php
\end{ospcode}

Die Bedeutung der einzelnen Dateien ist auf Seite \pageref{s9yfiles} ausführlich
beschrieben. Wenn Sie sich diese Dateien einmal in einem Editor ansehen, werden Sie
feststellen, dass die Dateien lediglich inhaltsleere Verweise sind, die die
eigentlichen Serendipity-Core-Dateien einbinden:

\begin{ospcode}
<?php # \$Id:\$
# Copyright (c) 2003-2005, Jannis Hermanns (on behalf the Serendipity 
# Developer Team)
# All rights reserved.  See LICENSE file for licensing details
# Serendipity is provided in managed mode here

require_once 's9y/index.php';
/* vim: set sts=4 ts=4 expandtab : */
?>
\end{ospcode}

\subsubsection{3. Für Einbindung des Core sorgen}

Wie man anhand des Code-Grundgerüsts sehen kann, gehen die standardmäßig
gelieferten \emph{Deployments} davon aus, dass Sie den Serendipity-Core in einem
Verzeichnis namens \cmd{s9y} abgelegt haben. Wenn in einem PHP-\cmd{include/require}-Befehl
kein voller Verzeichnisfad zu einer Datei angegeben
wird, bezieht PHP diesen Pfad automatisch anhand der Konfigurationseinstellung
\cmd{include\_path}. Meist enthalten Web-Server für diesen Wert lediglich das
Verzeichnis \cmd{/usr/local/lib/php}, wo auch \emph{PEAR} abgelegt wird.

Wenn wir auf unserem Server Zugriff zu einem im \cmd{include\_path} enthaltenen
Verzeichnis hätten und dort Serendipity in ein \cmd{s9y}-Unterverzeichnis
legen würden, wäre die Einbindung des Core in unseren Deployments problemlos
möglich. 

In unserem konstruierten Beispiel fehlt uns der Zugriff auf ein derartiges
Verzeichnis, daher müssen wir die Dateien der \emph{Deployments} leicht
abändern. Da wir Serendipity in den Pfad
\cmd{/home/www/seniorgamer.de/htdocs""/Serendipity/} kopiert haben, müssen wir nun
diesen Pfad in allen PHP-Scripts des obigen Verzeichnisses eintragen.

In allen Dateien der \emph{Deployments} ändern Sie daher die Zeilen wie

\begin{ospcode}
require_once 's9y/index.php';
\end{ospcode}

in

\begin{ospcode}
require_once '/home/www/seniorgamer.de/htdocs/Serendipity/index.php';
\end{ospcode}

ab. Wenn Sie die Möglichkeit haben, wäre eine Alternative zu diesem Schritt
selbstverständlich einfach das korrekte Setzen des PHP-\cmd{include\_path} auf
dieses Verzeichnis. Achten Sie in diesem Fall aber darauf, dass Ihr zentrales
Verzeichnis dann nicht \cmd{Serendipity} lauten darf, sondern wie durch die
Dateien des Deployments festgelegt \cmd{s9y}.

\subsubsection{4. Weitere Verzeichnisse anlegen}

Jedes Verzeichnis mit den \emph{Deployments} benötigt nun noch einige
Kleinigkeiten. 

Zum einen müssen die drei (leeren) Verzeichnisse \cmd{upload}, 
\cmd{templates\_c} und \cmd{archives} existieren und Schreibrechte für PHP (z.\,B.\
0777) besitzen.
Für eine fehlerfreie Installation muss das jeweilige Stammverzeichnis ebenfalls 
Schreibrechte besitzen, da andernfalls die beiden Dateien \cmd{.htaccess} und
\cmd{serendipity\_config\_local.inc.php} nicht erstellt werden könnten.

Um Plugins zu installieren, kann jedes \emph{Deployment} standardmäßig auf die Plugins
des \emph{Core} zurückgreifen. Wenn ein Blog jedoch nur auf bestimmte Plugins
zugreifen können soll, ist es empfehlenswert, das Verzeichnis
\cmd{/home/www/seniorgamer.de/htdocs/Serendipity/plugins} in das Verzeichnis
des jeweiligen \emph{Deployments} zu übernehmen. Um Redundanz zu vermeiden, wäre
es am besten, dieses Verzeichnis symbolisch zu verlinken. Wenn Ihr
Server/Provider dies nicht unterstützt, müssen Sie das komplette
\cmd{plugins}-Verzeichnis einfach kopieren.

Dasselbe gilt für das Verzeichnis \cmd{templates}. Dieses müssen Sie auch
entweder symbolisch vom \emph{Core}-Verzeichnis in das jeweilige
\emph{Deployment} verknüpfen oder kopieren.

Wenn Sie den internen WYSIWYG-Editor von Serendpity verwenden wollen, müssen Sie
als Letztes auch das Verzeichnis \cmd{htmlarea} übernehmen.
 
\subsubsection{5. Installation der Deployments ausführen}

Nun sind alle Deployments entsprechend vorbereitet und können installiert
werden. Rufen Sie dazu die URL wie
\cmd{http://blogs.seniorgamer.de""/shooter/serendipity\_admin.php} auf und folgen
Sie dem Serendipity-Installationsprozess. Dabei wird eine eigenständige
Konfigurationsdatei im \emph{Deployment}-Verzeichnis und eine
eigenständige Datenbank erstellt. Falls Sie alle Deployments in eine einzelne
Datenbank installieren, sollten Sie die \emph{Forgeschrittene Installation}
wählen und unterschiedliche Tabellenpräfixe nutzen.

Wenn Sie zusätzliche Demo-Inhalte in ein Deployment einstellen wollen, können
Sie die Dateien \cmd{sql/preload.sql} mit entsprechenden SQL"=Anweisungen füllen.
Wenn Ihr Deployment über die Standardsettings von Serendipity hinaus bestimmte
Plugins vorinstallieren soll, können Sie eine Datei \cmd{plugins/preload.txt}
mit den Namen der Plugin-Klassen (z.\,B.\ \cmd{se\-rendipity\_event\_nl2br}) füllen.
Trennen Sie mehrere Plugins mit einem Zeilenumbruch voneinander. Nach jedem
Plugin müssen Sie die Platzierung des Plugins eintragen (\cmd{left}, \cmd{right}
oder \cmd{event}):

\begin{ospcode}
serendipity\_event\_nl2br:event
serendipity\_plugin\_history:left
\ldots
\end{ospcode}

\subsubsection{6. Betrieb der Deployments}

Alle Deployments sind nun aufgrund ihrer eigenen Datenbanktabellen und
Konfigurationsdateien unabhängig voneinander. Über die jeweilige
\cmd{seren\-dipity\_admin.php}-URL können diese Deployments verwaltet werden.

\osppagebreak

Übrigens können Sie mehrere bestehende \emph{normale} Serendipity-Blogs auf
einem Server auch mit geringfügigem Aufwand in \emph{Shared Installations} umwandeln.

Dazu müssen Sie wie oben beschrieben ein Zentralverzeichnis einrichten.
Ersetzen Sie die bestehenden PHP-Dateien der bereits bestehenden
Blog-Installation durch die Dateien eines \emph{Deployments} und passen Sie wie
beschrieben die Pfade in den \cmd{.php}-Dateien an. Daraufhin können Sie in den
bestehenden Blogs die Verzeichnisse wie \cmd{include}, \cmd{deployment},
\cmd{docs}, \cmd{bun\-dled-libs}, \cmd{lang} und \cmd{sql} löschen; diese werden
in Zukunft aus dem \emph{Core-Verzeichnis} bezogen. Die Verzeichnisse
\cmd{templates} und \cmd{plugins} sollten Sie beibehalten, ebenso wie die
Konfigurationsdateien \cmd{serendipity\_config\_""local.inc.php} und \cmd{.htaccess}.\footnote{Eine ausführlichere Beschreibung dieses Vorgangs anhand einer tatsächlich
ausgeführten Umstellung bietet Falk Döring in seinem Blog unter
\cmd{http://www.""fadoe.de/""archives/136-Einzel-Blogs-auf-Shared-Blogs-umstellen-Projektbeschre""ibung.html} an.}

\subsection{Einsatzgebiete}

\emph{Shared Installations} machen besonders dann Sinn, wenn sie
automatisiert angelegt werden. Der obige Vorgang ist zwar nicht übermäßig
komplex, aber bereits umfangreich genug, um ein Script für diese Sklavenarbeit
einzusetzen. 

Provider wie \cmd{http://supersized.s9y.org/} setzen auf diese Art der
Shared Installation, um freie Serendipity-Blogs für Interessierte zu
erstellen. So kann Serendipity dann tatsächlich wie ein \cmd{blogger.com}-Ersatz
verwendet werden.

Leider sind die Rahmenbedingungen der Server zu unterschiedlich, um den Vorgang
einer Shared Installation so zu abstrahieren, dass er sich überall
einsetzen lässt. Zugriffsrechte, \cmd{open\_basedir}- und
\cmd{include\_path}"=Konfigurationen sind zu unterschiedlich und meist so
individuell, dass ein vollständig automatisiertes Script mehr falsch als richtig
machen könnte.

Im CVS von Serendipity steht dennoch eine kleine Script-Sammlung zur Verfügung.\footnote{\cmd{http://php-blog.cvs.sourceforge.net/php-blog/additional\_plugins/set""up/s9y\_conf/}
und \cmd{http://www.s9y.org/41.html}.}
Diese Sammlung kann Server-Administratoren dazu dienen, ihre eigenen Scripts zur
Erstellung von Shared Installations zu entwickeln.

Häufig macht es nämlich direkt Sinn, eine Nutzerverwaltung anzubinden. Damit
könnten aggregierte Blog-Übersichtsseiten erzeugt werden, oder ein zentrales
SQL-Datenbank-Interface, um SQL-Abfragen für alle \emph{Shared Blogs} auszuführen.

\index{Embedding}%
\index{Eingebettete Nutzung}%
\section{Embedding/Eingebettete Nutzung}
\label{embedding}

Häufig wünschen sich Blog-Betreiber, ihr Blog in eine bereits bestehende
Webseite einzubinden.

Diese Anforderung klingt eigentlich recht simpel, ist aber technisch relativ
komplex. Das Grundproblem dabei ist, dass Serendipity als eigenständige
Anwendung agiert. Es sendet vollständige HTML-Seiten, HTTP-Kopfzeilen und
benötigt URL-Parameter, um zu bestimmen, welche Inhalte angezeigt werden sollen.

Die einfachste Form der Einbindung von Serendipity in eine bestehende Seite wäre
die Erstellung eines \emph{framesets} oder \emph{iframes} innerhalb des
HTML-Codes Ihrer Seite. So wird Serendipity für den Besucher im Rahmen Ihrer
Seite eingebunden, ist aber technisch weiterhin vollständig losgelöst von Ihrer
Webseite. 

Dies ist natürlich nur die halbe Miete und bringt zahlreiche Probleme mit sich: 
Lesezeichen können bei Frames nicht gut verarbeitet werden, Suchmaschinen und sehbehinderte
Menschen können weniger gut darauf zugreifen, und auch das Design kann durch den
Einsatz von Frames durcheinander geraten.

\index{Wrapper}%
\subsection{Die Wrapper-Methode}

Bevor Serendipity mit Smarty-Templates umgehen konnte, wurde der \emph{Embed
Mode} aus der Taufe gehoben. Diesen Modus können Sie über die Konfiguration
Serendipitys aktivieren (Abschnitt \menu{Konfiguration\sm Design und Optionen\sm Eingebettete Nutzung von Serendipity aktivieren}). Er sorgt dafür, dass die Seiten von
Serendipity selbst keine HTML-Kopf- und Fußzeilen ausgeben und somit einfacher in
eine fremde Seite eingebunden werden können. Der Serendipity-Inhalt dient in so einem Fall also
lediglich einem HTML-Konstrukt, das auf einer vollständigen Seite eingebunden
werden muss. Wenn man ein Serendipity-Blog mit aktiviertem \emph{Embed Mode}
direkt aufruft, sieht man eine unformatierte HTML-Seite.

Serendipity sollte im \emph{Embed Mode} daher nicht mehr direkt aufgerufen
werden, sondern über den Umweg eines \emph{Wrappers}. Ein Wrapper ist eine
Art Container, der Serendipity und Ihre Webseite verkoppelt. Dafür bietet 
Serendipity die Option \menu{Konfiguration\sm Pfade\sm Index-Datei} an, mit
der Sie festlegen, welche Datei von Serendipity zur Darstellung des Blogs
angesprochen wird.

Wenn Sie einen Wrapper einsetzen wollen, müssen Sie an dieser Stelle einen
alternativen Dateinamen vergeben. Hierfür empfiehlt sich z.\,B.\ ein Dateiname wie
\cmd{wrapper.php}. Diese Datei muss von Ihnen im folgenden Schritt erstellt
werden, und es ist sehr wichtig, dass diese Datei im selben Verzeichnis wie
Serendipity liegt. Falls Sie mittels einer Angabe wie \cmd{../wrapper.php}
tricksen , wird dies die Permalink-Behandlung von Serendipity
durcheinanderbringen, und viele Seiten des Frontends werden nicht mehr
funktionieren. 

Die \cmd{wrapper.php}-Datei muss nun dafür sorgen, den Serendipity-Inhalt und
den Inhalt Ihrer Webseite zu \emph{verheiraten}. Ein derartiges Script kann wie
folgt aussehen:

\begin{ospcode}
<?php
ob\_start();
include 'index.php';
\$blog = ob\_get\_contents();
ob\_end\_clean();

include '../homepage.php';
?>
\end{ospcode}

Dieses Script sorgt dafür, alle Serendipity-Ausgaben in die Variable
\cmd{\$blog} zu speichern. Danach bindet es eine Datei wie \cmd{../homepage.php}
ein, die den üblichen Code Ihrer Webseite beinhaltet. Ob dies ein PHP-Script
oder einfacher HTML-Code ist, ist eigentlich egal. Sie müssen lediglich an der
Stelle Ihrer Homepage, wo Sie die Inhalte des Blogs sehen wollen,
die Variable \cmd{\$blog} ausgeben.

Wie Sie sehen, bindet das Wrapper-Script Dateien aus einem Unterverzeichnis
(\cmd{../}) ein. Sie sollten bei der Erstellung Ihrer Homepage also möglichst
darauf achten, dass alle Ihre Links relativ zum Stammverzeichnis der Homepage
angelegt sind, und nicht relativ zum aktuellen Verzeichnis -- denn sonst könnten
durch den Einsatz des Wrappers die Links Ihrer \cmd{homepage.php} nicht mehr zum
richtigen Ziel zeigen.

Grundsätzlich können Sie anstelle von \cmd{homepage.php} auch jedes andere
PHP-Framework einbinden, solange Sie die \cmd{\$blog}-Variable entsprechend
ausgeben. Theoretisch können Sie auch zuerst Ihr PHP-Framework einbinden und
erst danach wieder ins Serendipity-Verzeichnis wechseln, die Variable
\cmd{\$blog} zusammenstellen lassen und später ausgeben. Dies hängt allein von
dem auf Ihrer Seite benötigten Workflow ab.

Wichtig ist, dass Ihre einbindende Webseite selbständig alle
HTML"=Kopfzeilen ausgibt und auch alle eventuell benötigten Stylesheets von
Serendipity einbindet.

\subsection{Die Smarty-Methode}

Seit Serendipity das \emph{Smarty}-Templating unterstützt, gehört der
umständliche Umweg über eine Wrapper-Datei eher zum alten Eisen.


\osppagebreak

Mittels der \cmd{index.tpl}-Template-Datei Ihres Blog-Templates können Sie
bereits über die Smarty-Funktion \cmd{include\_php} oder \cmd{include\_file}
anderen HTML-Code Ihrer Webseite einbinden. Wenn Sie also bereits eigene
\emph{Header/Footer}-Dateien haben, können Sie diese ebenfalls ganz einfach im
Smarty-Template einbinden.

So müssen Sie sich nur an einer zentralen Stelle um das HTML-Groblayout kümmern
und nicht extra Ihre bereits bestehenden PHP-Header/Footer mühsam in ein
Serendipity-Template gießen.

Sie können sogar eigene PHP-Klassen und -Funktionen über den Umweg der
Smarty-Funktionen gehen. Dazu können Sie die Datei \cmd{config.inc.php} Ihres
Templates bearbeiten. Sämtlicher dort enthaltener PHP-Code wird vor der Ausgabe
des Templates von Serendipity ausgeführt und kann so auf ein Framework Ihrer
Webseite zugreifen.

Bedingung für die Fremdeinbindung von PHP-Code ist, dass Sie in der Datei
\cmd{config.inc.php} (siehe auch Seite \pageref{configinc}) 
die Zeile \cmd{\$serendipity['smar\-ty']->security = false;} einbinden. Damit wird
die Ausführungssicherheit deaktiviert, und Ihnen stehen alle PHP-Funktionen zur
Verfügung. 

\subsection{Das Serendipity-Framework nutzen}

Die eingangs vorgestellte \emph{Wrapper}-Lösung basierte darauf, dass
Serendipity als Erstes aufgerufen wird und dann Ihre Webseite einbindet.

Grundsätzlich können Sie Serendipity auch von einem PHP"=Framework aus
einbinden. Dazu reicht ein PHP-Code wie dieser:

\begin{ospcode}
<?php
// Ihr eigener Framework-Code befindet sich hier
\ldots

// Speichern des aktuellen Verzeichnisses
\$current = getcwd();

// Zum Serendipity-Verzeichnis wechseln
chdir('/home/www/example.com/serendipity/');

// Serendipity-Framework einbinden
include 'serendipity_config.inc.php';

// Serendipity-Smarty-Framework starten
serendipity\_smarty\_init();

// Liste der aktuellsten Blog-Artikel holen.
\$entries = serendipity_fetchEntries(null, true, 10);

// Einträge formatieren
serendipity\_printEntries(\$entries);

// Template-Datei zur Darstellung einlesen
\$tpl = serendipity\_getTemplateFile('entries.tpl', 'serendipityPath');

// Template darstellen
serendipity['smarty']->display(\$tpl);

// Zurück zu Ihrem Framework wechseln
chdir(\$current);

// hier Ihr etwaiger weiterer Framework-Code
\ldots
\end{ospcode}

Grundsätzlich können Sie nach Einbindung des Serendipity-Frameworks auf alle
Funktionen zurückgreifen, die in Kapitel \ref{zentralefunktionen} ab 
Seite \pageref{zentralefunktionen} aufgeführt sind.

\index{Schnittstellen}%
\index{Benutzerauthentifikation}%
\section{Externe Schnittstellen zur Benutzerauthentifikation}

Serendipitys Framework ist darauf ausgelegt, auf seine eigenen Datenbanktabellen
zugreifen zu können. Daher ist eine Integration einer fremden Benutzerdatenbank
oder Rechteverwaltung nicht ohne Weiteres möglich.

Häufig kommt der Wunsch auf, dass Sie eine Webseite z.\,B.\ mit einem Forum und
einem Blog betreiben. Beide Komponenten liefern eine Benutzerverwaltung, und Sie
müssten sich jeweils separat in beiden Anwendungen einloggen, um Zugriff zu
erhalten. 

Da die Benutzerdatenbanktabellen in vielen Serendipity-SQL-Abfragen zum Tragen
kommen, kann man diese leider nicht ohne Weiteres kapseln und mit
Fremdanwendungen verkoppeln. Das Gleiche gilt für fremde Forensoftware, die
ebenfalls eine eng verzahnte eigene Benutzerdatenbank abbildet.

An dieser Stelle gibt es daher meist nur eine Lösung: Man muss eine der
Datenbanktabellen als \emph{Master} deklarieren und alle anderen Datenbanken
mit deren Daten befüllen.

\index{LDAP}%
\subsection{LDAP}

Als Musterlösung für ein solches Vorgehen bietet Serendipity das Plugin
\emph{Externe Benutzer-Authentifizierung (LDAP)}
(\cmd{serendipity\_event\_external\-auth}) an. Dieses Plugin demonstriert, wie
eine fremde LDAP"=Benutzerdatenbank eingebunden werden kann.

\emph{LDAP} steht für \emph{Lightweight Directory Access Protocol} und stellt
Mittel einer zentralen Benutzerverwaltung zur Verfügung. Im Gegensatz zu einer
SQL-Datenbank besteht ein solches System aus einer beliebigen Baumstruktur mit
beliebigen Wertekonstellationen. Daher eignet es sich schlecht für die Verbindung
in einem Blog-System, das mit relationalen SQL-Datenbanken arbeitet. 

\index{Proxy-Authentifikation}%
Um dieses konzeptionelle Problem zu umgehen, geht das Serendipity"=Plugin den
Umweg über einen sogenannten \emph{Proxy-Mechanismus}. Die zentrale
Serendipity"=Benutzerdatenbank greift dabei weiterhin auf ihre eigene, gewohnte
Datenbanktabelle zu, wenn sich ein Benutzer einloggen will. 

Nur wenn der Benutzer in dieser Tabelle nicht gefunden wird, stellt das Plugin
eine Verbindung zum \emph{LDAP}-Benutzerverzeichnis her und sucht dort nach dem
Benutzer. Wird er dort gefunden, werden alle Login-relevanten Daten ausgelesen
und in der Serendipity-Benutzerdatenbank geklont/du\-pli\-ziert.

Dabei entsteht zwangsläufig Redundanz. Das Plugin versucht diese zumindest in
geringem Rahmen zu halten, gleicht die beiden Datenbanktabellen regelmäßig
miteinander ab und löscht beispielsweise Benutzeraccounts, die im
LDAP-Verzeichnis nicht mehr aufgeführt werden.

Nach einem ähnlichen Schema müssten Sie das Plugin erweitern, um dieselbe Aktion
für eine fremde Beutzerdatenbank durchzuführen. Sie brauchen also einen
regelmäßigen Synchronisierungsvorgang, der die dedizierte \emph{Master}-Tabelle
mit der \emph{Serendipity-Datenbank} abgleicht.

Um zum Beispiel eines fremden Forums zurückzukehren, müssten Sie also die
Daten dieser Benutzerdatenbanktabelle regelmäßig mit der von Serendipity
abgleichen. Das Plugin könnte dabei auch automatisch entsprechend geteilte
PHP-Sessiondaten erstellen. 

Dies alles erfordert natürlich eine gewisse Kenntnis der Systemarchitektur der 
fremden Applikation wie auch der von Serendipity. Daher wird dieser Weg relativ 
selten beschritten und eher nur von Dienstleistungsagenturen mit guten 
Systemkenntnissen angeboten. Eine Liste derartiger Dienstleister finden Sie auf 
der Serendipity-Projektseite unter \cmd{http://www.s9y.org/20.""html}.

\index{OpenID}%
\subsection{OpenID}

Dem Problem der Fremdauthentifikation tritt nicht nur bei Serendipity auf,
sondern bei sehr vielen Web-2.0-Anwendungen. Daher hat sich ein Konsortium
gegründet, das sich mit der \emph{OpenID}-Initiative\footnote{\cmd{http://www.openid.net}} das Ziel gesetzt hat, eine einheitliche und
dezentrale Benutzerauthentifizierung zur Verfügung zu stellen.

Auch für Serendipity gibt es hierzu bereits ein erstes Plugin, das sich jedoch
im täglichen Einsatz noch beweisen muss. Da sich OpenID aufgrund seiner
Komplexität generell eher schleppend fortentwickelt, ist jegliche Mitarbeit bei
diesem Thema im Serendipity-Forum sehr willkommen.

OpenID kümmert sich derzeit in erster Linie nur um das Problem, Besucher
für ihre Kommentare zu authentifizieren. In seiner jetzigen Form 
unterstützt OpenID kein komplexes Rechtemanagement und kann daher die 
Verwaltung von Benutzern und Gruppen in Serendipity nicht ersetzen bzw. 
darauf aufbauen. Für diese Verwaltung werden also nach wie vor zentrale 
Serendipity-Tabellen benötigt. 

Bis auch diese Tabellen durch einen offenen Standard ersetzt werden können, wird
noch viel Wasser den Rhein hinunterlaufen -- dennoch ist auch hier die Mithilfe
bei der Entwicklung nötiger Standards in unser aller Interesse.

\index{MySQL!Views}%
\subsection{MySQL VIEWs}

Eine sehr komfortable Lösung zum automatisierten Abgleich einer
\emph{Master}-Tabelle mit anderen Fremdtabellen ist der Einsatz von
\emph{Views}, die für das \emph{MySQL}-Datenbanksystem zur Verfügung stehen.

\emph{Views} (\emph{Sichten}) stellen ein Mittel von MySQL (ab Version 5.1) dar,
die Ergebnisse einer SQL-SELECT-Abfrage als virtuelle Tabelle zu erstellen. So
kann man eine fremde Benutzerdatenbanktabelle so \emph{umbiegen}, dass sie
in Wirklichkeit auf eine andere Tabelle zeigt.

Für die folgende Beschreibung gehen wir davon aus, dass Sie mit SQL-Code umgehen
und eine SQL-Oberfläche wie \cmd{phpMyAdmin} bedienen können.

Gehen wir von einem Forensystem aus, das folgende Benutzertabelle verwendet:

\begin{ospcode}
CREATE TABLE `forum\_users\` (
  `user\_id` mediumint(8) NOT NULL,
  `user\_name` varchar(30),
  `user\_password` varchar(30),
  PRIMARY KEY (`user\_id`)
);
\end{ospcode}

Im Vergleich dazu die bekannte \cmd{serendipity\_authors}-Tabelle:

\begin{ospcode}
CREATE TABLE `serendipity_authors` (
  `authorid` int(11) NOT NULL auto_increment,
  `realname` varchar(255) NOT NULL
  `username` varchar(20),
  `password` varchar(32),
  `mail_comments` int(1) default '1',
  `mail_trackbacks` int(1) default '1',
  `email` varchar(128) NOT NULL,
  `userlevel` int(4) NOT NULL,
  `right_publish` int(1) default '1',
  PRIMARY KEY  (`authorid`)
);
\end{ospcode}

Glücklicherweise ist unsere Beispielstruktur hier relativ kompatibel: Das Feld
\cmd{user\_id} kann mit \cmd{authorid} verkettet werden, \cmd{user\_name} mit 
\cmd{real\-name} und \cmd{username}, und \cmd{user\_password} mit \cmd{password}.
Wären die Passwörter in einem unterschiedlichen Format gespeichert, müsste man
sich mit den MySQL-Funktionen MD5() etc. auseinandersetzen, um ein identisches
Format zu erreichen.

Nachdem die Tabellenspalten derart zugeordnet wurden, muss man sich
entscheiden, welche Tabelle den \emph{Master} darstellt. Wir wählen Serendipity
aus, weil dies über mehr Meta-Daten verfügt und die komplexere
Benutzerverwaltung aufweist. Sie sollten stets die Tabelle als \emph{Master}
wählen, die die höchste Wichtigkeit in Ihrem Projekt darstellt und die größte
Komplexität aufweist.

Die Serendipity-Datenbanktabelle \cmd{serendipity\_authors} bleibt daher
unverändert, und die Tabelle \cmd{forum\_users} muss nun durch einen
\emph{View} virtualisiert werden, damit sie direkt auf die Serendipity-Tabelle
zugreift.

Am Ende der Virtualisierung wird das Löschen der Tabelle \cmd{forum\_users}
stehen. Da eine virtuelle Tabelle nicht den Namen einer tatsächlich bestehenden
Tabelle besitzen darf, benennen wir als Erstes diese Tabelle um:

\begin{ospcode}
RENAME TABLE `forum\_users` TO `tmp\_forum\_users`;
\end{ospcode}

Diese Tabelle \cmd{tmp\_forum\_users} dient uns als Sicherheitsbackup. Nun
können wir eine SQL-Abfrage ausführen, die uns als Basis der Virtualisierung
dient. Ziel dieser Abfrage der \cmd{serendipity\_authors}-Tabelle ist es, die
Ergebnisse in dem Format zu erhalten, wie sie in der \cmd{forum\_users}-Tabelle
stehen würden, damit die Fremdapplikation so weiterarbeiten kann, wie
sie es gewohnt ist.

\begin{ospcode}
SELECT authorid AS user\_id,
       username AS user\_name,
       password AS user\_password
  FROM serendipity\_authors
\end{ospcode}

Mittels der \cmd{X AS Y}-SQL-Syntax können die Spaltennamen der
\emph{Master}"=Tabelle in die Nomenklatur der Zieltabelle umbenannt werden.

Um nun aus dieser SQL-Abfrage eine \emph{VIEW} zu erstellen, benutzen wir
folgende Abfrage:

\osppagebreak

\begin{ospcode} 
CREATE VIEW forum\_users
         AS
     SELECT authorid AS user\_id,
            username AS user\_name,
            password AS user\_password
       FROM serendipity\_authors
\end{ospcode}

Nach dieser Abfrage steht Ihnen die virtuelle Tabelle \cmd{forum\_users} zur
Verfügung. Dort können Sie auch problemlos weitere \cmd{SELECTS} ausführen (wie
es die Fremdsoftware gewöhnt ist) und auch neue Datensätze einfügen oder
bestehende löschen. Im Hintergrund führt MySQL dann die benötigten Aktionen
durch. 

Die \cmd{SELECT}-Abfrage in unserem Beispiel ist bewusst sehr einfach gehalten.
Tatsächlich werden Sie später jedoch sicher komplexere SQL-Statements wie
\emph{String Functions} oder \emph{Control Flow Functions}\footnote{\cmd{http://dev.mysql.com/doc/refman/5.1/en/functions.html}} einsetzen. Damit
können Sie beispielsweise \emph{IF-Weichen} in einer Abfrage einführen, um
verschiedene Datentypen und Tabellenspalten miteinander zu verketten.

Zusätzlich wird der Einsatz von \emph{Stored Procedures} und \emph{Triggers} für
Sie von Interesse sein. Wenn bestimmte Aktionen von einer Fremdanwendung an
deren Datenbanktabellen ausgeführt werden (Löschen von Gruppen etc.) können Sie
mittels eines \emph{Triggers} dafür sorgen, dass eine ähnliche Funktion auch auf
die Datenbanktabellen Serendipitys angewendet wird.



%revised
\index{Mediendatenbank}%
\index{CMS!Einbindung der Mediendatenbank}%
\section{Mediendatenbank}
\label{mdb-profi}

Die Serendipity-Mediendatenbank verfügt abseits von den normal über das Backend
zugänglichen Methoden über ein weiteres Feature, das jedoch derzeit nicht von
Plugins oder dem Kernsystem unterstützt wird.

Wenn ein Bild über das Mediendatenbank-Popup in einen Blog-Artikel eingebunden
wird (siehe Seite \pageref{Mediendatenbank-Popup}), 
sorgt ein JavaScript (aus der Datei \cmd{se\-rendipity\_editor.js}, Funktion
\cmd{serendipity\_admin\_imageselector\_\osplinebreak{}done()}) dafür, dass die URL dieses
Bildes gemeinsam mit dem entsprechenden HTML-Code in den Beitrag eingebunden
wird. 

Dies hat den Vorteil, dass beim Auslesen der Datenbank Bildverweise
bereits im Artikel enthalten sind, was eine Migration vereinfacht. Plugins
können zudem leicht eine Bild-URL aus dem Eintragstext entnehmen und z.\,B.\ wie
das Lightbox-Plugin (siehe Seite \pageref{lightbox}) erweitern.

Der Nachteil dabei ist, dass die Bild-URL unveränderbar im
Artikel steht. Wenn Sie Ihr Blog einmal auf einen neuen Server laden, sich
Ihre Verzeichnisstruktur ändert oder Sie ein Bild umbenennen, wird der
HTML-Code auf ein nicht mehr vorhandenes Bild zeigen.

Dies ließe sich nur umgehen, wenn Serendipity anstelle des HTML-Codes nur die ID
des Mediendatenbank-Objekts einbinden und dynamisch bei jedem Seitenaufruf die
korrekte URL zurückliefern würde. Der erste Schritt hierzu ist für Serendipity 1.1
bereits gemacht worden, da hier die ID eines Bildes in einem HTML-Kommentar mit
ausgeliefert wird. Es existieren jedoch noch keine weiteren Plugins, die diesen
Kommentar aufbereiten.

\label{mdb-by-id}%
Dennoch bietet die Serendipity-Mediendatenbank intern bereits die Möglichkeit,
ein Bild anhand einer ID auszuliefern. Konkret können Sie beispielsweise das
Bild mit der ID \cmd{42} wie folgt darstellen:

\begin{ospcode}
http://www.example.com/serendipity/serendipity\_admin\_image\_selector.php?
serendipity[step]=showItem\&serendipity[image]=42
\end{ospcode}

Dieser Aufruf gibt eine HTML-Seite mit einem Verweis zum Bild und der
Darstellung der Metadaten (Titel, Beschreibung \ldots) des Bildes zurück.

Diese URL können Sie also (bisher nur manuell) auch in Ihre Blog-Einträge
einbinden. Dies hat sogar drei weitere beträchtliche Vorteile: Zum einen können
beim Aufruf des Bildes Statistiken ausgewertet werden, indem die Verweisquelle
(\emph{Referrer}) des Bildes gespeichert wird. Diese Verweise werden in der
Darstellung der Eigenschaften eines Objektes mit ausgegeben und dienen Ihnen
als Anhaltspunkt, von wo aus auf Ihr Bild verwiesen wird.

Zum anderen bietet diese Art der Einbindung den Vorteil, dass Zugriffsrechte
ausgewertet werden können. Zugriffsrechte können auf Verzeichnisebene im
Serendipity-Backend vergeben (siehe Seite \pageref{mdb-zugriffsrechte})
und entgegen dem direkten Aufruf per URL auch mit dieser Technik ausgewertet werden. 
So kann dann ein Besucher ohne Kenntnis der direkten URL Ihr Bild nicht aufrufen.

Drittens können Sie anhand weiterer URL-Variablen bei obigem Aufruf steuern, in
welcher Größe das Bild zurückgegeben werden soll. Dazu binden Sie das Script
direkt als Bildziel in einen HTML-Code wie folgenden ein:

\begin{ospcode}
<img
src='http://www.example.com/serendipity/serendipity\_admin\_image\_selector
.php?serendipity[step]=showItem\&serendipity[image]=42\&serendipity[show]=
full\&serendipity[resizeWidth]=200' />
\end{ospcode}

Dadurch wird das Bild automatisch mit einer Breite von 200 Pixeln skaliert.
Alternativ können Sie mittels \cmd{serendipity[resizeHeight]} auch die Bildhöhe
angeben oder beide Parameter miteinander verbinden. Der URL-Parameter
\cmd{serendipity[show]} kann folgende Werte haben:

\begin{ospdescription}
\ospitem{\cmd{full}} zeigt das Originalbild an.
\ospitem{\cmd{thumb}} zeigt das Vorschaubild an.
\ospitem{\cmd{redirect}} führt eine Browser-Weiterleitung zum Originalbild durch.
\ospitem{\cmd{redirectThumb}} führt eine Browser-Weiterleitung zum Vorschaubild durch. Ohne Angabe des Wertes wird eine HTML-Seite mit den Bildinformationen angezeigt.
\end{ospdescription}

Diese Art des Aufrufs macht es Serendipity möglich, auch als Bilddatenbank zu
einem fremden Content-Management-System genutzt zu werden. 

Dabei muss das CMS die Serendipity-Mediendatenbank lediglich per Pop\-up-Fenster
z.\,B.\ via JavaScript aufrufen. Die URL für dieses Popup lautet 
\cmd{http://www.example.com/serendipity/serendipity\_admin\_image\_\osplinebreak{}selector.php}
und kann zahlreiche URL-Variablen enthalten, die für eine Übergabe wichtig sind:

\begin{ospdescription}
\ospitem{\cmd{serendipity[only\_path]}} kann einen Pfadnamen enthalten, den das
Mediendatenbank-Popup auslesen soll.

\ospitem{\cmd{serendipity[htmltarget]}} enthält die eindeutige ID eines
HTML-Elementes, in den der Rückgabewert des Popups geschrieben werden soll. Wenn
das CMS z.\,B. ein Feld wie \cmd{<input type='hidden'
name='data[foreign\_image]'\osplinebreak{} id='id\_foreign\_image' value='' />} ausgibt, müssen
Sie der\osplinebreak{} Mediendatenbank die Variable
\cmd{serendipity[htmltarget]=id\_fo\-reign\_image} übergeben. Andernfalls kann das
JavaScript keinen\osplinebreak{} Rückgabewert an das CMS liefern.

Wenn ein Wert für die Variable \cmd{serendipity[filename\_only]} gesetzt
wird, gibt das Popup-Fenster lediglich einen Dateinamen zurück. Ansonsten
liefert das Popup den vollständigen HTML-Code zur Darstellung eines Bildes.

\end{ospdescription}

Weiterhin muss das fremde CMS dafür sorgen, dass die Datei
\cmd{serendipity""\_editor.js} via JavaScript eingebunden wird, damit das Popup
auf die öffnende Seite (\cmd{parent.window.opener\ldots}) zugreifen kann. Alle
zurückgelieferten Werte und angesprochenen JavaScript-Funktionen
können Sie nach Belieben über die Template-Dateien \cmd{admin/media\_choose.tpl}
an Ihr CMS anpassen. Suchen Sie in dieser Datei nach dem Einsatz der 
Funktion \cmd{serendipity\_imageSelector\_done()}.

Es ist Ihrer Art der Einbindung überlassen, ob Serendipity direkt die URL zu
einem Bild für die Verwendung in Ihrem CMS-Artikel zurückliefert oder nur 
eine ID der Datei, die Sie dann später über das CMS
automatisiert an die URL zu der oben beschriebenen Bildausgabe weitergeben.

Zwar greift Serendipity auf eine eigene User-Datenbank zurück\footnote{Diese
könnten Sie theoretisch selbst per MySQL5-Views oder Proxy-Tabellen an die User-Datenbank
des CMS ankoppeln.}, aber wenn Serendipity auf demselben Server läuft
wie das Content-Management"=System, können PHP-Sessions bzw. Cookies zur
automatischen Anmeldung an Serendipity problemlos durchgereicht werden. Notfalls
kann ein fester Login vom CMS auch per URL-Variable an den Aufruf der
Serendipity"=Mediendatenbank weitergereicht werden:
\cmd{serendipity\_admin\_image\_selector.""php?http\_auth\_user=\cmdvar{benutzername}\&http\_auth\_pw=\cmdvar{passwort}}. 

\index{Import}%
\section{Importer}

Serendipity kann Daten aus zahlreichen Blog-Systemen importieren. Dazu dienen
eigene PHP-Klassen, die in Dateien des Verzeichnisses \cmd{include/ad\-min/importers} 
definiert werden.

Die Basisklasse \cmd{Serendipity\_Import} wird in der Datei
\cmd{include/admin/""import.inc.php} festgelegt. Jede Importerdatei muss eine
eigene Klasse von diesem Objekt ableiten. Der jeweilige Klassenname muss dabei
\cmd{Seren\-dipity\_Import\_\cmdvar{Name}} lauten. Der Dateiname der PHP-Datei mit
dieser Klasse kann beliebig gewählt werden, darf aber keine Sonderzeichen
enthalten. 

Am Ende der PHP-Datei des jeweiligen Importers muss der Name der Klasse mittels

\begin{ospcode}
return 'Serendipity\_Import\_Name';
\end{ospcode} 

zurückgeliefert werden. Wenn Sie einen eigenen Importer für ein neues System 
erstellen wollen, ist es am einfachsten, als Vorlage eine bestehende
Import-Datei heranzuziehen. Die Datei
\cmd{include/admin/importers/""textpattern.inc.php} bietet sich dafür an, da sie
am wenigsten unnötige Zusatzabfragen beinhaltet.

Jede Importer-Klasse besitzt drei Klassenvariablen: \cmd{\$this->info} enthält
ein Array mit Informationen zum Importer. Der Array-Schlüssel \cmd{software}
enthält als Wert den dargestellten Namen der Import-Klasse im Backend.
Die Variable \cmd{\$this->inputFields} enthält ein Array, das alle Konfigurationsoptionen des
Plugins bestimmt, die vom Benutzer beim Import angegeben werden müssen.
Dabei enthält \cmd{\$this->data} beim Importvorgang die Eingaben des Benutzers
für diese Konfigurationsoptionen. 

Jede Import-Klasse muss folgende Methoden implementieren:

\begin{ospdescription}
\ospitem{\cmd{getImportNotes()}}
Diese Methode liefert etwaige Zusatzinfos zum Importer zurück, die im Backend
vor dem Import ausgegeben werden sollen. Üblicherweise informiert diese Methode
den Benutzer über Einschränkungen oder Besonderheiten des Importers.

\ospitem{\cmd{Serendipity\_Import\_Name()}}
Der Konstruktor der PHP-Klasse muss die Arrays \cmd{\$this->data} und
\cmd{\$this->inputFields} füllen. Für die Eingabefelder wird dabei ein verschachteltes
Array angelegt. Jedes Unter-Array enthält dabei die Definition der
Konfigurationsfelder und greift dabei auf folgende Ar\-ray-Schlüssel zurück:

\begin{ospdescription}
\ospitem{\cmd{text}} enthält die Beschreibung der Konfigurationsoption.
\ospitem{\cmd{type}} bestimmt, wie die Konfigurationsoption dargestellt
wird. Mögliche Werte: \cmd{input} (Eingabefeld), \cmd{list} (Ausklappfeld),
\cmd{bool} (Ja/""Nein). Die Typen stimmen mit denen überein, die auch für die
Konfigurationsoptionen des Blogs in der \cmd{include/tpl/config\_""local.inc.php}
verfügbar sind (siehe Seite \pageref{configlocal}).
\ospitem{\cmd{name}} bestimmt den Feldnamen der Konfigurationsoption, um später
innerhalb des \cmd{\$this->data}-Arrays darauf zugreifen zu können.
\ospitem{\cmd{default}} enthält den Standardwert der Option.
\end{ospdescription}

\ospitem{\cmd{validateData()}}
Überprüft die Benutzereingaben beim Import auf Gültigkeit. Hier\osplinebreak{} können z.\,B.\
Datenbankzugänge getestet oder Eingabefelder auf ihren Inhalt geprüft werden. 

\ospitem{\cmd{getInputFields()}}
Dient als Kapselungsmethode, um das Array \cmd{\$this->inputFields} zurückzuliefern.

\ospitem{\cmd{import()}}
Diese Methode führt den eigentlichen Import durch. In jedem der Importer werden
hier die Ursprungsdaten des fremden Systems eingelesen und die
Serendipity-Datenbanktabellen entsprechend befüllt.

Als Erstes werden dabei meist alle Redakteure des fremden Systems ausgelesen
und als Serendipity-Autoren hinzugefügt. Danach werden Kategorien, Artikel und
Kommentare zugewiesen. Da beim Import die Primärschlüssel des alten Systems für
Serendipity neu vergeben werden, wird häufig mit sogenannten \cmd{Lookup-Arrays}
gearbeitet. Diese speichern die ID eines Objekts (Artikel, Kategorie \ldots) im
alten Blog-System sowie die ID bei Serendipity. So kann später beim
Durchlaufen der alten Zuordnungen von Redakteuren zu Einträgen (oder Kategorien
zu Einträgen) leicht die neue Zuordnung für Serendipity durchgeführt werden.
\end{ospdescription}

Jede Klasse kann weiterhin beliebige eigene PHP-Methoden enthalten, damit Sie
für Ihren Importer beliebige Kapselung erreichen können.

Folgende Methoden sind in der \cmd{Serendipity\_Import}-Klasse definiert und
können beliebig eingesetzt werden:

\begin{ospdescription}
\ospitem{\cmd{getCharsets()}}
Hilfsfunktion, um ein Dropdown mit möglichen Zeichensätzen (nativer Zeichensatz,
ISO-8859-1, UTF-8) in den Konfigurationsoptionen einzubinden. Die Werte werden
dabei anhand der aktuellen Konfiguration des Blogs zusammengestellt und dienen
beim Import dazu, Zeichensatzkollisionen zu vermeiden.

\ospitem{\cmd{decode(), strtr(), strtrRecursive()}}
Konvertiert eine Zeichenfolge anhand des in der Konfiguration des Importers
festgelegten Zeichensatzes in das gewünschte Zielformat des Blogs. Diese Methode
greift auf die Hilfsmethoden \cmd{strtr()} und \cmd{strtrRecursive()} zu, damit
rekursiv auch Arrays mit Zeichenketten konvertiert werden können.

\ospitem{\cmd{getTransTable()}}
Hilfsmethode, um HTML-Sonderzeichen zurück in native Zeichen umzuwandeln.

\ospitem{\cmd{nativeQuery()}}
Führt eine Datenbankabfrage in der Datenbank des Zielsystems aus. Die normale
\cmd{serendipity\_db\_query()}-Funktion operiert weiterhin auf der
Serendipity-Datenbank. 

\end{ospdescription}

\index{Template-API}%
\index{Smarty!Alternativen}%
\section{Template Processor/Template API}
\label{templateapi}

Serendipity ist grundsätzlich auf den Einsatz mit dem \emph{Smarty}-Template"=Framework 
ausgerichtet. Die Vorteile von Smarty sind eine auch für
Nicht-Programmierer erlernbare Syntax, einfache Integration von Zusatzfunktionen
und eine hohe Ausführungsgeschwindigkeit. Zudem wird Smarty aktiv
weiterentwickelt und verfügt über eine hervorragende Online"=Dokumentation und
Verbreitung. 

Dennoch besteht gerade bei PHP-Entwicklern oft der Wunsch, ohne Umwege eines
Template-Frameworks Inhalte ausgeben zu wollen. Daher bietet Serendipity die
Möglichkeit an, Templates mit beliebigen eigenen Ausgabestrukturen einzusetzen.
An diese Personen richtet sich Serendipitys Template API -- Sie sollten PHP
gut beherrschen, wenn Sie diese API einsetzen möchten.

Dabei bedient sich Serendipity einer Art \emph{Connector-API}. Dank dem Einsatz
von Smarty werden alle Template-Variablen über eine einheitliche API
weitergereicht und Template-Dateien mittels weniger Funktionen ausgegeben. 

Wenn Sie ein eigenes Template-Framework einsetzen wollen, benötigen Sie
lediglich eine Art Emulation der Smarty-Funktionen. Serendipity bietet Ihnen
dazu ein Grundgerüst an und liefert beispielhaft zwei Template-Layer mit:
\cmd{templates/default-php} (PHP-Templates) und \cmd{templates/default""-xml}
(XML/XSLT-Templates). 

Eine eigenständige API kann vom Template mit einer \cmd{template.inc.php}
(ähnlich wie eine \cmd{config.inc.php}-Datei) eingebunden werden. Diese\osplinebreak{}
PHP-Datei muss die jeweilige Emulator-Klasse laden.
\cmd{templates/default""-php/template.inc.php} tut dies wie folgt:

\begin{ospcode}
<?php
include_once S9Y\_INCLUDE\_PATH . 'include/template\_api.inc.php'; 
\$GLOBALS['template'] = new serendipity\_smarty\_emulator\_xml(); 
\$GLOBALS['serendipity']['smarty'] =\& \$GLOBALS['template'];
?>
\end{ospcode}

In der ersten Zeile wird die Serendipity-Emulationsklasse geladen, in der
zweiten und dritten die Klasse als Ersatz des
\cmd{\$serendipity['smarty']}-Objekts.

Für alle Serendipity-Funktionen bleibt dabei der Zugriff auf das
Template-Framework so erhalten, als käme Smarty zum Einsatz. In Wirklichkeit
kümmert sich jedoch die Emulationsklasse um die Ausgabe.

Sie können an dieser Stelle jedes beliebige Objekt einsetzen, solange es
folgende Methoden implementiert:

\begin{ospdescription}
\ospitem{\cmd{assign()}}
Weist eine Template-Variable zu.

\ospitem{\cmd{assign\_by\_ref()}}
Weist eine Template-Variable als Referenz zu.

\ospitem{\cmd{call()}}
Rufen Benutzer in Ihren Templates Smarty-Funktionen auf, dient die Methode
\cmd{call()} als Zwischenstufe zum Aufruf der tatsächlichen\osplinebreak{} PHP-Funktion.

\ospitem{\cmd{display()}}
Gibt den Inhalt einer Template-Datei aus.

\ospitem{\cmd{trigger\_error()}}
Gibt eine Fehlermeldung aus.

\ospitem{\cmd{getdefault()}}
Liefert den Wert einer durch \cmd{assign()} gesetzten Template-Variable zurück.

\ospitem{\cmd{fetch()}}
Bindet eine Unter-Template-Datei ein und leitet deren Inhalt weiter an eine
Template-Variable. Dies wird dazu verwendet, um kleine Template-Dateien wie
\cmd{comments.tpl} in eine große Datei (\cmd{entries.""tpl}) einzubinden.
\end{ospdescription} 

\index{XSLT}%
Für PHP und XSLT sind die Beispiel-Emulatorklassen in der Datei
\cmd{include/""template\_api.inc.php} enthalten. Diese sollten Sie als Vorlage für
etwaige Eigenentwicklungen nutzen.

Das Prinzip der PHP-Emulation ist technisch recht simpel. Sie benötigt anstelle
der Smarty-Template-Dateien einfache PHP-Dateien. Während in Smarty-Templates
Variablen mittels \ospsmarty{Variable} ausgegeben werden,\osplinebreak{} muss dies in PHP
mittels \cmd{<?php echo \$Variable; ?>} erfolgen. Daher müssen für ein
PHP-Template alle \cmd{.tpl}-Dateien in das entsprechende Format konvertiert
werden. Smarty-Modifier und Smarty-Funktionen müssen ebenfalls entsprechend der
PHP-Syntax abgeändert werden, wie auch Smar\-ty-Sprachkonstrukte (z.\,B.\  
\cmd{\{if\ldots\}\ldots\{/if\}}).

Beispielhaft wurde das für einige Template-Dateien des Verzeichnisses
\cmd{tem\-plates/default-php/} bereits durchgeführt. Dieses
Vorhaben ist jedoch nicht komplettiert, da de facto wenig Nachfrage nach einem
PHP-Template-System besteht. Das Smarty-Framework ist bereits so leistungsfähig,
dass die Mitglieder der Serendipity-Community dieses System favorisieren und
dafür Templates entwickeln.

Die XML-Emulation arbeitet dabei viel simpler. Sie weist einfach alle
Template"=Variablen einem eigenen XML-Element zu und schachtelt Arrays
entsprechend. Die Darstellung derartiger XML-Elemente kann mittels
XSLT-Stylesheets oder -Transformationen erfolgen.


\ospvacat

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "serendipity"
